<bm_lib_func_zip_deploy><id>4180575</id><container_id>4133367</container_id><func_type>1</func_type><data>[B@6e3f5982</data><_children><bm_lib_func><id>641265976</id><name><![CDATA[getDateFromString]]></name><variable_name><![CDATA[getDateFromString]]></variable_name><description></description><return_type>5</return_type><func_type>1</func_type><function_id>641265975</function_id><date_modified>1549578186000</date_modified><guid><![CDATA[bm_lib_func_util_getDateFromString]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>641265975</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getDateFromString_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435941000</date_modified><guid><![CDATA[09db6fde-ec8e-4a18-a1d7-a0f9c42a0f4a]]></guid><script_size>241</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[DATE_FORMAT_PREFERENCE_HYPHEN = "yyyy-MM-dd";
DATE_FORMAT_PREFERENCE_SLASH = "MM/dd/yyyy";
returnDateObj = getdate();
dateString = argumentDateString;

if (dateString <> "" AND NOT isnull(dateString)){
	//timezone = util.getUserTimeZone();
	dateString = substring(dateString, 0, 10);
	
	if(find(dateString, "/") <> -1) {
		returnDateObj = strtojavadate(dateString, DATE_FORMAT_PREFERENCE_SLASH);
	}else{
		returnDateObj = strtojavadate(dateString, DATE_FORMAT_PREFERENCE_HYPHEN); 
	}
}
return returnDateObj;]]></script_text><_children><bm_lib_func_assoc><id>641265978</id><caller_func_id>641265975</caller_func_id><called_lib_func_id>170675968</called_lib_func_id><rule_area><![CDATA[getDateFromString]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1549578186000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[5e3d4a5d-fce4-4432-b737-a21ddb5e4dab]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>641265977</id><bm_lib_func_id>641265976</bm_lib_func_id><param_name><![CDATA[argumentDateString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1549578186000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getDateFromString.bm_lib_func_param_argumentDateString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814666</id><name><![CDATA[getIntListDict]]></name><variable_name><![CDATA[getIntListDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>8</return_type><func_type>1</func_type><function_id>4814665</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getIntListDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814665</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getIntListDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435924000</date_modified><guid><![CDATA[LEGACY_4814665]]></guid><script_size>144</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  getIntListDict - Get the integer[] from dict("integer[]")
  param:
    dictionary
    dictionaryKey
    defaultList
  return 
    integer[]
*/
result = defaultList;

if ( containskey(dictionary, dictionaryKey) ) {
  result = get(dictionary, dictionaryKey);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814667</id><bm_lib_func_id>4814666</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>17</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getIntListDict.bm_lib_func_param_dictionary_17]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814668</id><bm_lib_func_id>4814666</bm_lib_func_id><param_name><![CDATA[dictionaryKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getIntListDict.bm_lib_func_param_dictionaryKey_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814669</id><bm_lib_func_id>4814666</bm_lib_func_id><param_name><![CDATA[defaultList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getIntListDict.bm_lib_func_param_defaultList_7]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906063</id><name><![CDATA[getStringAttribute]]></name><variable_name><![CDATA[getStringAttribute]]></variable_name><description><![CDATA[Obtains the value of a String attribute.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4906062</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getStringAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906062</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getStringAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435919000</date_modified><guid><![CDATA[LEGACY_4906062]]></guid><script_size>180</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = "";

lookupKey = docNum + delimiter + commerceField;

if (containskey(stringsDict, lookupKey)) {
	result = get(stringsDict, lookupKey);
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906064</id><bm_lib_func_id>4906063</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getStringAttribute.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906065</id><bm_lib_func_id>4906063</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getStringAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906066</id><bm_lib_func_id>4906063</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getStringAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906067</id><bm_lib_func_id>4906063</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getStringAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722730</id><name><![CDATA[getAssetValue]]></name><variable_name><![CDATA[getAssetValue]]></variable_name><description><![CDATA[NOT USED. this function returns the requested attribute value from the assets string]]></description><return_type>1</return_type><func_type>1</func_type><function_id>15722729</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getAssetValue]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722729</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAssetValue_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435932000</date_modified><guid><![CDATA[testconcur_10773769]]></guid><script_size>639</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////util.getAssetValue
//////parameters:
//////assetStr		string		contain all assets information in the format: att1_asset1$$att2_asset1...@@att1_asset2$$att1_asset2...@@
//////pi			string		the part number
//////attIndex		integer		the index of the attribute on the asset string
//////attType		string		CURRENCY/FLOAT/STRING
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ASSET_DELIMITER = "@@";
INTERNAL_DELIMITER = "$$";
assetsArray = string[];
assetLine = "";
assetAttValueArr = string[];
ret = "";
debugMode = false;

assetsArray = split(assetStr, ASSET_DELIMITER);//split the Asset string into an array. each array cell will contain one asset string delimited with "$$"
if(debugMode){
	print "assetsArray: ";
	print assetsArray;
}

if(NOT(isempty(assetsArray))){
	for asset in assetsArray {//loop through all assets to find the requested pi (parameter) string
		if (find(asset, pi + INTERNAL_DELIMITER) > -1) {
			assetLine = asset;
			break;
		}
	}
}

if(debugMode){
	print "assetLine: " + assetLine;
}

if(assetLine <> ""){//if the required asset pi was found among the assetsString_Quote
	assetAttValueArr = split(assetLine, INTERNAL_DELIMITER);
	if(debugMode){
		print "sizeofarray(assetAttValueArr): " + string(sizeofarray(assetAttValueArr));
	}
	if(NOT(isempty(assetAttValueArr)) AND attIndex < sizeofarray(assetAttValueArr)){	
		ret = assetAttValueArr[attIndex];
	}
}
if(debugMode){
	print "ret: " + ret;
}

if(ret == "" AND (attType == "CURRENCY" OR attType == "FLOAT")){//return string for currency/float attribute should be 0.0
	ret = "0.0";
}

if(debugMode){
	print "ret: " + ret;
}

return ret;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722731</id><bm_lib_func_id>15722730</bm_lib_func_id><param_name><![CDATA[assetStr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getAssetValue.bm_lib_func_param_assetStr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722732</id><bm_lib_func_id>15722730</bm_lib_func_id><param_name><![CDATA[pi]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getAssetValue.bm_lib_func_param_pi_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722733</id><bm_lib_func_id>15722730</bm_lib_func_id><param_name><![CDATA[attIndex]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547405000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getAssetValue.bm_lib_func_param_attIndex_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722734</id><bm_lib_func_id>15722730</bm_lib_func_id><param_name><![CDATA[attType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getAssetValue.bm_lib_func_param_attType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814671</id><name><![CDATA[getFloatListDict]]></name><variable_name><![CDATA[getFloatListDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>9</return_type><func_type>1</func_type><function_id>4814670</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getFloatListDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814670</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getFloatListDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435924000</date_modified><guid><![CDATA[LEGACY_4814670]]></guid><script_size>144</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  getFloatListDict - Get the float[] from dict("float[]")
  param:
    dictionary
    dictionaryKey
    defaultList
  return 
    float[]
*/
result = defaultList;

if ( containskey(dictionary, dictionaryKey) ) {
  result = get(dictionary, dictionaryKey);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814672</id><bm_lib_func_id>4814671</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>18</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getFloatListDict.bm_lib_func_param_dictionary_18]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814673</id><bm_lib_func_id>4814671</bm_lib_func_id><param_name><![CDATA[dictionaryKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getFloatListDict.bm_lib_func_param_dictionaryKey_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814674</id><bm_lib_func_id>4814671</bm_lib_func_id><param_name><![CDATA[defaultList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getFloatListDict.bm_lib_func_param_defaultList_8]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814656</id><name><![CDATA[getIntDict]]></name><variable_name><![CDATA[getIntDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>3</return_type><func_type>1</func_type><function_id>4814655</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getIntDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814655</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getIntDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435923000</date_modified><guid><![CDATA[LEGACY_4814655]]></guid><script_size>169</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* 
getIntDict
*/

result = defaultValue;

if ( containskey(dictionary, key) ) {
	result = get(dictionary, key);
} 
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814657</id><bm_lib_func_id>4814656</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getIntDict.bm_lib_func_param_dictionary_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814658</id><bm_lib_func_id>4814656</bm_lib_func_id><param_name><![CDATA[key]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getIntDict.bm_lib_func_param_key_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814659</id><bm_lib_func_id>4814656</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getIntDict.bm_lib_func_param_defaultValue_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5942355</id><name><![CDATA[Get Approval Email]]></name><variable_name><![CDATA[getApprovalEmail]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>5942354</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getApprovalEmail]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5942354</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getApprovalEmail_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435930000</date_modified><guid><![CDATA[LEGACY_5942354]]></guid><script_size>808</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util.getApprovalEmail

userLogin - String, _system_user_login
stringsDict - String Dictionary, Can contain new information if necessary

Returns a commerce string

Used to populate the approval email attributes 
*/
QUOTE_DOC_NUM = "1";
approvalEmailSet = bmql("SELECT mgrEmail, vpEmail, svpEmail, gmEmail, evpEmail, cfoEmail FROM approverNames WHERE userLogin = $userLogin");
actionName = "";
if ( containskey( stringsDict, "actionName" ) ){
	actionName = get( stringsDict, "actionName" );
}
mgrEmail = "";
vpEmail = "";
svpEmail = "";
gmEmail = "";
evpEmail = "";
cfoEmail = "";
// Cycle through the returns and save the information
// We only want to keep one result
for approvalEmail in approvalEmailSet{
	mgrEmail = get(approvalEmail, "mgrEmail");
	vpEmail = get(approvalEmail, "vpEmail" );
	svpEmail = get(approvalEmail, "svpEmail");
	gmEmail = get(approvalEmail, "gmEmail");
	evpEmail = get(approvalEmail, "evpEmail");
	cfoEmail = get(approvalEmail, "cfoEmail" );
}

retStr = QUOTE_DOC_NUM + "~mgrEmail_quote~" + mgrEmail + "|" 
  		+ QUOTE_DOC_NUM + "~vPEmail_quote~" + vpEmail + "|" 
		+ QUOTE_DOC_NUM + "~sVPEmail_quote~" + svpEmail + "|" 
		+ QUOTE_DOC_NUM + "~gMEmail_quote~" + gmEmail + "|"
		+ QUOTE_DOC_NUM + "~evpEmail_quote~" + evpEmail + "|" 
		+ QUOTE_DOC_NUM + "~cFOEmail_quote~" + cfoEmail + "|";


if ( actionName == "submit" OR actionName == "request approval"){
	retStr = retStr + QUOTE_DOC_NUM + "~mgrLogin_quote~" + mgrEmail + "|" 
		+ QUOTE_DOC_NUM + "~vpLogin_quote~" + vpEmail + "|" 
		+ QUOTE_DOC_NUM + "~svpLogin_quote~" + svpEmail + "|" 
		+ QUOTE_DOC_NUM + "~gmLogin_quote~" + gmEmail + "|"
		+ QUOTE_DOC_NUM + "~evpLogin_quote~" + evpEmail + "|" 
		+ QUOTE_DOC_NUM + "~cfoLogin_quote~" + cfoEmail + "|";
}

return retStr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5942357</id><bm_lib_func_id>5942355</bm_lib_func_id><param_name><![CDATA[userLogin]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getApprovalEmail.bm_lib_func_param_userLogin_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5942358</id><bm_lib_func_id>5942355</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getApprovalEmail.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>201339659</id><name><![CDATA[Get Difference in Months]]></name><variable_name><![CDATA[getDifferenceInMonths]]></variable_name><description><![CDATA[Gets the difference in months between two dates. KA. 11-3-2015.]]></description><return_type>3</return_type><func_type>1</func_type><function_id>201339658</function_id><date_modified>1626948723000</date_modified><guid><![CDATA[bm_lib_func_util_getDifferenceInMonths]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>201339658</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getDifferenceInMonths_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948723000</date_modified><guid><![CDATA[8427e62d-0513-4e1a-9582-2aa6a3cbf984]]></guid><script_size>645</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//Util to get difference, in months, between 2 dates
//Take 2 date strings (firstDate and secondDate)as parameters
//applies to date strings in yyyy-MM-dd or MM/dd/yyyy format

firstYearVal = "";
firstMonthVal = "";
splitFirstDate = string[];

secondYearVal = "";
secondMonthVal = "";
splitSecondDate = string[];

diffMonths = 0;

if(firstDate <> ""){
	firstDateformatted = substring(firstDate, 0, 10);
	if( find(firstDateformatted,"-") <> -1 ){ 
		splitFirstDate = split(firstDateformatted, "-");
		firstYearVal = splitFirstDate[0];
		firstMonthVal = splitFirstDate[1];
	}
	elif( find(firstDateformatted, "/") <> -1 ){
		splitFirstDate = split(firstDateformatted, "/");
		firstYearVal = splitFirstDate[2];
		firstMonthVal = splitFirstDate[0];
	}
}

if(secondDate <> ""){
	secondDateFormatted = substring(secondDate, 0, 10);
	if( find(secondDateFormatted,"-") <> -1 ){ 
		splitSecondDate = split(secondDateFormatted, "-");
		secondYearVal = splitSecondDate[0];
		secondMonthVal = splitSecondDate[1];
	}
	elif( find(secondDateFormatted, "/") <> -1 ){
		splitSecondDate = split(secondDateFormatted, "/");
		secondYearVal = splitSecondDate[2];
		secondMonthVal = splitSecondDate[0];
	}
}
	

	
if(isnumber(firstYearVal) AND isnumber(firstMonthVal) AND isnumber(secondYearVal) AND isnumber(secondMonthVal)){
	
	diffMonths =  ((atoi(secondYearVal) - atoi(firstYearVal))*12) + (atoi(secondMonthVal) - atoi(firstMonthVal));
}

return diffMonths;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>201339660</id><bm_lib_func_id>201339659</bm_lib_func_id><param_name><![CDATA[firstDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948723000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getDifferenceInMonths.bm_lib_func_param_firstDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>201339661</id><bm_lib_func_id>201339659</bm_lib_func_id><param_name><![CDATA[secondDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948723000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getDifferenceInMonths.bm_lib_func_param_secondDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814661</id><name><![CDATA[getBooleanDict]]></name><variable_name><![CDATA[getBooleanDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>4814660</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getBooleanDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814660</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getBooleanDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435924000</date_modified><guid><![CDATA[LEGACY_4814660]]></guid><script_size>147</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* 
	getBooleanDict
		- get the value from the dictionary if exists. otherwise, return defaultValue;
*/

result = defaultValue;

if ( containskey(dictionary, key) ) {
	result = get(dictionary, key);
} 
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814662</id><bm_lib_func_id>4814661</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>22</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getBooleanDict.bm_lib_func_param_dictionary_22]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814663</id><bm_lib_func_id>4814661</bm_lib_func_id><param_name><![CDATA[key]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getBooleanDict.bm_lib_func_param_key_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814664</id><bm_lib_func_id>4814661</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getBooleanDict.bm_lib_func_param_defaultValue_0]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906075</id><name><![CDATA[getFloatAttribute]]></name><variable_name><![CDATA[getFloatAttribute]]></variable_name><description><![CDATA[Obtains the value of a float or currency-type attribute from floatsDict.]]></description><return_type>2</return_type><func_type>1</func_type><function_id>4906074</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getFloatAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906074</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getFloatAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435919000</date_modified><guid><![CDATA[LEGACY_4906074]]></guid><script_size>193</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = 0.0;

lookupKey = docNum + delimiter + commerceField;

if (containskey(floatsDict, lookupKey)) {
	result = get(floatsDict, lookupKey);
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906076</id><bm_lib_func_id>4906075</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getFloatAttribute.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906077</id><bm_lib_func_id>4906075</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getFloatAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906078</id><bm_lib_func_id>4906075</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getFloatAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906079</id><bm_lib_func_id>4906075</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getFloatAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4904536</id><name><![CDATA[getStdTierPricing]]></name><variable_name><![CDATA[getStdTierPricing]]></variable_name><description><![CDATA[Populates the piQtyToPriceDict with the correct Standard Tier Price for a given list of PIs and Qtys (or Transactions).]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4904535</function_id><date_modified>1626948718000</date_modified><guid><![CDATA[bm_lib_func_util_getStdTierPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4904535</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getStdTierPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948718000</date_modified><guid><![CDATA[LEGACY_4904535]]></guid><script_size>1493</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	getStdTierPricing
	-------------------
	Description:
		For a given list of PIs, imported into this function as piQtyList,
		populates the piQtyAndImplementationMethodToPriceDict dictionary with the corresponding
		tier price of the PI, based on its quantity or no. of transactions.
	
	Params:
		String priceList
		String currencyCode
		FloatDict piQtyAndImplementationMethodToPriceDict
		String[] piQtyAndImplementationMethodList
		String piDelimiter
	Returns:
		StringDict resultDict
	
	piQtyAndImplementationMethodToPriceDict:
		This is the dictionary that will be populated with values queried.
		Key: <pi_number><piDelimiter><qty_or_num_transactions>
		Value: standard tier price
		
	piQtyAndImplementationMethodList:
		Elements: <pi_number><piDelimiter><qty_or_num_transactions><piDelimiter><implementationMethod>
*/

resultDict = dict("string");

piList = string[];
tierPricingConditionsMatrix = string[][];
piQtyDict = dict("integer"); //Maps a PI to a Quantity/NumTransactions

//From our list of PIs (with Qty/Trxns and Implementation Method), extract the list of PIs only (for the BMQL query)
index = 0;

for piQty in piQtyAndImplementationMethodList {
	pricingKeys = split(piQty, piDelimiter);
	pi = pricingKeys[0];
	qty = pricingKeys[1];
	implementationMethod = pricingKeys[2];

	if (pi <> "" and isnumber(qty) and implementationMethod <> "") {
		append(piList, pi);
		tierPricingConditionsMatrix[index][0] = pi;
		tierPricingConditionsMatrix[index][1] = qty;
		tierPricingConditionsMatrix[index][2] = implementationMethod;
		index = index + 1;
	}
}

tierPricingRecords = bmql("select pi, minTierQty, maxTierQty, price, implementationMethod from stdTierPricing where priceList = $priceList and pi in $piList");


	
count = 0;
recordCount = 0;
for tierPricingCondition in tierPricingConditionsMatrix {
				lineItemPI = tierPricingCondition[0];
				lineItemQty = atoi(tierPricingCondition[1]); //No isnumber() check is needed here, because when this array was populated, the isnumber() check was already done (line 41)
				lineItemImplementationMethod = tierPricingCondition[2];
				isMatchingImplementationMethod = "N/A";
	
for tierRecord in tierPricingRecords {
	//isMatchingImplementationMethod = "N/A";
	pi = get(tierRecord, "pi");
	strMinTierQty = get(tierRecord, "minTierQty");
	strMaxTierQty = get(tierRecord, "maxTierQty");
	strPrice = get(tierRecord, "price");
	implementationMethod = get(tierRecord, "implementationMethod");

	if (strMinTierQty <> "" and strMaxTierQty <> "") {
		if (isnumber(strMinTierQty) and isnumber(strMaxTierQty)) {
			minTierQty = integer(atof(strMinTierQty));
			maxTierQty = integer(atof(strMaxTierQty));
			
			//for tierPricingCondition in tierPricingConditionsMatrix {
				//lineItemPI = tierPricingCondition[0];
				//lineItemQty = atoi(tierPricingCondition[1]); //No isnumber() check is needed here, because when this array was populated, the isnumber() check was already done (line 41)
				//lineItemImplementationMethod = tierPricingCondition[2];
				
				if (lineItemPI == pi and (implementationMethod == lineItemImplementationMethod OR implementationMethod == "" ) and lineItemQty >= minTierQty and lineItemQty <= maxTierQty) {
					if ( implementationMethod <> "" ){
						if (isnumber(strPrice)) {
						
							price = atof(strPrice);
							
							put(piQtyAndImplementationMethodToPriceDict, join(tierPricingCondition, piDelimiter), price);
							
							if ( isMatchingImplementationmethod <> "N/A" ){
								count = count + 1;
							}
							isMatchingImplementationMethod = "true";
						}
					}
					
					else{
						if ( isMatchingImplementationMethod <> "true" ){
							if ( isnumber( strPrice ) ){
							
								price = atof(strPrice);
							
								put(piQtyAndImplementationMethodToPriceDict, join(tierPricingCondition, piDelimiter), price);
								
								isMatchingImplementationMethod = "false";
								count = count + 1;
							}
						}
					}
				
				}
			}
		}
	}
	recordCount = recordCount + 1;
}
if (recordCount == 0) {
	put(resultDict, "error", "No records were returned from the stdTierPricing query");
} elif (count == 0) {
	put(resultDict, "error", "No tier prices found.");
}

put(resultDict, "count", string(count));

return resultDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4904538</id><bm_lib_func_id>4904536</bm_lib_func_id><param_name><![CDATA[priceList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948718000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getStdTierPricing.bm_lib_func_param_priceList_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904539</id><bm_lib_func_id>4904536</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948718000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getStdTierPricing.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904540</id><bm_lib_func_id>4904536</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodToPriceDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1626948718000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getStdTierPricing.bm_lib_func_param_piQtyAndImplementationMethodToPriceDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904541</id><bm_lib_func_id>4904536</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948718000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getStdTierPricing.bm_lib_func_param_piQtyAndImplementationMethodList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904542</id><bm_lib_func_id>4904536</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948718000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getStdTierPricing.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722747</id><name><![CDATA[Form Attribute Value String]]></name><variable_name><![CDATA[formAttrValueStr]]></variable_name><description><![CDATA[This util forms return string of individual attribute and is passed to setAttributes Commerce Library]]></description><return_type>1</return_type><func_type>1</func_type><function_id>15722746</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_formAttrValueStr]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722746</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_formAttrValueStr_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435933000</date_modified><guid><![CDATA[testconcur_13336796]]></guid><script_size>194</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* 
 #############################################################################
 formDelimitedString Util Library

Parameters:
dictionary (attribute dict)
key (string)
docNumber (string)
value (string)

Returns:
string "Passed:formAttrValueStr~" used for debug purposes in commerce libraries.

Description:
Used to store all pricing related result strings into attributesDict dictionary

Format:
util.formAttrValueStr(attributesDict,key,documentNumber,value);

Example:
res = util.formAttrValueStr(attributesDict,"reviseFlag_quote",1,"false"); 

 #############################################################################
*/

delim = "~";
delimPipe = "|";
combinedValue = "";

dictKey = docNumber + delim + key;
combinedValue = docNumber + delim + key + delim + value + delimPipe;
put(dictionary,dictKey,combinedValue);
//put(dictionary,key,combinedValue);

return "";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722748</id><bm_lib_func_id>15722747</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547405000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_formAttrValueStr.bm_lib_func_param_dictionary_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722749</id><bm_lib_func_id>15722747</bm_lib_func_id><param_name><![CDATA[key]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_formAttrValueStr.bm_lib_func_param_key_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722750</id><bm_lib_func_id>15722747</bm_lib_func_id><param_name><![CDATA[docNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_formAttrValueStr.bm_lib_func_param_docNumber_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722751</id><bm_lib_func_id>15722747</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_formAttrValueStr.bm_lib_func_param_value_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814684</id><name><![CDATA[uniqueList]]></name><variable_name><![CDATA[uniqueList]]></variable_name><description><![CDATA[NOT USED. Adds an element to an unique Array.If element exists, it wont be added.]]></description><return_type>10</return_type><func_type>1</func_type><function_id>4814682</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_uniqueList]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814682</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_uniqueList_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435910000</date_modified><guid><![CDATA[LEGACY_4814682]]></guid><script_size>160</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  uniqueList - To add a value into a list. The list is unique. If the input list contains the input value, it won't add to the list.
    param: 
      inputList - String[];
      inputValue - String
    return 
      string[]
*/

result = inputList;

if ( trim(inputValue) <> "" and findinarray(inputList, inputValue) == -1 ) {
  append(result, inputValue);
} 
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814685</id><bm_lib_func_id>4814684</bm_lib_func_id><param_name><![CDATA[inputList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_uniqueList.bm_lib_func_param_inputList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814686</id><bm_lib_func_id>4814684</bm_lib_func_id><param_name><![CDATA[inputValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_uniqueList.bm_lib_func_param_inputValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5160023</id><name><![CDATA[Format Price]]></name><variable_name><![CDATA[fomatPrice]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>5160022</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_fomatPrice]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5160022</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_fomatPrice_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435922000</date_modified><guid><![CDATA[LEGACY_5160022]]></guid><script_size>1056</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  BML Util (formatPrice):
      - Format PriceFormats float into currency format (returns a string)
  param:
    price - Float
    currencySymbol - String
	numDecimals  - Integer
  return 
    String
*/


thousandSep = ",";
decimalPt = ".";

price1 = 0.0;
array = string[15];
i = 0;
price1 = round(price,numDecimals);
neg = false;
if (price1 < 0) {
  price1 = price1 * -1;
  neg = true;
}

decimal = substring(string(round(price1 % 1,numDecimals)),1);

for item in array {
  
  array[i] = string(integer(price1 % 1000));
  price1 = price1/1000;
  
  if (price1 < 1 ) { break; }
  i = i + 1;
}

newArray = string[i+1];


j = 0;
for newItem in newArray {
  if (j == 0 OR len(array[i]) == 3) {
    newArray[j] = array[i];
  } elif (len(array[i]) == 2) {
    newArray[j] = "0" + array[i];
  } elif (len(array[i]) == 1) {
    newArray[j] = "00" + array[i];
  }
  i = i - 1;
  j = j + 1;
}



if (len(decimal) < 3) {
  decimal = decimal + "0";
}

if (decimalPt <> ".") {
  decimal = replace(decimal,".",decimalPt);	
}

formattedPrice = join(newArray,thousandSep);
if (neg) {
  formattedPrice = "-" + formattedPrice;
}
return currencySymbol + formattedPrice + decimal ;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5160025</id><bm_lib_func_id>5160023</bm_lib_func_id><param_name><![CDATA[price]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_fomatPrice.bm_lib_func_param_price_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5160026</id><bm_lib_func_id>5160023</bm_lib_func_id><param_name><![CDATA[currencySymbol]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_fomatPrice.bm_lib_func_param_currencySymbol_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5160027</id><bm_lib_func_id>5160023</bm_lib_func_id><param_name><![CDATA[numDecimals]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547403000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_fomatPrice.bm_lib_func_param_numDecimals_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722739</id><name><![CDATA[Set Config Att Values for RE]]></name><variable_name><![CDATA[setConfigAttValuesForRE]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>15722738</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_setConfigAttValuesForRE]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722738</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setConfigAttValuesForRE_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435932000</date_modified><guid><![CDATA[testconcur_10476674]]></guid><script_size>494</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
isSize
attributeName
valuesDelString
*/

ASSET_DELIMITER = "@@";
INTERNAL_DELIMITER = "$$";
NEW_DEL = "*|*";
VALUE = 1;

if(find(valuesDelString,attributeName)==-1){
	return "FALSE";
}

newValuesDelString = replace(valuesDelString,attributeName,NEW_DEL+attributeName);

attributesArray = split(newValuesDelString ,NEW_DEL);

retSize = 0;
ret = "";
for entry in attributesArray{
	if(NOT(startswith(entry,attributeName))){continue;}
	if(isSize){retSize = retSize + 1; ret = string(retSize)+INTERNAL_DELIMITER;continue;}
	tempArr = split(entry,ASSET_DELIMITER);
	CurData = split(tempArr[0],INTERNAL_DELIMITER);
	ret = ret + curData[VALUE] + INTERNAL_DELIMITER;
}

ret = substring(ret,0,-2);
return ret;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722740</id><bm_lib_func_id>15722739</bm_lib_func_id><param_name><![CDATA[isSize]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1508547405000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setConfigAttValuesForRE.bm_lib_func_param_isSize_0]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722741</id><bm_lib_func_id>15722739</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setConfigAttValuesForRE.bm_lib_func_param_attributeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722742</id><bm_lib_func_id>15722739</bm_lib_func_id><param_name><![CDATA[valuesDelString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547405000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setConfigAttValuesForRE.bm_lib_func_param_valuesDelString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814678</id><name><![CDATA[getStrListDict]]></name><variable_name><![CDATA[getStrListDict]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>4814676</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getStrListDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814676</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getStrListDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435910000</date_modified><guid><![CDATA[LEGACY_4814676]]></guid><script_size>144</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  getStrListDict - Get the string[] from dict("string[]")
  param:
    dictionary
    dictionaryKey
    defaultList
  return 
    string[]
*/
result = defaultList;

if ( containskey(dictionary, dictionaryKey) ) {
  result = get(dictionary, dictionaryKey);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814679</id><bm_lib_func_id>4814678</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getStrListDict.bm_lib_func_param_dictionary_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814680</id><bm_lib_func_id>4814678</bm_lib_func_id><param_name><![CDATA[dictionaryKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getStrListDict.bm_lib_func_param_dictionaryKey_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814681</id><bm_lib_func_id>4814678</bm_lib_func_id><param_name><![CDATA[defaultList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getStrListDict.bm_lib_func_param_defaultList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906069</id><name><![CDATA[getIntegerAttribute]]></name><variable_name><![CDATA[getIntegerAttribute]]></variable_name><description><![CDATA[Obtains the value of an integer-type attribute from the integersDict.]]></description><return_type>3</return_type><func_type>1</func_type><function_id>4906068</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getIntegerAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906068</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getIntegerAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435919000</date_modified><guid><![CDATA[LEGACY_4906068]]></guid><script_size>193</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = 0;

lookupKey = docNum + delimiter + commerceField;

if (containskey(integersDict, lookupKey)) {
	result = get(integersDict, lookupKey);
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906070</id><bm_lib_func_id>4906069</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getIntegerAttribute.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906071</id><bm_lib_func_id>4906069</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getIntegerAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906072</id><bm_lib_func_id>4906069</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getIntegerAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906073</id><bm_lib_func_id>4906069</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getIntegerAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906088</id><name><![CDATA[putIntegerAttribute]]></name><variable_name><![CDATA[putIntegerAttribute]]></variable_name><description><![CDATA[Puts the value of an integer attribute into the integersDict.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>4906087</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_putIntegerAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906087</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_putIntegerAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435920000</date_modified><guid><![CDATA[LEGACY_4906087]]></guid><script_size>135</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[key = docNum + delimiter + commerceField;

put(integersDict, key, value);

return true;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906089</id><bm_lib_func_id>4906088</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_putIntegerAttribute.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906090</id><bm_lib_func_id>4906088</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_putIntegerAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906091</id><bm_lib_func_id>4906088</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_putIntegerAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906092</id><bm_lib_func_id>4906088</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_putIntegerAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906093</id><bm_lib_func_id>4906088</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_putIntegerAttribute.bm_lib_func_param_value_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814698</id><name><![CDATA[customAtof]]></name><variable_name><![CDATA[customAtof]]></variable_name><description></description><return_type>2</return_type><func_type>1</func_type><function_id>4814697</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_customAtof]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814697</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_customAtof_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435911000</date_modified><guid><![CDATA[LEGACY_4814697]]></guid><script_size>120</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = defaultValue;

if (  isnumber(inputValue) ) {
	result = atof(inputValue);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814699</id><bm_lib_func_id>4814698</bm_lib_func_id><param_name><![CDATA[inputValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_customAtof.bm_lib_func_param_inputValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814700</id><bm_lib_func_id>4814698</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_customAtof.bm_lib_func_param_defaultValue_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4805741</id><name><![CDATA[require_javascript]]></name><variable_name><![CDATA[require_javascript]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>4805740</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_require_javascript]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4805740</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_require_javascript_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435923000</date_modified><guid><![CDATA[LEGACY_4805740]]></guid><script_size>67</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[return "";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4805743</id><bm_lib_func_id>4805741</bm_lib_func_id><param_name><![CDATA[filename]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_require_javascript.bm_lib_func_param_filename_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906095</id><name><![CDATA[putFloatAttribute]]></name><variable_name><![CDATA[putFloatAttribute]]></variable_name><description><![CDATA[Puts the value of a float attribute into the floatsDict.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>4906094</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_putFloatAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906094</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_putFloatAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435920000</date_modified><guid><![CDATA[LEGACY_4906094]]></guid><script_size>135</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[key = docNum + delimiter + commerceField;

put(floatsDict, key, value);

return true;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906096</id><bm_lib_func_id>4906095</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_putFloatAttribute.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906097</id><bm_lib_func_id>4906095</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_putFloatAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906098</id><bm_lib_func_id>4906095</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_putFloatAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906099</id><bm_lib_func_id>4906095</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_putFloatAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906100</id><bm_lib_func_id>4906095</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547402000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_putFloatAttribute.bm_lib_func_param_value_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>958769667</id><name><![CDATA[Fetch Userlogin for Manager]]></name><variable_name><![CDATA[fetchUserloginForManager]]></variable_name><description><![CDATA[(CSYS-99935, NP. 15-Jul-2020) This library function fetches the userlogins from ApproverNames datatable where the loginName parameter is manager.]]></description><return_type>10</return_type><func_type>1</func_type><function_id>958769666</function_id><date_modified>1594900182000</date_modified><guid><![CDATA[bm_lib_func_util_fetchUserloginForManager]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>958769666</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_fetchUserloginForManager_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594900182000</date_modified><guid><![CDATA[0de69963-06ca-4815-9ecd-96aee187276d]]></guid><script_size>266</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[managerList = string[];
resultSet = bmql("SELECT userLogin FROM approverNames WHERE mgrEmail = $loginName");

for rec in resultSet{
	if (get(rec,"userLogin")<>""){
		append(managerList ,get(rec,"userLogin"));
	} 
}

return managerList;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>958769669</id><bm_lib_func_id>958769667</bm_lib_func_id><param_name><![CDATA[loginName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1594900182000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_fetchUserloginForManager.bm_lib_func_param_loginName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5427829</id><name><![CDATA[Calculate Prod Based Pricing]]></name><variable_name><![CDATA[calculateProdBasedPricing]]></variable_name><description></description><return_type>15</return_type><func_type>1</func_type><function_id>5427828</function_id><date_modified>1688748145000</date_modified><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5427828</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_calculateProdBasedPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1688748145000</date_modified><guid><![CDATA[LEGACY_5427828]]></guid><script_size>5651</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
      BML Utility Library
      calculateProdBasedPricing
      ----------------------------
      Params:
            String[]Dict modelToLineDocNumsDict
            String currentDocNum
            StringDict stringsDict
            IntegerDict integersDict
            FloatDict floatsDict
            String piDelimiter
      Returns:
            StringDict result
                  productBasedDiscountUsed => true or false
                  error => error message
                  
      Description and Usage:
            This function is meant to be called once for each line item. For a
            given line item, it calculates the productBasedPrice_line.
*/
//Meta control variables
debug = false;
DEBUG_PREFIX = "> > > > ";

/* ======================================================================== */
/*                                              CONSTANTS                                                   */
/* ======================================================================== */
//Constants for piBasedProductPricingDict array indexes
COND_PI1 = 0;
COND_PI2 = 1;
DISC_PI = 2;
DISC_VAL = 3;
DISC_TYPE = 4;
LISTPRICE_PI = 5;

//Constants for qtyBasedProductPricingDict array indexes
Q_PI = 0;
Q_TRANS_BASED_PI = 1;
Q_QTY_BASED_PI = 2;
Q_LISTPRICE_PI = 3;
Q_PRICING_TYPE = 4;

//Constants for attribute names
PART_NUM = "_part_number";
PARENT_DOC_NUM = "_parent_doc_number";
TIER_PRICE = "tierPrice_line";
EXT_TIER_PRICE = "extTierPrice_line";
PRODUCT_BASED_PRICE = "productBasedPrice_line";
EXT_PRODUCT_BASED_PRICE = "extProductBasedPrice_line";
PROD_BASED_PRICE_USD = "extProductBasedPriceUSD_line";
TRANSACTIONS_LABEL = "numCommittedTransaction_line";
QTY_LABEL = "_price_quantity";
IS_GROUPED = "isPartOfPackage_line"; //This form field is checked if the user wishes to DYNAMICALLY GROUP this line item

//Constants for part custom field names
PI_ITEM_TYPE = "piItemType_line";
PO_ID = "poId";
UNIT_OR_FIXED = "unitOrFixed_line";
QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
UOM_TYPE = "uomType_line";
PRIMARY_BASE_FEE = "primaryBaseFee";
RAMP_PLAN_OVERRIDE = "overrideDefaultRampPlan_line";

//Constants for part custom field values
PRE_PRODUCTION = "Pre-Prod Fee";
BASE_FEE = "Base Fee";
UNIT = "UNIT";
FIXED = "FIXED";
UOM_QTY = "QTY";
DELIMITER = "@.@";
ACTION_DELIMITER = "*@*";
//Constants for BMQL tables
FIXED_PRICE = "FIXED_PRICE";
PRE_PROD_PERCENT = "preProdPercent";
INCREMENTAL = "INCRE_FEE";
BASE = "BASE_FEE";
//Constants
HUNDRED_PERCENT = 100.0;
MAX_ARRAY_SIZE = 1000;
MAX_ARRAY_SIZE_FLOAT = 1000.00;
TRUE_STR = "true";
FALSE_STR = "false";
RAMP_DELIMITER = "-_**_-";
IS_RAMP_SUBLINE = "false";
IS_UNITBASED = "unitBasedTransaction";
TILDE_DELIMITER = "~";
if ( find( currentDocNum, RAMP_DELIMITER ) <> -1 ){
      IS_RAMP_SUBLINE = "true";
}
NUMBER_RAMP_ENTRIES = "numRampEntries";
/* ======================================================================== */
/*                                              VARIABLES                                                   */
/* ======================================================================== */
//Result variables
result = dict("string");
error = false;
errorMsg = "";
productBasedPriceFound = false;
productBasedPrice = 0.0;

//Instance variables
isPreProductionItem = false;



/* ======================================================================== */
/*                First, get the Model associated with this line item               */
/* ======================================================================== */
parentDocNumKey = currentDocNum + piDelimiter + PARENT_DOC_NUM;
parentDocNum = "";

if (containskey(stringsDict, parentDocNumKey)) {
      parentDocNum = get(stringsDict, parentDocNumKey);
} else {
      //If no associated model is found for this line item, stop the script
      error = true;
      errorMsg = errorMsg + "calculateProductBasedPricing(1): could not find _parent_doc_number for docNum " + currentDocNum + "\n";
      put(result, "error", errorMsg);
      return result;
}


/* ======================================================================== */
/*                Second, get the PI of this line item                                          */
/* ======================================================================== */
piKey = currentDocNum + piDelimiter + PART_NUM;
pi = "";
if (containskey(stringsDict, piKey)) {
      pi = get(stringsDict, piKey);
} else {
      //If no PI is found for the current line item, stop the script
      error = true;
      errorMsg = errorMsg + "calculateProductBasedPricing(2): could not find PI (_part_num) for docNum " + currentDocNum + " with piKey " + piKey + "\n";
      put(result, "error", errorMsg);
      return result;
}


/* If this is a ramp item, find its index */
rampIndex = "";
//CSYS-86115 (KA. 10-16-2017):
regulardocNum = "";

if ( IS_RAMP_SUBLINE == "true" ){
      rampIndexArr = split( currentDocNum, RAMP_DELIMITER );
      rampIndex = rampIndexArr[1];

      //CSYS-86115 (KA. 10-16-2017):
      regularDocNum = rampIndexArr[0];
}

howManyRamps = util.getIntegerAttribute( integersDict, regularDocNum, piDelimiter, NUMBER_RAMP_ENTRIES );

/* ======================================================================== */
/*                Third, find out if it is a Pre-Production PI                            */
/* ======================================================================== */
/*piItemTypeKey = pi + piDelimiter + PI_ITEM_TYPE;
piItemType = "";
if (containskey(stringsDict, piItemTypeKey)) {
      piItemType = get(stringsDict, piItemTypeKey);
} else {
      error = true;
      errorMsg = errorMsg + "calculateProductBasedPricing(3): could not find PI Item Type (custom_field8) for docNum " + currentDocNum + "\n";
      put(result, "error", errorMsg);
      return result;
}

if (piItemType == PRE_PRODUCTION) {
      isPreProductionItem = true;
}

*/
/* ======================================================================== */
/*          Third, get dicts of:
                  - line item PIs
                  - line item Tier Prices under this Model
                  - line item quantities
                  - line item numTransactions

            If this line item is a Pre-Prod Fee, we also want to find the 
            Base Fee line item for each PO ID.
*/
/* ======================================================================== */
lineItemDocNums = string[];
if (containskey(modelToLineDocNumsDict, parentDocNum)) {
      lineItemDocNums = get(modelToLineDocNumsDict, parentDocNum);
} else {
      //If no child line item docNums are found for the current Model, stop the script
      error = true;
      errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find child docNums for parent docNum " + parentDocNum + " of docNum " + currentDocNum + "\n";
      put(result, "error", errorMsg);
      return result;
}

lineItemExtTierPriceDict = dict("float");
lineItemTransactionsDict = dict("integer");
lineItemQtyDict = dict("integer");
poIdToBaseFeeLineItemDocNumDict = dict("string");

for lineItemDocNum in lineItemDocNums {
      
      if ( find( lineItemDocNum, RAMP_DELIMITER ) <> -1 ){
            continue;
      }
      /* -------------------------------------------------------------------- */
      //Get the lineItemPi
      /* -------------------------------------------------------------------- */
      lineItemPiKey = lineItemDocNum + piDelimiter + PART_NUM;
      lineItemPi = "";
      if (containskey(stringsDict, lineItemPiKey)) {
            lineItemPi = get(stringsDict, lineItemPiKey);
      } else {
            //If no child line item PIs are found for the current Model, stop the script
            error = true;
            errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PI (_part_num) for childDocNum " + lineItemDocNum + "\n";
            put(result, "error", errorMsg);
            return result;
      }
      
      /* -------------------------------------------------------------------- */
      //Get the lineItemTierPrice
      /* -------------------------------------------------------------------- */
      lineItemExtTierPriceKey = lineItemDocNum + piDelimiter + EXT_TIER_PRICE;

      rampExtTierPriceKey = "";
      if ( rampIndex <> "" ){
            rampExtTierPriceKey = lineItemDocNum + RAMP_DELIMITER + rampIndex + piDelimiter + EXT_TIER_PRICE;
      }
      
      lineItemExtTierPrice = 0.0;
      if (containskey(floatsDict, lineItemExtTierPriceKey)) {
            lineItemExtTierPrice = get(floatsDict, lineItemExtTierPriceKey);
      } else {
            //If no child line item PI tier prices are found for the current Model, stop the script
            error = true;
            errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find tierPrice_line for childDocNum " + lineItemDocNum + "\n";
            put(result, "error", errorMsg);
            return result;
      }
      if ( containskey(floatsDict, rampExtTierPriceKey) ){
            lineItemExtTierPrice = get(floatsDict, rampExtTierPriceKey );
      }
      put(lineItemExtTierPriceDict, lineItemPi, lineItemExtTierPrice);
      
      /* -------------------------------------------------------------------- */
      //Get lineItemTransactions
      /* -------------------------------------------------------------------- */
      lineItemTransactionsKey = lineItemDocNum + piDelimiter + TRANSACTIONS_LABEL;
      rampItemTransactionsKey = "";
      if ( rampIndex <> "" ){
            rampItemTransactionsKey = lineItemDocNum + RAMP_DELIMITER + rampIndex + piDelimiter + TRANSACTIONS_LABEL;
      }
      lineItemTransactions = 0;
      if (containskey(integersDict, lineItemTransactionsKey)) {
            lineItemTransactions = get(integersDict, lineItemTransactionsKey);
      } else {
            error = true;
            errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find numCommittedTransactions_line for childDocNum " + lineItemDocNum + "\n";
            put(result, "error", errorMsg);
            return result;
      }
      if ( containskey(integersDict, rampItemTransactionsKey )){
            lineItemTransactions = get(integersDict, rampItemTransactionsKey);
      }
      put(lineItemTransactionsDict, lineItemPi, lineItemTransactions);
      
      /* -------------------------------------------------------------------- */
      //Get the lineItemQty
      /* -------------------------------------------------------------------- */
      /*lineItemQtyKey = lineItemDocNum + piDelimiter + QTY_LABEL;
      lineItemQty = 0;
      if (containskey(integersDict, lineItemQtyKey)) {
            lineItemQty = get(integersDict, lineItemQtyKey);
      } else {
            error = true;
            errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find _price_quantity for childDocNum " + lineItemDocNum + "\n";
            put(result, "error", errorMsg);
            return result;
      }
      put(lineItemQtyDict, lineItemPi, lineItemQty);*/
      
      /* -------------------------------------------------------------------- */
      //Get the Base Fee docNum associated with this PO ID
      /* -------------------------------------------------------------------- */
      /*if (isPreProductionItem) {
            //Get the PI Item Type of this line item 
            piItemTypeKey = lineItemPi + piDelimiter + PI_ITEM_TYPE;
            piItemType = "";
            if (containskey(stringsDict, piItemTypeKey)) {
                  piItemType = get(stringsDict, piItemTypeKey);
                  
                  if (piItemType == BASE_FEE) {
                        //Get the PO ID associated with this line item
                        poIdKey = lineItemPi + piDelimiter + PO_ID;
                        poId = "";
                        if (containskey(stringsDict, poIdKey)) {
                              poId = get(stringsDict, poIdKey);
                              if (containskey(poIdToBaseFeeLineItemDocNumDict, poId)) {
                                    error = true;
                                    errorMsg = errorMsg + "calculateProductBasedPricing(4): duplicate PO ID detected for multiple Base Fee items! childDocNum " + lineItemDocNum + "\n";
                                    put(result, "error", errorMsg);
                                    return result;
                              }
                              put(poIdToBaseFeeLineItemDocNumDict, poId, lineItemDocNum);
                        } else {
                              error = true;
                              errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PO ID for childDocNum " + lineItemDocNum + "\n";
                              put(result, "error", errorMsg);
                              return result;
                        }
                  }
            } else {
                  error = true;
                  errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PI Item Type for childDocNum " + lineItemDocNum + "\n";
                  put(result, "error", errorMsg);
                  return result;
            }
      }*/
}
/* -------------------------------------------------------------------- */
//           Find if the line item is dynamically grouped
/* -------------------------------------------------------------------- */
isGroupedKey = currentDocNum + piDelimiter + IS_GROUPED;
isGrouped = "";
if (containskey(stringsDict, isGroupedKey)) {
      isGrouped = get(stringsDict, isGroupedKey);
}

dependentPIResSet = bmql("SELECT transactionBasedPI, listPricePI, pricingType, requiredGroup, businessUnit, upliftPercent FROM productDependentPIs WHERE pi=$pi");
businessUnit = "";
if ( containskey( stringsDict, "1" + DELIMITER + "ownerBU_quote" ) ){
      businessUnit = get( stringsDict, "1" + DELIMITER + "ownerBU_quote" );
}
businessUnitFound = false;

//CSYS-87125:
stateAndLocalPackageId = "26";
itemType = "";
if(containsKey(stringsDict, pi + piDelimiter + PI_ITEM_TYPE)){
      itemType = get(stringsDict, pi + piDelimiter + PI_ITEM_TYPE);
}
PACKAGE_ID = "package_line";
packageId = "";
if(containsKey(stringsDict, TILDE_DELIMITER + pi + TILDE_DELIMITER + piDelimiter + PACKAGE_ID)){
      packageId = get(stringsDict, TILDE_DELIMITER + pi + TILDE_DELIMITER + piDelimiter + PACKAGE_ID);
}

piKey = currentDocNum + piDelimiter + PART_NUM;
for dependentPIRes in dependentPIResSet {
      listPrice = 0.0;
      trxn = 0;
      tmp = 0;
      
      //Bundle Incremental fix part 2 for CSYS-39318
      trxnPI = "";
      if (get(stringsDict, get(dependentPIRes, "transactionBasedPI") + ACTION_DELIMITER) <> "TERMINATE"){
            trxnPI = get(dependentPIRes, "transactionBasedPI");
      }
      //End Bundle Incremental fix part 2
      listPricePI = get(dependentPIRes, "listPricePI");
      pricingType = get(dependentPIRes, "pricingType");
      requiredGroup = get(dependentPIRes, "requiredGroup");
      
      /* SMB Uplift Variables */
      tableBusinessUnit = get(dependentPIRes, "businessUnit" );
      upliftPercent = get(dependentPIRes, "upliftPercent" );
      upliftValue = 0.0;
      if ( isnumber( upliftPercent ) ){
            upliftValue = atof( upliftPercent );
      }
      upliftMultiplier = 1.0 + upliftValue/HUNDRED_PERCENT;
      
      if(((requiredGroup == "TRUE" AND isGrouped == TRUE_STR) OR requiredGroup == "FALSE") AND (businessUnit == tableBusinessUnit OR ( tableBusinessUnit == "" AND businessUnitFound == false))) {

            if(containskey(lineItemExtTierPriceDict, listPricePI)) {
                  listPrice = get(lineItemExtTierPriceDict, listPricePI);

                  //CSYS-87125 (KA. 11-29-2017): Ensure Incremental list prices are zero for the State and Local Government package.
                  /*
                        Notes: conditionally zeroing out the list price in getStandardTierPricing is not enough for incrementals.
                        We need to conditionally zero the price out here as well, or else it will take the Base list price 
                        multiplied by the upliftMultiplier.
                  */
                  if(itemType == "Incremental" AND packageId == stateAndLocalPackageId){
                        listPrice = 0.0;
                  }

            }
            else{
                  continue;
            }
            if(containskey(lineItemTransactionsDict, trxnPI)) {
                  trxn = get(lineItemTransactionsDict, trxnPI);
            }
            else{
                  continue;
            }
            if(pricingType == "BASE_FEE") {
                  productBasedPrice = listPrice * trxn * upliftMultiplier;
      
            } else {
                  if(trxn > 0) {
						//IESCNQRCPQ-864(OK. 7/7/2023) Commented out below line and added round() to avoid the price difference for Incremental list price
                        //productBasedPrice = (listPrice / trxn) * upliftMultiplier;
						productBasedPrice = round(((listPrice / trxn) * upliftMultiplier), 2);
                  
                  }
            }
      //    if(containskey(lineItemExtTierPriceDict, listPricePI) AND containskey(lineItemTransactionsDict, trxnPI)) {
                  productBasedPriceFound = true;
                  if ( businessUnit == tableBusinessUnit ){
                        businessUnitFound = true;
                  }
            //}
      }
}

/* ======================================================================== */
/*  Calculate Product Based Price   */
/* ======================================================================== */

/* ======================================================================== */
/*    Populate a default value for the productBasedPrice, if none was found   */
/* ======================================================================== */

productBasedPriceKey = currentDocNum + piDelimiter + PRODUCT_BASED_PRICE;

extProductBasedPriceKey = currentDocNum + piDelimiter + EXT_PRODUCT_BASED_PRICE;
extProductBasedPriceUSDKey = currentDocNum + piDelimiter + PROD_BASED_PRICE_USD;
userExtProductBasedPriceKey = currentDocNum + piDelimiter + "userExtProductBasedPrice";
userExtProductBasedPriceUSDKey = currentDocNum + piDelimiter + "userExtProductBasedPriceUSD";

//CSYS-86115 (KA. 10-16-2017):
userEnteredBaseFeeKey = currentDocNum + piDelimiter + "userBaseFeeNet";
userEnteredIncFeeKey = currentDocNum + piDelimiter + "userIncFeeNet";
userIncFeeNetKey = currentDocNum + piDelimiter + "incrementalFeeNet";
userIncFeeNetUSDKey = currentDocNum + piDelimiter + "incrementalFeeNetUSD";

if (productBasedPriceFound == false) {
      standardTierPriceKey = currentDocNum + piDelimiter + TIER_PRICE;
     
      tierPrice = 0.0;
      if (containskey(floatsDict, standardTierPriceKey)) {
            tierPrice = get(floatsDict, standardTierPriceKey);
      } else {
            error = true;
            errorMsg = errorMsg + "calculateProductBasedPricing(6): default productBasedPrice calculation - could not find tierPrice for docNum " + currentDocNum + "\n";
            put(result, "error", errorMsg);
            return result;
      }
      //If no productBasedPrice was found for this line item, give it the same value as the tierPrice
      productBasedPrice = tierPrice;
      
}





// Calculate Extended Product Based Prices
/* ======================================================================== */
/*                Find out if it is a Unit/Fixed PI                                 */
/* ======================================================================== */
unitOrFixedKey = pi + piDelimiter + UNIT_OR_FIXED;
unitOrFixed = "";
if (containskey(stringsDict, unitOrFixedKey)) {
      unitOrFixed = get(stringsDict, unitOrFixedKey);
}
/* ------------------------------------------------------------------------ */
/*          Obtain the UOM type of the current part                                 */
/* ------------------------------------------------------------------------ */
uomTypeKey = pi + piDelimiter + UOM_TYPE;
uomType = "";

if (containskey(stringsDict, uomTypeKey)) {
      uomType = get(stringsDict, uomTypeKey);
} 
/* ------------------------------------------------------------------------ */
/*          Obtain the correct multiplier (either Qty or Transactions) 
            depending on the UOM type                                                                 */
/* ------------------------------------------------------------------------ */
multiplier = 0;
key = currentDocNum + piDelimiter + TRANSACTIONS;
if (uomType == UOM_QTY) {
      key = currentDocNum + piDelimiter + QTY;
}
if (containskey(integersDict, key)) {
      multiplier = get(integersDict, key);
}
if(unitOrFixed == FIXED) {
      multiplier = 1;
}
/* ======================================================================== */
/*                                              Return variables                                      */
/* ======================================================================== */

put(floatsDict, productBasedPriceKey, productBasedPrice);
put(floatsDict, extProductBasedPriceKey, productBasedPrice * multiplier);
put(floatsDict, extProductBasedPriceUSDKey, productBasedPrice * multiplier);

//CSYS-86115 (ensure user entered Base Fee Net/Inc Fee Net values can be committed by the GetRampXMLStringArrayDict util. KA. 10-16-2017):
overrideRampPrice = "";
primaryBaseDocNum = "";
coreRampOverride = "";
regularRampOverride = "";
isUnitBased = util.getStringAttribute(stringsDict, regularDocNum, DELIMITER, IS_UNITBASED);
if(containskey( stringsDict, parentdocNum+DELIMITER+ PRIMARY_BASE_FEE )){
      primaryBaseDocNum = get( stringsDict, parentdocNum+DELIMITER+ PRIMARY_BASE_FEE );
}
if(containskey(stringsDict, primaryBaseDocNum+DELIMITER+ RAMP_PLAN_OVERRIDE)) {
      coreRampOverride = get(stringsDict, primaryBaseDocNum+DELIMITER+ RAMP_PLAN_OVERRIDE);
}
if(containskey(stringsDict, regularDocNum+DELIMITER+ RAMP_PLAN_OVERRIDE)) {
      regularRampOverride = get(stringsDict, regularDocNum+DELIMITER+ RAMP_PLAN_OVERRIDE);
}
if(containskey(stringsDict, regularDocNum + DELIMITER + "overrideRampPrice")){
      overrideRampPrice = get(stringsDict, regularDocNum + DELIMITER + "overrideRampPrice");
}

//CSYS-95500 (LN. 4-24-2019) Commenting out the 'isUnitBased' check here - we are now allowing Unit Based Products to undergo the Override Price functionality
if(overrideRampPrice == TRUE_STR AND 
(coreRampOverride == TRUE_STR OR (regularRampOverride == TRUE_STR /*AND isUnitBased <> TRUE_STR*/ AND isGrouped <> TRUE_STR)) AND 
howManyRamps <> 0 AND rampIndex <> ""){
    //make sure we're not dealing with the last ramp:
    if(isnumber(rampIndex) AND atoi(rampIndex) < howManyRamps - 1){
          if(containskey(floatsDict, userEnteredBaseFeeKey)){
                userExtProductBasedPrice = get(floatsDict, userEnteredBaseFeeKey);
          
                //if user elected to overwrite the baseFeeNet, populate the dict key for getRampXMLStringArrayDict::
                //put(floatsDict, extProductBasedPriceKey, userExtProductBasedPrice);
                //put(floatsDict, extProductBasedPriceUSDKey, userExtProductBasedPrice);
                put(floatsDict, userExtProductBasedPriceKey, userExtProductBasedPrice);
                put(floatsDict, userExtProductBasedPriceUSDKey, userExtProductBasedPrice);    

                if(find(currentDocNum, RAMP_DELIMITER) <> -1){
                      put(stringsDict, currentDocNum + DELIMITER + "userEnteredRampPricing", TRUE_STR);
                }
    
          }
    
          if(containskey(floatsDict, userEnteredIncFeeKey)){
                userIncFeeNet = get(floatsDict, userEnteredIncFeeKey);
    
                //if user elected to overwrite the increFeeNet, populate the dict key for getRampXMLStringArrayDict:
                put(floatsDict, userIncFeeNetKey, userIncFeeNet);
                put(floatsDict, userIncFeeNetUSDKey, userIncFeeNet);
                if(find(currentDocNum, RAMP_DELIMITER) <> -1){
                     put(stringsDict, currentDocNum + DELIMITER + "userEnteredRampPricing", TRUE_STR);
                }
          }
    }
}

put(result, "productBasedPricingUsed", string(productBasedPriceFound));
if (error) {
      put(result, "error", errorMsg);
}



return result;]]></script_text><_children><bm_lib_func_assoc><id>446104753</id><caller_func_id>5427828</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[Calculate Prod Based Pricing]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1688748145000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[b17e5a65-2dbb-4871-9e93-cbd6d99ada87]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>446104754</id><caller_func_id>5427828</caller_func_id><called_lib_func_id>4906069</called_lib_func_id><rule_area><![CDATA[Calculate Prod Based Pricing]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1688748145000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[b29b02c2-72e2-4c45-8206-b83410c242cb]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>5427831</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[modelToLineDocNumsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1688748145000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_modelToLineDocNumsDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5427832</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[currentDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1688748145000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_currentDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5427833</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1688748145000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5427834</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1688748145000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5427835</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1688748145000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5427836</id><bm_lib_func_id>5427829</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1688748145000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_calculateProdBasedPricing.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814702</id><name><![CDATA[formatDate]]></name><variable_name><![CDATA[formatDate]]></variable_name><description><![CDATA[Format Date in short, long or default format]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4814701</function_id><date_modified>1677737535000</date_modified><guid><![CDATA[bm_lib_func_util_formatDate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814701</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_formatDate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1677737535000</date_modified><guid><![CDATA[LEGACY_4814701]]></guid><script_size>2039</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  formatDate
  param:
    inputDate   - String 
    type        - String:   short / long 
  return  
    String 
*/

result = inputDate;

monthSpanishLongName = String[] {"enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"};//CSYS-92933 (LN. 10-16-2018) New long month format for the Spanish Order Form
monthFrenchLongName = String[] { "janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre" };//CSYS-91980 (LN. 7-24-2018) New long month format for the French Order Form
monthGermanLongName = String[] { "Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember" };//CSYS-95993 (LN. 8-16-2019) New long month format for the German Order Form
monthLongName = String[] { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
monthShortName = String[] { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};
monthNum = String[] {"01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"};
monthJapaneseLongName = String[] {"01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"}; //CSYS-107251 (PG 11/14/2022)

monthSpanishLongNameDict = dict("string");//CSYS-92933
monthFrenchLongNameDict = dict("string");//CSYS-91980
monthGermanLongNameDict = dict("string");//CSYS-95993
monthJapaneseLongNameDict = dict("string");//CSYS-107251 (PG 11/14/2022)
monthLongNameDict = dict("string");
monthShortNameDict = dict("string");

index = 0;

for item in monthNum {
  put( monthSpanishLongNameDict, monthNum[index], monthSpanishLongName[index]);//CSYS-92933
  put( monthFrenchLongNameDict, monthNum[index], monthFrenchLongName[index]);//CSYS-91980
  put( monthGermanLongNameDict, monthNum[index], monthGermanLongName[index]);//CSYS-95993
  put( monthJapaneseLongNameDict, monthNum[index], monthJapaneseLongName[index]); //CSYS-107251 (PG 11/14/2022)
  put( monthLongNameDict, monthNum[index], monthLongName[index]);
  put( monthShortNameDict, monthNum[index], monthShortName[index]);
  
  index = index + 1;
} 

year = substring(inputDate, 0, 4);
month = substring(inputDate, 5, 7);
day = substring(inputDate, 8, 10);

if ( type == "short" ) {
  monthName = "";
  if ( containskey(monthShortNameDict, month) ) {
    monthName = get(monthShortNameDict, month);
  }   
  
  result = day + "-" + monthName + "-" + year;
} 
elif ( type == "long" ) {
  monthName = "";
  if ( containskey(monthLongNameDict, month) ) {
    monthName = get(monthLongNameDict, month);
  }

  result = monthName + " " + day + ", " + year;
}
elif ( type == "frenchLong") {//CSYS-91980
  monthName = "";
  if( containskey(monthFrenchLongNameDict, month) ){
    monthName = get(monthFrenchLongNameDict, month);
  }

  result = day + " " + monthName + " " + year;
}
elif ( type == "spanishLong") {//CSYS-92933
  monthName = "";
  if( containskey(monthSpanishLongNameDict, month) ){
    monthName = get(monthSpanishLongNameDict, month);
  }

  result = day + " " + monthName + " " + year;
}
elif ( type == "germanLong") {//CSYS-95993
  monthName = "";
  if( containskey(monthGermanLongNameDict, month) ){
    monthName = get(monthGermanLongNameDict, month);
  }

  //CSYS-97803, PhilS, 12/26/2019
  //result = day + " " + monthName + " " + year;
  //result = day + ". " + monthName + ", " + year;
  result = day + ". " + monthName + " " + year;  //CSYS-98306, PhilS, 01/24/2020

}

//CSYS-107251 (PG 11/14/2022)
elif ( type == "japaneseLong") {
  monthName = "";
  if( containskey(monthJapaneseLongNameDict, month) ){
    monthName = get(monthJapaneseLongNameDict, month);
  }
  
    result = year + "/ " + monthName + "/ " + day;
	
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814703</id><bm_lib_func_id>4814702</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1677737536000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_formatDate.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814704</id><bm_lib_func_id>4814702</bm_lib_func_id><param_name><![CDATA[type]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1677737536000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_formatDate.bm_lib_func_param_type_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839320</id><name><![CDATA[getTravelAndExpensePIs]]></name><variable_name><![CDATA[getTravelAndExpensePIs]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>989839319</function_id><date_modified>1599705699000</date_modified><guid><![CDATA[bm_lib_func_util_getTravelAndExpensePIs]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839319</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getTravelAndExpensePIs_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705699000</date_modified><guid><![CDATA[1789f74f-2faa-4788-9b4a-d9325764b302]]></guid><script_size>211</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getTravelAndExpensePIs
*/
travelAndExpenseWithTriplinkProductArr = String[];
travelAndExpenseWithTriplinkRes = BMQL("SELECT pi FROM tAndEWithTriplink");

for entry in travelAndExpenseWithTriplinkRes {
    pi = get(entry, "pi");
    append(travelAndExpenseWithTriplinkProductArr, pi);
}
return travelAndExpenseWithTriplinkProductArr;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>4814688</id><name><![CDATA[convert2DListToDict]]></name><variable_name><![CDATA[convert2DListToDict]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4814687</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_convert2DListToDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814687</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convert2DListToDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435910000</date_modified><guid><![CDATA[LEGACY_4814687]]></guid><script_size>243</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  convert2DListToDict
  param:
    input2DList     - string[][];
    returnDict      - String dictionary
    returnDictKey   - String[]
  return 
    string
*/

result = "";

for row in input2DList {
  put( returnDict, row[0], row[1]);
  append(returnDictKey, row[0]);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814689</id><bm_lib_func_id>4814688</bm_lib_func_id><param_name><![CDATA[input2DList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>10</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_convert2DListToDict.bm_lib_func_param_input2DList_10]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814690</id><bm_lib_func_id>4814688</bm_lib_func_id><param_name><![CDATA[returnDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_convert2DListToDict.bm_lib_func_param_returnDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814691</id><bm_lib_func_id>4814688</bm_lib_func_id><param_name><![CDATA[returnDictKey]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_convert2DListToDict.bm_lib_func_param_returnDictKey_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>303109688</id><name><![CDATA[Set Date to First Day of Month]]></name><variable_name><![CDATA[setDateToFirstDayOfMonth]]></variable_name><description><![CDATA[Set the string date passed in, to the first day of the month. Used for CSYS-74106. KA. 12-14-2016.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>303109687</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_setDateToFirstDayOfMonth]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>303109687</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setDateToFirstDayOfMonth_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435939000</date_modified><guid><![CDATA[7b15a416-f7da-4d4b-82f0-74dee698f447]]></guid><script_size>344</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//Logic to set date strings to first day of the month
//applies to date strings in yyyy-MM-dd format

newDate = "";
yearVal = "";
monthVal = "";
dayVal = "";
splitNewDate = string[];

if( find(inputDate,"-") <> -1 ){
	splitNewDate = split(inputDate, "-");
	yearVal = splitNewDate[0];
	monthVal = splitNewDate[1];
	dayVal = splitNewDate[2];
}

if (sizeofarray(splitNewDate) > 0 AND isnumber(dayVal) AND isnumber(monthVal) AND isnumber(yearVal)){
	firstDayOfMonth = "01";
	newDate = yearVal + "-" + monthVal + "-" + firstDayOfMonth;
}

return newDate;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>303109689</id><bm_lib_func_id>303109688</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setDateToFirstDayOfMonth.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4906081</id><name><![CDATA[putStringAttribute]]></name><variable_name><![CDATA[putStringAttribute]]></variable_name><description><![CDATA[Puts the value of a string attribute into the stringsDict.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>4906080</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_putStringAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906080</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_putStringAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435920000</date_modified><guid><![CDATA[LEGACY_4906080]]></guid><script_size>131</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[key = docNum + delimiter + commerceField;
put(stringsDict, key, value);

return true;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4906082</id><bm_lib_func_id>4906081</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_putStringAttribute.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906083</id><bm_lib_func_id>4906081</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_putStringAttribute.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906084</id><bm_lib_func_id>4906081</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_putStringAttribute.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906085</id><bm_lib_func_id>4906081</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_putStringAttribute.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906086</id><bm_lib_func_id>4906081</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_putStringAttribute.bm_lib_func_param_value_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4959847</id><name><![CDATA[getQtyBasedProductPricingConditions]]></name><variable_name><![CDATA[getQtyBasedProductPricingConditions]]></variable_name><description></description><return_type>15</return_type><func_type>1</func_type><function_id>4959846</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getQtyBasedProductPricingConditions]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4959846</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getQtyBasedProductPricingConditions_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435922000</date_modified><guid><![CDATA[LEGACY_4959846]]></guid><script_size>646</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	getQtyBasedProductPricingConditions
	-----------------------------------
	Params:
		String[] piList
		String[]Dict qtyBasedProductPricingDict
	Returns:
		StringDict result
			rowCount => number of records returned
	
	Description:
		For a given list of Part Numbers, return all Product Dependent
		conditions within the list of Part Numbers. 
*/
result = dict("string");

qtyBasedProductPricingConditions = bmql("select pi, transactionBasedPI, qtyBasedPI, listPricePI, pricingType from productDependentPIs where pi in $piList and listPricePI in $piList and (transactionBasedPI in $piList or qtyBasedPI in $piList)");

index = 0;
for record in qtyBasedProductPricingConditions {
	
	row = string[];
	
	append(row, get(record, "pi"));
	append(row, get(record, "transactionBasedPI"));
	append(row, get(record, "qtyBasedPI"));
	append(row, get(record, "listPricePI"));
	append( row, get( record, "pricingType" ) );
	
	put(qtyBasedProductPricingDict, index, row);
	
	index = index + 1;
}

put(result, "rowCount", string(index));

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4959849</id><bm_lib_func_id>4959847</bm_lib_func_id><param_name><![CDATA[piList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getQtyBasedProductPricingConditions.bm_lib_func_param_piList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4959850</id><bm_lib_func_id>4959847</bm_lib_func_id><param_name><![CDATA[qtyBasedProductPricingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getQtyBasedProductPricingConditions.bm_lib_func_param_qtyBasedProductPricingDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>170675968</id><name><![CDATA[Get User Time Zone]]></name><variable_name><![CDATA[getUserTimeZone]]></variable_name><description><![CDATA[Retrieves the time zone of the user. 
Ex: GMT-7]]></description><return_type>1</return_type><func_type>1</func_type><function_id>170675967</function_id><date_modified>1626948725000</date_modified><guid><![CDATA[bm_lib_func_util_getUserTimeZone]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>170675967</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getUserTimeZone_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948725000</date_modified><guid><![CDATA[25164262-5f58-4d63-acc4-58f12b5259d8]]></guid><script_size>179</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[timezone = "";
userTimezone = _user_timezone;

rez = bmql("SELECT TimezoneValue FROM timezoneTable WHERE SystemUserTimezone = $userTimezone");
for entry in rez{
	
	timezone = get(entry, "TimezoneValue");
}

return timezone;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>170675969</id><bm_lib_func_id>170675968</bm_lib_func_id><param_name><![CDATA[_user_timezone]]></param_name><ref_id>42</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948725000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getUserTimeZone.bm_lib_func_param__user_timezone_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839315</id><name><![CDATA[getProfOnlyPOsForUniversal]]></name><variable_name><![CDATA[getProfOnlyPOsForUniversal]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>989839314</function_id><date_modified>1599705698000</date_modified><guid><![CDATA[bm_lib_func_util_getProfOnlyPOsForUniversal]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839314</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getProfOnlyPOsForUniversal_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705699000</date_modified><guid><![CDATA[b47ee15c-b9a0-4450-9b2b-9614a33c3a89]]></guid><script_size>332</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getProfOnlyPOsForUniversal
implementationMethods - String
*/
PROFESSIONAL_EDITION = "Professional"; //(CSYS-99801 NP. 07/21/2020)
usOfferProfessionalOnlyArr = String[];

if(find(implementationMethods, "Universal") <> -1){
    //When Edition is Universal: Query the 'USOfferSimp' table and gather the poIDs for those Professional ONLY products
    //CSYS-98751, Phil S, 03/26/2020
    //universalPORes = BMQL("SELECT pONumber, edition FROM USOfferSimp");
    //(CSYS-99801, NP. 07/21/2020)
    universalPORes = BMQL("SELECT pONumber, edition FROM UniversalOfferSimp WHERE edition = $PROFESSIONAL_EDITION");

    for entry in universalPORes {
        edition = get(entry, "edition");
        poIDArr = split(get(entry, "pONumber"), "~");

      //  if(edition == "Professional"){ (CSYS-99801 NP. 07/21/2020)
            for eachPO in poIDArr {
                //append the POs to the 'usOfferProfessionalOnlyArr', to be used later in the script
                append(usOfferProfessionalOnlyArr, eachPO);
            }
       // }
    }
}
return usOfferProfessionalOnlyArr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839316</id><bm_lib_func_id>989839315</bm_lib_func_id><param_name><![CDATA[implementationMethods]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1599705698000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getProfOnlyPOsForUniversal.bm_lib_func_param_implementationMethods_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814694</id><name><![CDATA[customAtoi]]></name><variable_name><![CDATA[customAtoi]]></variable_name><description></description><return_type>3</return_type><func_type>1</func_type><function_id>4814693</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_customAtoi]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814693</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_customAtoi_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435911000</date_modified><guid><![CDATA[LEGACY_4814693]]></guid><script_size>123</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  BML util (customAtoi)
   - To convert the string into integer.
   - if the input is not a valid number, the application will take the default value input and return back as a result.
   
  param:
    inputValue - String
    defaultValue   - integer
  result:
    Integer

*/

result = defaultValue;

if (  isnumber(inputValue) ) {
	result = integer(atof(inputValue));
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814695</id><bm_lib_func_id>4814694</bm_lib_func_id><param_name><![CDATA[inputValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_customAtoi.bm_lib_func_param_inputValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814696</id><bm_lib_func_id>4814694</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_customAtoi.bm_lib_func_param_defaultValue_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814713</id><name><![CDATA[initStrList]]></name><variable_name><![CDATA[initStrList]]></variable_name><description><![CDATA[NOT USED.]]></description><return_type>10</return_type><func_type>1</func_type><function_id>4814712</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_initStrList]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814712</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_initStrList_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435912000</date_modified><guid><![CDATA[LEGACY_4814712]]></guid><script_size>182</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  initStrList 
  param:
    numElement      - integer
    defaultValue    - string
  return 
    integer[];
*/
result = String[];

list = range(numElement);

for element in list {
  result[element] = defaultValue;
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814715</id><bm_lib_func_id>4814713</bm_lib_func_id><param_name><![CDATA[numElement]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_initStrList.bm_lib_func_param_numElement_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814714</id><bm_lib_func_id>4814713</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_initStrList.bm_lib_func_param_defaultValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839309</id><name><![CDATA[getTransactionMatchPOs]]></name><variable_name><![CDATA[getTransactionMatchPOs]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>989839308</function_id><date_modified>1599705698000</date_modified><guid><![CDATA[bm_lib_func_util_getTransactionMatchPOs]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839308</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getTransactionMatchPOs_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705698000</date_modified><guid><![CDATA[8efd4db8-8fdc-4d10-a80a-7b90e768443b]]></guid><script_size>302</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getTransactionMatchPOs
stringsDict - dict("string")
*/
DELIMITER = "@.@";
TRUE_STR = "true";
TRANS_VALIDATION_APPLIES = "transValidationApplies";

//make list of PIs that qualify for num of trans constraint
rez = BMQL("SELECT PO FROM trnsValidation WHERE PO in $poArray");
listOfNumOfTransPOs = string[];
for entry in rez{
    poID = get(entry,"PO");
    append(listOfNumOfTransPOs,poID);
    put(stringsDict, poID + DELIMITER + TRANS_VALIDATION_APPLIES, TRUE_STR); //CSYS-70683
}
return listOfNumOfTransPOs;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839310</id><bm_lib_func_id>989839309</bm_lib_func_id><param_name><![CDATA[poArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1599705698000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getTransactionMatchPOs.bm_lib_func_param_poArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>989839311</id><bm_lib_func_id>989839309</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1599705698000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getTransactionMatchPOs.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814717</id><name><![CDATA[initFloatList]]></name><variable_name><![CDATA[initFloatList]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>9</return_type><func_type>1</func_type><function_id>4814716</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_initFloatList]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814716</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_initFloatList_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435913000</date_modified><guid><![CDATA[LEGACY_4814716]]></guid><script_size>186</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  initFloatList 
  param:
    numElement      - integer
    defaultValue    - float
  return 
    integer[];
*/
result = float[];

list = range(numElement);

for element in list {
  result[element] = defaultValue;
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814718</id><bm_lib_func_id>4814717</bm_lib_func_id><param_name><![CDATA[numElement]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_initFloatList.bm_lib_func_param_numElement_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814719</id><bm_lib_func_id>4814717</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_initFloatList.bm_lib_func_param_defaultValue_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5371496</id><name><![CDATA[Get Select Access Level Fee]]></name><variable_name><![CDATA[getSelectAccessLevelFee]]></variable_name><description></description><return_type>2</return_type><func_type>1</func_type><function_id>5371495</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getSelectAccessLevelFee]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5371495</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getSelectAccessLevelFee_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435929000</date_modified><guid><![CDATA[LEGACY_5371495]]></guid><script_size>683</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> Get Select Access Level Fee 

floatsDict - Float Dictionary, key = docNum + DELIMITER + variable name
DELIMITER - Delimiter to use for the floats dict.

*/
selectAccessLevel1 = "Select Access Level 1";
selectAccessLevel2 = "Select Access Level 2";
selectAccessLevel3 = "Select Access Level 3";
selectAccessLevel4 = "Select Access Level 4";

LEVEL1FEE = "selectAccessLevel1FeesPerTransaction_quote";
LEVEL2FEE = "selectAccessLevel2FeesPerTransaction_quote";
LEVEL3FEE = "selectAccessLevel3FeesPerTransaction_quote";
LEVEL4FEE = "selectAccessLevel4FeesPerTransaction_quote";


result = 0.0;
miscDataValue = "";
miscDataKey = "";
accessFeeResSet = bmql("SELECT miscDataVal, miscDataKey FROM miscCommerceData WHERE miscDataKey = $selectAccessLevel1 OR miscDataKey = $selectAccessLevel2 OR miscDataKey = $selectAccessLevel3 OR miscDataKey = $selectAccessLevel4");
for accessFee in accessFeeResSet {
	accessLevelKey = "";
	miscDataValue = get(accessFee, "miscDataVal");
	miscDataKey = get(accessFee, "miscDataKey");
	
	if(miscDataValue <> "" AND miscDataKey == "Select Access Level 1"){
		accessLevelKey = "1" + DELIMITER + LEVEL1FEE;
		put(floatsDict, accessLevelKey, atof(miscDataValue));
	}
	if(miscDataValue <> "" AND miscDataKey == "Select Access Level 2"){
		accessLevelKey = "1" + DELIMITER + LEVEL2FEE;
		put(floatsDict, accessLevelKey, atof(miscDataValue));
	}
	if(miscDataValue <> "" AND miscDataKey == "Select Access Level 3"){
		accessLevelKey = "1" + DELIMITER + LEVEL3FEE;
		put(floatsDict, accessLevelKey, atof(miscDataValue));
	}
	if(miscDataValue <> "" AND miscDataKey == "Select Access Level 4"){
		accessLevelKey = "1" + DELIMITER + LEVEL4FEE;
		put(floatsDict, accessLevelKey, atof(miscDataValue));
	}
}


return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5371500</id><bm_lib_func_id>5371496</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getSelectAccessLevelFee.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5371986</id><bm_lib_func_id>5371496</bm_lib_func_id><param_name><![CDATA[DELIMITER]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getSelectAccessLevelFee.bm_lib_func_param_DELIMITER_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>49924544</id><name><![CDATA[getStandardTierPricing]]></name><variable_name><![CDATA[getStandTierPricing]]></variable_name><description><![CDATA[Populates the piQtyToPriceDict with the correct Standard Tier Price for a given list of PIs and Qtys ( or Transactions).]]></description><return_type>15</return_type><func_type>1</func_type><function_id>49924543</function_id><date_modified>1678338291000</date_modified><guid><![CDATA[bm_lib_func_util_getStandTierPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>49924543</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getStandTierPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1678338291000</date_modified><guid><![CDATA[23e5598d-65ec-4059-a895-04d58c866b3f]]></guid><script_size>7406</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	getStandTierPricing
	-------------------
	Description:
		For a given list of PIs, imported into this function as piQtyList,
		populates the piQtyAndImplementationMethodToPriceDict dictionary with the corresponding
		tier price of the PI, based on its quantity or no. of transactions.
	
	Params:
		String priceList
		String currencyCode
		FloatDict piQtyAndImplementationMethodToPriceDict
		String[] piQtyAndImplementationMethodList
		String piDelimiter
		String quoteTheater
		String quoteMarket
		String[] coreService
		String quoteType
	Returns:
		StringDict resultDict
	
	piQtyAndImplementationMethodToPriceDict:
		This is the dictionary that will be populated with values queried.
		Key: <pi_number><piDelimiter><qty_or_num_transactions>
		Value: standard tier price
		
	piQtyAndImplementationMethodList:
		Elements: <pi_number><piDelimiter><qty_or_num_transactions><piDelimiter><implementationMethod>
*/

resultDict = dict("string");
pricingDict = dict("float");
tierPricingConditionsMatrix = string[][];
piQtyDict = dict("integer"); //Maps a PI to a Quantity/NumTransactions
TILDA = "~";
PI_ITEM_TYPE = "piItemType_line";
//PACKAGE_ID = "package_line";
//stateAndLocalPackageId = "26";

//From our list of PIs (with Qty/Trxns and Implementation Method), extract the list of PIs only (for the BMQL query)
index = 0;
rowImp = 0;

piDict = dict("string");
billingCounter = "";//CSYS-106564
strPrice = "";//CSYS-106564
lineBillingCounter = "";//CSYS-106564

for piQty in piQtyAndImplementationMethodList {
	pricingKeys = split(piQty, piDelimiter);
	pi = pricingKeys[0];
	qty = pricingKeys[1];
	implementationMethod = pricingKeys[2];
	core = pricingKeys[3];
	billingCounter = pricingKeys[4];//CSYS-106564

	put(piDict, pi + TILDA + "piCore" + TILDA + core, core); //modified the dictionary key for CSYS-83581 (KA. 7-18-2017)

	if (pi <> "" and isnumber(qty) and implementationMethod <> "" and core <> "") {
		tierPricingConditionsMatrix[index][0] = pi;
		tierPricingConditionsMatrix[index][1] = qty;
		tierPricingConditionsMatrix[index][2] = implementationMethod;
		tierPricingConditionsMatrix[index][3] = core;
		tierPricingConditionsMatrix[index][4] = billingCounter;//CSYS-106564
		index = index + 1;
	}
}

count = 0;
recordCount = 0;


//CSYS-83094 (KA. 8-7-2017): replace ownerMarket with quoteMarket and replace ownerTheater with quoteTheater
for tierPricingCondition in tierPricingConditionsMatrix {
				lineItemPI = tierPricingCondition[0];
				lineItemQty = atoi(tierPricingCondition[1]); //No isnumber() check is needed here, because when this array was populated, the isnumber() check was already done (line 41)
				lineItemImplementationMethod = tierPricingCondition[2];
				lineCoreService = tierPricingCondition [3];
				lineBillingCounter = tierPricingCondition [4];
				isMatchingImplementationMethod = "N/A";

				//CSYS-88979 Moved this farther up to leverage the logic per line item for conditional pricing for State and Local
				/*packageId = "";
				if(containsKey(stringsDict, TILDA + lineItemPI + TILDA + piDelimiter + PACKAGE_ID)){
					packageId = get(stringsDict, TILDA + lineItemPI + TILDA + piDelimiter + PACKAGE_ID);
				}*/

				//CSYS-88979
				//CSYS-97295 (OC 9.30.2019) Removing quoteMrkt
				//quoteMrkt = "";
				/*if(packageId == stateAndLocalPackageId){
					quoteMrkt = quoteVertical;
				} else {*/
					//quoteMrkt = quoteMarket;
				//}

				//CSYS-106564 - Commented bmql.
				//tierPricingRecords = bmql("select pi, minTierQty, maxTierQty, price, implementationMethod, quoteTheater, quoteMarket, coreService, quoteType from stdTierPricing where priceList = $priceList and pi = $lineItemPI and ( minTierQty <= $lineItemQty  and maxTierQty >= $lineItemQty ) and (implementationMethod = $lineItemImplementationMethod or implementationMethod = '' or implementationMethod is null) and (quoteTheater = $quoteTheater or quoteTheater = '' or quoteTheater is null) and (quoteMarket = $quoteMarket or quoteMarket = '' or quoteMarket is null) and (coreService = $lineCoreService or coreService = '' or coreService is null) and (quoteType = $quoteType or quoteType = '' or quoteType is null)");
				
				

				rowImp = 33;

				itemType = "";
				if(containsKey(stringsDict, lineItemPI + piDelimiter + PI_ITEM_TYPE)){
					itemType = get(stringsDict, lineItemPI + piDelimiter + PI_ITEM_TYPE);
				}
				
				//CSYS-106564 - Start
				if(quoteMarket == "Japan" AND lineBillingCounter == "Expense User Based" AND (itemType == "Base" OR itemType == "Incremental")){
					lineCoreService = lineBillingCounter;
				}
					tierPricingRecords = bmql("select pi, minTierQty, maxTierQty, price, implementationMethod, quoteTheater, quoteMarket, coreService, quoteType from stdTierPricing where priceList = $priceList and pi = $lineItemPI and ( minTierQty <= $lineItemQty  and maxTierQty >= $lineItemQty ) and (implementationMethod = $lineItemImplementationMethod or implementationMethod = '' or implementationMethod is null) and (quoteTheater = $quoteTheater or quoteTheater = '' or quoteTheater is null) and (quoteMarket = $quoteMarket or quoteMarket = '' or quoteMarket is null) and (coreService = $lineCoreService or coreService = '' or coreService is null) and (quoteType = $quoteType or quoteType = '' or quoteType is null)");
				//CSYS-106564 - End
				
	
	for tierRecord in tierPricingRecords {
		//isMatchingImplementationMethod = "N/A";
		pi = get(tierRecord, "pi");
		strMinTierQty = get(tierRecord, "minTierQty");
		strMaxTierQty = get(tierRecord, "maxTierQty");
		strPrice = get(tierRecord, "price");
		implementationMethod = get(tierRecord, "implementationMethod");
		theater = get(tierRecord, "quoteTheater");
		market = get(tierRecord, "quoteMarket");
		service = get(tierRecord, "coreService");
		type = get(tierRecord, "quoteType");


		//CSYS-85811 (LN. 9/27/2017) Updates made to handle new Custom Pricing workflow, passing in actionName from pricing
		if((actionName == "updateCustomPrice") OR
			(actionName <> "updateCustomPrice" AND containskey(piQtyAndImplementationMethodToPriceDict, "customPricingExecuted" + piDelimiter + "customPricingExecuted"))){
			if(containskey(piQtyAndImplementationMethodToPriceDict, pi + piDelimiter + "customListPriceStdTierPricing")){
				//strPrice should equal the customListPriceStdTierPricing sent in as a paramter through Pricing f(x) 
				
				strPrice = string(get(piQtyAndImplementationMethodToPriceDict, pi + piDelimiter + "customListPriceStdTierPricing"));
				
			}
		}


		if (strMinTierQty <> "" and strMaxTierQty <> "") {
			if (isnumber(strMinTierQty) and isnumber(strMaxTierQty)) {
				minTierQty = integer(atof(strMinTierQty));
				maxTierQty = integer(atof(strMaxTierQty));
				
				//for tierPricingCondition in tierPricingConditionsMatrix {
					//lineItemPI = tierPricingCondition[0];
					//lineItemQty = atoi(tierPricingCondition[1]); //No isnumber() check is needed here, because when this array was populated, the isnumber() check was already done (line 41)
					//lineItemImplementationMethod = tierPricingCondition[2];
					//AND theater == quoteTheater AND market == quoteMarket AND service == lineCoreService AND type == quoteType AND implementationMethod == lineItemImplementationMethod)
					
				if (lineItemPI == pi ){
					if(theater == quoteTheater OR theater == ""){
						if( market == quoteMarket OR market == "") {
							if(service == lineCoreService OR service == ""){
								if(type == quoteType OR type == ""){ 
									if(implementationMethod == lineItemImplementationMethod OR implementationMethod == "" ){
										if (lineItemQty >= minTierQty and lineItemQty <= maxTierQty){
											if (theater <> "" AND market <> "" AND service <> "" AND type <> "" AND implementationMethod <> "" ){
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 1){
														put(pricingDict, 1, price);
														rowImp = 1;
													}															
													
													break;
												}
											}
											elif(theater <> "" AND market <> "" AND service == "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 2){
														put(pricingDict, 1, price);
														rowImp = 2;
													}
													
												}
											}
											elif(theater <> "" AND market <> "" AND service <> "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 3){
														put(pricingDict, 1, price);
														rowImp = 3;
													}
													
												}
											}
											elif(theater <> "" AND market <> "" AND service <> "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 4){
														put(pricingDict, 1, price);
														rowImp = 4;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service <> "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 5){
														put(pricingDict, 1, price);
														rowImp = 5;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service <> "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);

													
													if(rowImp > 6){
														put(pricingDict, 1, price);
														rowImp = 6;
													}
													
															
												}
											}
											elif(theater <> "" AND market <> "" AND service == "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 7){
														put(pricingDict, 1, price);
														rowImp = 7;
													}
													
															
												}
											}
											elif(theater <> "" AND market <> "" AND service == "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 8){
														put(pricingDict, 1, price);
														rowImp = 8;
													}
													
															
												}
											}
											elif(theater <> "" AND market <> "" AND service <> "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 9){
														put(pricingDict, 1, price);
														rowImp = 9;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service == "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 10){
														put(pricingDict, 1, price);
														rowImp = 10;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service <> "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 11){
														put(pricingDict, 1, price);
														rowImp = 11;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service <> "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 12){
														put(pricingDict, 1, price);
														rowImp = 12;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service == "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 13){
														put(pricingDict, 1, price);
														rowImp = 13;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service <> "" AND type <> "" AND implementationMethod == "" ){
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 14){
														put(pricingDict, 1, price);
														rowImp = 14;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service <> "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 15){
														put(pricingDict, 1, price);
														rowImp = 15;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service <> "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 16){
														put(pricingDict, 1, price);
														rowImp = 16;
													}
													
															
												}
											}
											elif(theater <> "" AND market <> "" AND service == "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 17){
														put(pricingDict, 1, price);
														rowImp = 17;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service == "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 18){
														put(pricingDict, 1, price);
														rowImp = 18;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service == "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 19){
														put(pricingDict, 1, price);
														rowImp = 19;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service <> "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 20){
														put(pricingDict, 1, price);
														rowImp = 20;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service == "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 21){
														put(pricingDict, 1, price);
														rowImp = 21;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service == "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 22){
														put(pricingDict, 1, price);
														rowImp = 22;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service <> "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 23){
														put(pricingDict, 1, price);
														rowImp = 23;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service == "" AND type <> "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 24){
														put(pricingDict, 1, price);
														rowImp = 24;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service <> "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 25){
														put(pricingDict, 1, price);
														rowImp = 25;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service <> "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 26){
														put(pricingDict, 1, price);
														rowImp = 26;
													}
													
															
												}
											}
											elif(theater <> "" AND market == "" AND service == "" AND type == "" AND implementationMethod == "" ){
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 27){
														put(pricingDict, 1, price);
														rowImp = 27;
													}
													
															
												}
											}
											elif(theater == "" AND market <> "" AND service == "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 28){
														put(pricingDict, 1, price);
														rowImp = 28;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service == "" AND type <> "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 29){
														put(pricingDict, 1, price);
														rowImp = 29;
													}
													
															
												}
											}
											elif(theater == "" AND market == "" AND service == "" AND type == "" AND implementationMethod <> "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 30){
														put(pricingDict, 1, price);
														rowImp = 30;
													}
													
															
													}
											}
											elif(theater == "" AND market == "" AND service <> "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 31){
														put(pricingDict, 1, price);
														rowImp = 31;
													}
													
															
													}
											}
											elif(theater == "" AND market == "" AND service == "" AND type == "" AND implementationMethod == "" ) {
												if (isnumber(strPrice)) {
													
													price = atof(strPrice);
													
													if(rowImp > 32){
														put(pricingDict, 1, price);
														rowImp = 32;
													}
																							
												}
											}
										}
									}
								}
							}
						}	
					}
				}
			}
		}
	}
	recordCount = recordCount + 1;
	
	// MM constainskey check SR=3-8925661361 5/2/14
	if (containskey(pricingDict, 1)){
		put(piQtyAndImplementationMethodToPriceDict, join(tierPricingCondition, piDelimiter), get(pricingDict, 1));	
	}//end MM
}



if (recordCount == 0) {
	put(resultDict, "error", "No records were returned from the stdTierPricing query");
} elif (count == 0) {
	put(resultDict, "error", "No tier prices found.");
}

put(resultDict, "count", string(count));

return resultDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>49924545</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[priceList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_priceList_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924546</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924547</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodToPriceDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1678338291000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_piQtyAndImplementationMethodToPriceDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924548</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1678338291000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_piQtyAndImplementationMethodList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924549</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924550</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[quoteTheater]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_quoteTheater_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924551</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[quoteMarket]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_quoteMarket_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49924552</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[quoteType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_quoteType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>405584585</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[actionName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338291000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_actionName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>463832971</id><bm_lib_func_id>49924544</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678338291000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_getStandTierPricing.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839302</id><name><![CDATA[x - setPropertiesForCIPParts]]></name><variable_name><![CDATA[setPropertiesOfCIPParts]]></variable_name><description><![CDATA[CSYS-100546 (OK. 3-3-2021) NOT IN USE. Created new function - setPropertiesForCIPParts with same code.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>989839301</function_id><date_modified>1617876443000</date_modified><guid><![CDATA[bm_lib_func_util_setPropertiesOfCIPParts]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839301</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setPropertiesOfCIPParts_1]]></java_class_name><child_class_names></child_class_names><date_modified>1617876443000</date_modified><guid><![CDATA[e997c746-bff8-43bf-9564-45282d68d76c]]></guid><script_size>789</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-96006
cipPiDict = dict("string");
TILDE_DELIMITER = "~";

cipRez = BMQL("SELECT partNumber, coreService, ServPartnerSpecialty, ServPartnerAuthrzns FROM cipSetupFees WHERE partNumber IN $partNumArr");

for entry in cipRez {
	cipPi = get(entry, "partNumber");
	cipCore = get(entry, "coreService");
	servicePartnerSpecialty = get(entry, "ServPartnerSpecialty");
	servPartnerAuthrzns = get(entry, "ServPartnerAuthrzns");

	if (servicePartnerSpecialty == "" AND servPartnerAuthrzns == ""){
		put(cipPiDict, cipPi, "true");
		put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
	}
	else{
		//CSYS-96006
		if ( find(partnerSpecialty, servicePartnerSpecialty) <> -1 OR
			 find(partnerAuthrzns, servPartnerAuthrzns) <> -1 ){

			//CSYS-96739 If there dictionary key is not yet populated, continue
			if(NOT(containskey(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore"))){
				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
			}
			//CSYS-96739 If there is already a key in the dictionary, update the key to include Invoice
			else {

				invoiceCore = split(cipCore, TILDE_DELIMITER);
				firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
				firstCipCore = firstCipCore + invoiceCore[1];

				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", firstCipCore + TILDE_DELIMITER);
			}

			put(cipPiDict, cipPi, "true");
		}
	}
}
return cipPiDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839303</id><bm_lib_func_id>989839302</bm_lib_func_id><param_name><![CDATA[partnerSpecialty]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1617876443000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesOfCIPParts.bm_lib_func_param_partnerSpecialty_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>989839304</id><bm_lib_func_id>989839302</bm_lib_func_id><param_name><![CDATA[partnerAuthrzns]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1617876443000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesOfCIPParts.bm_lib_func_param_partnerAuthrzns_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>989839305</id><bm_lib_func_id>989839302</bm_lib_func_id><param_name><![CDATA[partNumArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1617876443000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesOfCIPParts.bm_lib_func_param_partNumArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814706</id><name><![CDATA[convertToBMLDate]]></name><variable_name><![CDATA[convertToBMLDate]]></variable_name><description><![CDATA[NOT USED. Convert into BML Script Format]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4814705</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_convertToBMLDate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[// convertToBMLDate_TestScript 

inputDate = "2010-06-30";
result = util.convertToBMLDate(inputDate);
print inputDate + "  ====> " + result;
inputDate = "2012-07-15";
result = util.convertToBMLDate(inputDate);
print inputDate + "  ====> " + result;

return result;]]></main_script_text><_children><bm_function><id>4814705</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convertToBMLDate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435912000</date_modified><guid><![CDATA[LEGACY_4814705]]></guid><script_size>207</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  convertToBMLDate
  param:
    inputDate 
  return 
    string
*/


result = inputDate;

if (result <> "" ) {
  inputYear = substring(result, 0, 4);
  inputMonth = substring(result, 5, 7);
  inputDay = substring(result, 8, 10);

  result = inputMonth + "/" + inputDay + "/" + inputYear; 

} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814707</id><bm_lib_func_id>4814706</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_convertToBMLDate.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4978288</id><name><![CDATA[getXMLNodeValues]]></name><variable_name><![CDATA[getXMLNodeValues]]></variable_name><description><![CDATA[Variation of getXMLNode. Returns an array containing only the VALUES of all occurrences of a given node. Handles blank values as well as CDATA.]]></description><return_type>10</return_type><func_type>1</func_type><function_id>4978287</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getXMLNodeValues]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4978287</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getXMLNodeValues_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435914000</date_modified><guid><![CDATA[LEGACY_4978287]]></guid><script_size>841</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getXMLNodeValues
xmlString - String
xmlNodeName - String
*/
result = String[];

// maximum number of elements
loop = split(xmlString,"<" + xmlNodeName);
rest = xmlString;

attrTag = "<" + xmlNodeName + " ";		//"<from "
noAttrTag = "<" + xmlNodeName + ">";	//"<from>"
emptyTag = "<" + xmlNodeName + "/>";	//"<from/>"
endTag = "</" + xmlNodeName + ">";		//"</from>"

nodeTypes = String[]{attrTag,noAttrTag,emptyTag};
nodeTypeRange = range(sizeofarray(nodeTypes));

for i in loop {
	nextNodeIndex = -1;
	nextNodeType = -1;
	
	for j in nodeTypeRange {
		index = find(rest,nodeTypes[j]);
		if(index > -1 and (nextNodeIndex == -1 or nextNodeIndex > index)) { //If one of the attribute tags was found, and 
			nextNodeIndex = index;
			nextNodeType = j;
		}
	}
	
	if(nextNodeIndex == -1) {
		break;
	}
	
	if(nodeTypes[nextNodeType] == emptyTag) {
		endIndex = nextNodeIndex + len(emptyTag);
	}
	else {
		endIndex = find(rest,endTag);
		if(endIndex == -1) {
			break;
		}
		endIndex = endIndex + len(endTag);
	}
	
	tagsWithValue = substring(rest, nextNodeIndex, endIndex);
	startTagIndex = find(tagsWithValue, ">");
	value = substring(tagsWithValue, startTagIndex + 1);
	endTagIndex = find(value, "</");
	value = substring(value, 0, endTagIndex);
	
	append(result, value);
	rest = substring(rest,endIndex);
}
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4978290</id><bm_lib_func_id>4978288</bm_lib_func_id><param_name><![CDATA[xmlString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getXMLNodeValues.bm_lib_func_param_xmlString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4978291</id><bm_lib_func_id>4978288</bm_lib_func_id><param_name><![CDATA[xmlNodeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getXMLNodeValues.bm_lib_func_param_xmlNodeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814709</id><name><![CDATA[initIntList]]></name><variable_name><![CDATA[initIntList]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>8</return_type><func_type>1</func_type><function_id>4814708</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_initIntList]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814708</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_initIntList_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435912000</date_modified><guid><![CDATA[LEGACY_4814708]]></guid><script_size>186</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  initIntList 
  param:
    numElement      - integer
    defaultValue    - integer
  return 
    integer[];
*/
result = integer[];

list = range(numElement);

for element in list {
  result[element] = defaultValue;
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814710</id><bm_lib_func_id>4814709</bm_lib_func_id><param_name><![CDATA[numElement]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_initIntList.bm_lib_func_param_numElement_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814711</id><bm_lib_func_id>4814709</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_initIntList.bm_lib_func_param_defaultValue_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839297</id><name><![CDATA[getCountryISOCode]]></name><variable_name><![CDATA[getCountryISOCode]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>989839296</function_id><date_modified>1599705697000</date_modified><guid><![CDATA[bm_lib_func_util_getCountryISOCode]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839296</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getCountryISOCode_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705697000</date_modified><guid><![CDATA[d463b620-acd9-43f8-a0bb-70ac00146d09]]></guid><script_size>174</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getCountryIsoCode
billingCountry - String
*/
countryIsoCode = "";
billingCountryCodeResSet = bmql("SELECT metraNetCountry FROM countryCodeMapping WHERE bmiCountry = $billingCountry");
for billingCountryCodeRes in billingCountryCodeResSet {
	//countryIsoCode = get(billingCountryCodeRes, "	");//old
	countryIsoCode = get(billingCountryCodeRes, "metraNetCountry");//correction dwc 20200825
	
}
return countryIsoCode;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839298</id><bm_lib_func_id>989839297</bm_lib_func_id><param_name><![CDATA[billingCountry]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1599705697000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getCountryISOCode.bm_lib_func_param_billingCountry_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5190927</id><name><![CDATA[calculateUnifiedPricing]]></name><variable_name><![CDATA[calculateUnifiedPricing]]></variable_name><description><![CDATA[Among other things, this function calculates Base Fee Net and Inc Fee Net at the line ramp level.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>5190926</function_id><date_modified>1626948716000</date_modified><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5190926</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_calculateUnifiedPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948717000</date_modified><guid><![CDATA[LEGACY_5190926]]></guid><script_size>35606</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> calculateUnifiedPricing 

unifiedPricingDataDict - String[] Dictionary 
unifiedPricingDataRowCount - Integer
docToChildNumListDict - String[] Dictionary
currentDocNum - String
stringsDict - String Dictionary
integersDict - Integer Dictionary
floatDict - Float Dictionary

11/26/2013 Edited by Lawrence Fodge to add promotions. TODO: not found in unifiedPRicing datatable
*/
result = false;
iterArr = range(unifiedPricingDataRowCount);
docNumPODict = dict("string"); // key: document_number; value: PO_ID
docNumPOCatDict = dict("string"); // key: document_number; value: PO_CATEGORY
docNumItemTypeDict = dict("string"); // key: document_number; value: Item Type
docNumRollupDict = dict("string"); // key: document_number; value:Roll up
docNumNumOfRampsDict = dict("integer"); // key: document_number; value:Number of Ramps
docNumFromRampsDict = dict("string"); // key: document_number; value:From ramps 
docNumToRampsDict = dict("string"); // key: document_number; value:to ramps

debug = false;
childNumArr = string[];
allChildrenNumArr = string[];
isGrouped = "";
partNum = "";
poId = "";
poCat = "";
itemType = "";
rollUp = "";
fromRamps = "";
toRamps = "";
DELIMITER = "@.@";
PART_NUM = "_part_number";
PO_ID = "poId_line";
PO_CATEGORY = "poCategory_line";
IS_GROUPED = "isPartOfPackage_line";
TRUE_STR = "true";
LIST_PRICE = "listPrice_line";
EXT_LIST = "extendedList_line";
NET_EACH = "netPriceEach_line";
EXT_NET = "extendedNetPrice_line";
TERM_BASED_PRICE = "termBasedListPrice_line";
EXT_TERM_BASED_PRICE = "extTermBasedListPrice_line";
PROMO_PRICE = "promoPrice_line";
NET_PRICE_UNIFIED = "netPriceUnified_line";
EXT_NET_PRICE_UNIFIED = "extNetPriceUnified_line";
QTY = "numCommittedTransaction_line";
DISCOUNT = "discount_line";
DISCOUNT_TYPE = "discountType_line";
PERCENTAGE_DISCOUNT_TYPE = "%";
AMOUNT_DISCOUNT_TYPE = "Amt";
ITEM_TYPE = "piItemType_line";
ROLL_UP = "rollUp_line";
PERCENTAGE_DISCOUNT_TYPE = "%";
AMOUNT_DISCOUNT_TYPE = "Amt";
SETUP_FEE = "Setup";
INCR_FEE = "Incremental";
BASE_FEE = "Base";
PRE_PROD = "Pre Prod";
CORE_SERVICE_CATEGORY = "Core Service";
PROD_PRICE = "productBasedPrice_line";
PROD_ROLL = "productBasedPriceRollUp";
RAMP_DELIMITER = "-_**_-";
NUMBER_RAMP_ENTRIES = "numRampEntries";
FROM = "from";
TO = "to";
PRICE_DELIMITER = "*.*";
RAMP_MESSAGE = "rampValidationMessage_quote";
INCREMENTAL_FEE_LIST = "incrementalFeeList";
INCREMENTAL_FEE_NET = "incrementalFeeNet";
RAMP_FLAG = "rampFlag_line";
IS_RAMPABLE = "isRampable";
DISCOUNT_AMOUNT = "discountAmt_line";
rampValidationMessage = "";
INCREMENTAL_FEE_RATIO_VALUE = "incrementalFeeRatioValue";
NET_PRICE_UNIFIED = "netPriceUnified_line";
EXT_NET_PRICE_UNIFIED = "extNetPriceUnified_line";
RAMP_PRICE_FOR_NON_RAMPABLE_BASE = "rampPriceForNonRampableBase";
UNIFIED_LIST_PRICE = "unifiedListPrice";
NON_RAMPABLE_BASE_INCREMENTAL_STRING = "nonRampableBaseIncrementalString";
BASE_LIST_PRICE_UNIFIED = "listPriceUnified";
TRANS_VALIDATION_APPLIES = "transValidationApplies"; //CSYS-70683
NONE_ACTION = "NONE";

// Get the document number of all the children for this model
if(containskey(docToChildNumListDict, currentDocNum)) {
	allChildrenNumArr = get(docToChildNumListDict, currentDocNum);
}
// Get only the grouped line items under that model
for childNum in allChildrenNumArr {
	isGroupedKey = childNum + DELIMITER + IS_GROUPED;
	if (containskey(stringsDict, isGroupedKey)) {
		isGrouped = get(stringsDict, isGroupedKey);
	}
	if(isGrouped == TRUE_STR) {
		append(childNumArr, childNum);
	}
}

				  
// Get the partnumber and PO of each of the children
for childNum in childNumArr {
	partNumLookupKey = childNum + DELIMITER + PART_NUM;
	if (containskey(stringsDict, partNumLookupKey)) {
		partNum = get(stringsDict, partNumLookupKey);
	}
	poIdLookupKey = partNum + DELIMITER + PO_ID;
	if (containskey(stringsDict, poIdLookupKey)) {
		poId = get(stringsDict, poIdLookupKey);
	}
	itemTypeLookupKey = partNum + DELIMITER + ITEM_TYPE;
	if (containskey(stringsDict, itemTypeLookupKey)) {
		itemType = get(stringsDict, itemTypeLookupKey);
	}
	rollUpLookupKey = partNum + DELIMITER + ROLL_UP;
	if (containskey(stringsDict, rollUpLookupKey)) {
		rollUp = get(stringsDict, rollUpLookupKey);
	}
	poCatLookupKey = partNum + DELIMITER + PO_CATEGORY;
	if (containskey(stringsDict, poCatLookupKey)) {
		poCat = get(stringsDict, poCatLookupKey);
	}
	numOfRampsLookupKey = childNum + DELIMITER + NUMBER_RAMP_ENTRIES;
	numOfRamps = 0;
	if(containskey(integersDict, numOfRampsLookupKey)) {
		numOfRamps = get(integersDict, numOfRampsLookupKey);
	}
	fromRampsLookupKey = childNum + DELIMITER + FROM;
	if(containskey(stringsDict, fromRampsLookupKey)) {
		fromRamps = get(stringsDict, fromRampsLookupKey);
	}
	toRampsLookupKey = childNum + DELIMITER + TO;
	if(containskey(stringsDict, toRampsLookupKey)) {
		toRamps = get(stringsDict, toRampsLookupKey);
	}
	if(find(childNum, "_**_") == -1) { // Base Fee has multiple entries in the dict
		put(docNumPODict, childNum, poId);
		put(docNumPOCatDict, childNum, poCat);
		put(docNumItemTypeDict, childNum, itemType);
		put(docNumRollupDict, childNum, rollUp);
		put(docNumNumOfRampsDict, childNum, numOfRamps);
		put(docNumFromRampsDict, childNum, fromRamps);
		put(docNumToRampsDict, childNum, toRamps);
	}
}

// Check for validation for ramps. All Base fee (grouped line items) line items' ramps must be the same
numOfRampsArr = integer[];
fromRampsArr = string[];
toRampsArr = string[];
counter = 0;
for childNum in childNumArr {
	childItemType = "";
	childNumOfRamps = 0;
	childFromRamps = "";
	childToRamps = "";
	poId = "";
	if(containskey(docNumItemTypeDict, childNum)) {
		childItemType = get(docNumItemTypeDict, childNum);
	}
	if(containskey(docNumNumOfRampsDict, childNum)) {
		childNumOfRamps = get(docNumNumOfRampsDict, childNum);
	}
	if(containskey(docNumFromRampsDict, childNum)) {
		childFromRamps = get(docNumFromRampsDict, childNum);
	}
	if(containskey(docNumToRampsDict, childNum)) {
		childToRamps = get(docNumToRampsDict, childNum);
	}
	if(containskey(docNumPODict, childNum)) { //CSYS-70683
		poId = get(docNumPODict, childNum);
	}
	isRampable = "false";
	if ( containskey( stringsDict, childNum + DELIMITER + IS_RAMPABLE ) ){
		isRampable = get( stringsDict, childNum + DELIMITER + IS_RAMPABLE );
	}
	transValidation = ""; //CSYS-70683
	if ( poId <> "" AND containskey( stringsDict, poId + DELIMITER + TRANS_VALIDATION_APPLIES ) ){
		transValidation = get( stringsDict, poId + DELIMITER + TRANS_VALIDATION_APPLIES );
	}
	
	if(childItemType == BASE_FEE AND isRampable == TRUE_STR AND transValidation == TRUE_STR) { //CSYS-70683: added the transValidation check
		append(numOfRampsArr, childNumOfRamps);
		append(fromRampsArr, childFromRamps);
		append(toRampsArr, childToRamps);
		counter = counter + 1;
	}
}
counterArr = range(counter);
for count in counterArr {
	if(numOfRampsArr[count] <> numOfRampsArr[0]) {
		rampValidationMessage = rampValidationMessage + "Number of Ramps in grouped line items don't match. ";
		break;
	}
	if(fromRampsArr[count] <> fromRampsArr[0]) {
		rampValidationMessage = rampValidationMessage + "From Ramps in grouped line items don't match. ";
		break;
	}
	if(toRampsArr[count] <> toRampsArr[0]) {
		rampValidationMessage = rampValidationMessage + "To Ramps in grouped line items don't match. ";
		break;
	}
}

for item in iterArr {
	itemKey = string(item) + DELIMITER + currentDocNum;
	if ( containskey( unifiedPricingDataDict, itemKey ) <> true ){
		itemKey = string(item);
	}
	if(containskey(unifiedPricingDataDict, itemKey)) {
		POArr = get(unifiedPricingDataDict, itemKey); // POArr[0]=coreProdPO, POArr[1]==unifiedPO
		baseUnifiedPrice = 0.0;
		setUpUnifiedPrice = 0.0;
		incrUnifiedPrice = 0.0;
		preProdUnifiedPrice = 0.0;
		
		// Added by Lawrence 11/26/2013 for promotion compatibility
		basePromo = 0.0;
		setupPromo = 0.0;
		incrPromo = 0.0;
		preProdPromo = 0.0;
		extBasePromo = 0.0;
		extSetupPromo = 0.0;
		extIncrPromo = 0.0;
		extPreProdPromo = 0.0;
		
		baseUnifiedPriceExt = 0.0;
		setUpUnifiedPriceExt = 0.0;
		incrUnifiedPriceExt = 0.0;
		preProdUnifiedPriceExt = 0.0;
		childPOArr = values(docNumPODict); // Size of childNumArr, childPOArr and docNumPODict will all be the same
		childPOArrIndex = 0;
		baseCoreDocNum = "";
		setUpCoreDocNum = "";
		incrCoreDocNum = "";
		preProdCoreDocNum = "";
		baseUnifiedDocNum = "";
		setUpUnifiedDocNum = "";
		incrUnifiedDocNum = "";
		preProdUnifiedDocNum = "";
		disc = 0.0;
		discType = "";
		incrDisc = 0.0;
		incrDiscType = "";
		//modelDisc = 0.0;
		//modelDiscType = "";
		numTrxns = 0;
		baseListArr = string[];
		summedUpBaseListArr = float[];
		summedUpBaseListCountArr = integer[];
		incrListArr = string[];
		summedUpIncrListArr = float[];
		summedUpIncrListCountArr = integer[];
		prodPriceArr = string[];
		summedUpProdPriceArr = float[];

		/*for childPO in childPOArr {
			
			if(childPO == POArr[0]) {
				coreDocNum = childNumArr[childPOArrIndex];
				priceLookupKey = coreDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					unifiedPrice = unifiedPrice + get(floatDict, priceLookupKey);
				}
			} elif(childPO == POArr[2]) {
				unifiedDocNum = childNumArr[childPOArrIndex];
				priceLookupKey = unifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					unifiedPrice = unifiedPrice + get(floatDict, priceLookupKey);
				}
			} 
		}*/
		// Unified Product Based price for saving as ramp XML LIst price
		unifiedProductAsListPrice = 0.0;
		for childNum in childNumArr {
			childPO = "";
			childItemType = "";
			childRollUp = "";
			childPOCat = "";
			childNumOfRamps = 0;
			
			if(containskey(docNumPODict, childNum)) {
				childPO = get(docNumPODict, childNum);
			}

				  
				   
	
			if(containskey(docNumItemTypeDict, childNum)) {
				childItemType = get(docNumItemTypeDict, childNum);
			}
			if(containskey(docNumRollUpDict, childNum)) {
				childRollUp = get(docNumRollUpDict, childNum);
			}
			if(containskey(docNumPOCatDict, childNum)) {
				childPOCat = get(docNumPOCatDict, childNum);
			}
			if(containskey(docNumNumOfRampsDict, childNum)) {
				childNumOfRamps = get(docNumNumOfRampsDict, childNum);
			}
			rampsArr = range(childNumOfRamps);
			//put( floatDict, rampKey + DELIMITER + PROD_ROLL, prodPrice );
			if(childPO == POArr[0] AND childItemType == BASE_FEE) {
				if(childRollUp == "Y") {
					baseCoreDocNum = childNum;
					priceLookupKey = baseCoreDocNum + DELIMITER + LIST_PRICE;
					
					if (containskey(floatDict, priceLookupKey)) {			
						baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
					}
					// Added by Lawrence for promo integration
					promoKey = baseCoreDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						basePromo = basePromo + get( floatDict, promoKey );
					}
					promoKey = baseCoreDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extBasePromo = extBasePromo + get( floatDict, promoKey );
					}
					
					priceLookupKey = baseCoreDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {			
						baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
					if(rampValidationMessage == "") {
						index = 0;
						listPriceStr = "";
						incrListPriceStr = "";
						prodPriceString = "";
						summedUpBaseListCountArr = range(childNumOfRamps); // Set the size here
						summedUpIncrListCountArr = range(childNumOfRamps); // Set the size here
						
						for ramp in rampsArr {
							rampKey = childNum + RAMP_DELIMITER + string(index);
							extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
							//incrListLookUpKey = rampKey + DELIMITER + LIST_PRICE;
							incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_RATIO_VALUE;
							prodPriceLookupKey = rampKey + DELIMITER + PROD_PRICE;
							if(containskey(floatDict, extListLookUpKey)) {
								// Use ramp price for non rampable base only here in the core base fee
								listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey)) + PRICE_DELIMITER; 
							}
							if(containskey(floatDict, incrListLookUpKey)) {
								incrListPriceStr = incrListPriceStr + string(get(floatDict, incrListLookUpKey)) + PRICE_DELIMITER; 
							}
							
							if ( containskey(floatDict, prodPriceLookupKey ) ){
								prodPriceString = prodPriceString + string(get(floatDict, prodPriceLookupKey)) + PRICE_DELIMITER; 
							}
							index = index + 1;
						}
						append(baseListArr, listPriceStr);
						append(incrListArr, incrListPriceStr);
						append(prodPriceArr, prodPriceString);
					}
				} else {
					baseUnifiedDocNum = childNum;
					priceLookupKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {
								
						baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
					
					}
					// Added by Lawrence for promo integration
					promoKey = baseUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						basePromo = basePromo + get( floatDict, promoKey );
					}
					// Added by Lawrence for promo integration
					promoKey = baseUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extBasePromo = extBasePromo + get( floatDict, promoKey );
					}
					
					priceLookupKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {
		
						baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);
					
					}
					// Zero out the prices of the unified PI
					listPriceKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + TERM_BASED_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_TERM_BASED_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + NET_EACH;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_NET;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = baseUnifiedDocNum + DELIMITER + PROMO_PRICE;
					put(floatDict, listPriceKey, 0.0);
				
		
					
					if(rampValidationMessage == "") {
						index = 0;
						listPriceStr = "";
						incrListPriceStr = "";
						prodPriceString = "";
						for ramp in rampsArr {
							
							rampKey = childNum + RAMP_DELIMITER + string(index);
							extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
							extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
							//incrListLookUpKey = rampKey + DELIMITER + LIST_PRICE;
							incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_RATIO_VALUE;
							prodPriceLookupKey = rampKey + DELIMITER + PROD_PRICE;
							if(containskey(floatDict, extListLookUpKey)) {
								listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey) )+ PRICE_DELIMITER; 
							}
							if(containskey(floatDict, incrListLookUpKey)) {
								incrListPriceStr = incrListPriceStr + string(get(floatDict, incrListLookUpKey) )+ PRICE_DELIMITER; 
							}
							
							if ( containskey(floatDict, prodPriceLookupKey ) ){
								prodPriceString = prodPriceString + string(get(floatDict, prodPriceLookupKey)) + PRICE_DELIMITER; 
							}
							
							// Zero out the prices for non Core
							put(floatDict, extListLookUpKey, 0.0);
							put(floatDict, extNetLookUpKey, 0.0);
							// Zero out the incremental prices
							incrFeeListKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
							incrFeeNetKey = rampKey + DELIMITER + INCREMENTAL_FEE_NET;
							prodKey = rampkey + DELIMITER + PROD_ROLL;
							put(floatDict, incrFeeListKey, 0.0);
							put(floatDict, incrFeeNetKey, 0.0);
							put(floatDict, prodKey, 0.0 );
							index = index + 1;
						}
						append(baseListArr, listPriceStr);
						append(incrListArr, incrListPriceStr);
						append(prodPriceArr, prodPriceString );
					}
				}
			} elif(childPO == POArr[1] AND childItemType == BASE_FEE) {
				baseUnifiedDocNum = childNum;
				priceLookupKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {
							
					baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
					
				}
				// Added by Lawrence for promo integration
				promoKey = baseUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					basePromo = basePromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = baseUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extBasePromo = extBasePromo + get( floatDict, promoKey );
				}
				
				
				priceLookupKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {
						
					baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);
					
				}
				// Zero out the prices of the unified PI
				listPriceKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + TERM_BASED_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_TERM_BASED_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + NET_EACH;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_NET;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + PROMO_PRICE;
				put(floatDict, listPriceKey, 0.0);
				
				
				if(rampValidationMessage == "") {
					index = 0;
					listPriceStr = "";
					incrListPriceStr = "";
					prodPriceString = "";
					for ramp in rampsArr {
						rampKey = childNum + RAMP_DELIMITER + string(index);
						extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
						extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
						incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_RATIO_VALUE;
						prodPriceLookupKey = rampKey + DELIMITER + PROD_PRICE;
						if(containskey(floatDict, extListLookUpKey)) {
							listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey) )+ PRICE_DELIMITER; 
						}
						if(containskey(floatDict, incrListLookUpKey)) {
							incrListPriceStr = incrListPriceStr + string(get(floatDict, incrListLookUpKey) )+ PRICE_DELIMITER; 
						}
						if ( containskey(floatDict, prodPriceLookupKey ) ){
								prodPrice = get( floatDict, prodPriceLookupKey );
								unifiedProductAsListPrice = unifiedProductAsListPrice + prodPrice;	
						}
						if ( containskey(floatDict, prodPriceLookupKey ) ){
								prodPriceString = prodPriceString + string(get(floatDict, prodPriceLookupKey)) + PRICE_DELIMITER; 
						}
						/*
						if (containskey( floatDict, prodPriceLookupKey ) ){
								prodPrice = get( floatDict, prodPriceLookupKey );
								prodRollLookupKey = rampKey + DELIMITER + PROD_ROLL;
								put( floatDict, prodRollLookupKey, 0.0 );
								existingProdKey = baseCoreDocNum + RAMP_DELIMITER + string(index) + DELIMITER + PROD_ROLL;
								existingProdPrice = get(floatDict, existingProdKey );
								newPrice = existingProdPrice + prodPrice;
								  
					   
							  
								put( floatDict, existingProdKey, newPrice );
						}*/
						// Zero out the prices for non Core
						put(floatDict, extListLookUpKey, 0.0);
						put(floatDict, extNetLookUpKey, 0.0);
						// Zero out the incremental prices
						incrFeeListKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
						incrFeeNetKey = rampKey + DELIMITER + INCREMENTAL_FEE_NET;
						prodKey = rampkey + DELIMITER + PROD_ROLL;
						put(floatDict, incrFeeListKey, 0.0);
						put(floatDict, incrFeeNetKey, 0.0);
						put(floatDict, prodKey, 0.0 );
						index = index + 1;
					}
					append(baseListArr, listPriceStr);
					append(incrListArr, incrListPriceStr);
					append(prodPriceArr, prodPriceString );
				}
			} elif(childPO <> POArr[0] AND childPO <> POArr[1] AND childItemType == BASE_FEE AND ((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <> CORE_SERVICE_CATEGORY))) {
				baseUnifiedDocNum = childNum;
				priceLookupKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {
					
					baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
				}
				
				// Added by Lawrence for promo integration
				promoKey = baseUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					basePromo = basePromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = baseUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extBasePromo = extBasePromo + get( floatDict, promoKey );
				}
				
				
				priceLookupKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {
				
					baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);

				}
				// Zero out the prices of the unified PI
				listPriceKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
				if(rampValidationMessage == "") {
					index = 0;
					listPriceStr = "";
					incrListPriceStr = "";
					prodPriceString = "";
					for ramp in rampsArr {
						rampKey = childNum + RAMP_DELIMITER + string(index);
						extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
						extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
						incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_RATIO_VALUE;
						prodPriceLookupKey = rampKey + DELIMITER + PROD_PRICE;
						if(containskey(floatDict, extListLookUpKey)) {
							listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey) )+ PRICE_DELIMITER; 
						}
						if(containskey(floatDict, incrListLookUpKey)) {
							incrListPriceStr = incrListPriceStr + string(get(floatDict, incrListLookUpKey) )+ PRICE_DELIMITER; 
						}
						if ( containskey(floatDict, prodPriceLookupKey ) ){
								prodPriceString = prodPriceString + string(get(floatDict, prodPriceLookupKey)) + PRICE_DELIMITER; 
						}
						// Zero out the prices for non Core
						put(floatDict, extListLookUpKey, 0.0);
						put(floatDict, extNetLookUpKey, 0.0);
						// Zero out the incremental prices
						incrFeeListKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
						incrFeeNetKey = rampKey + DELIMITER + INCREMENTAL_FEE_NET;
						prodKey = rampkey + DELIMITER + PROD_ROLL;
						put(floatDict, incrFeeListKey, 0.0);
						put(floatDict, incrFeeNetKey, 0.0);
						put(floatDict, prodKey, 0.0 );
						index = index + 1;
					}
					append(baseListArr, listPriceStr);
					append(incrListArr, incrListPriceStr);
					append(prodPriceArr, prodPriceString );
				}
			} elif(childPO == POArr[0] AND childItemType == SETUP_FEE) {
				if(childRollUp == "Y") {
					setUpCoreDocNum = childNum;
					priceLookupKey = setUpCoreDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {			
						setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
					}
					// Added by Lawrence for promo integration
					promoKey = setUpCoreDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						setupPromo = setupPromo + get( floatDict, promoKey );
					}
					// Added by Lawrence for promo integration
					promoKey = setUpCoreDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extSetupPromo = extSetupPromo + get( floatDict, promoKey );
					}
					
					priceLookupKey = setUpCoreDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {			
						setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
				} else {
					setUpUnifiedDocNum = childNum;
					priceLookupKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {			
						setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
					}
					// Added by Lawrence for promo integration
					promoKey = setUpUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						setupPromo = setupPromo + get( floatDict, promoKey );
					}
					// Added by Lawrence for promo integration
					promoKey = setUpUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extSetupPromo = extSetupPromo + get( floatDict, promoKey );
					}	
					
					priceLookupKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {			
						setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
					// Zero out the prices of the unified PI
					listPriceKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
					put(floatDict, listPriceKey, 0.0);
				}
			} elif(childPO == POArr[1] AND childItemType == SETUP_FEE) {
				setUpUnifiedDocNum = childNum;
				priceLookupKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
				}
				priceLookupKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {			
					setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
				}
				// Added by Lawrence for promo integration
				promoKey = setUpUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					setupPromo = setupPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = setUpUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extSetupPromo = extSetupPromo + get( floatDict, promoKey );
				}
				
				// Zero out the prices of the unified PI
				listPriceKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			} elif(childPO <> POArr[0] AND childPO <> POArr[1] AND childItemType == SETUP_FEE AND ((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <> CORE_SERVICE_CATEGORY))) {
				setUpUnifiedDocNum = childNum;
				priceLookupKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
				}
				priceLookupKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {			
					setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
				}
				
				// Added by Lawrence for promo integration
				promoKey = setUpUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					setupPromo = setupPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = setUpUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extSetupPromo = extSetupPromo + get( floatDict, promoKey );
				}
				
				// Zero out the prices of the unified PI
				listPriceKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}  elif(childPO == POArr[0] AND childItemType == INCR_FEE) {
				if(childRollUp == "Y") {

					incrCoreDocNum = childNum;
					priceLookupKey = incrCoreDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {			
						incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
						
					}
					// Added by Lawrence for promo integration
					promoKey = incrCoreDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						incrPromo = incrPromo + get( floatDict, promoKey );
					}
					// Added by Lawrence for promo integration
					promoKey = incrCoreDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extIncrPromo = extIncrPromo + get( floatDict, promoKey );
					}

					
			   
										   
							 
	  
					priceLookupKey = incrCoreDocNum + DELIMITER + EXT_LIST;										
					if (containskey(floatDict, priceLookupKey)) {			
						incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
				} else {
					incrUnifiedDocNum = childNum;
					priceLookupKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;

					if (containskey(floatDict, priceLookupKey)) {
						
						incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
					
						
					}
					// Added by Lawrence for promo integration
					promoKey = incrUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						incrPromo = incrPromo + get( floatDict, promoKey );
					}
					// Added by Lawrence for promo integration
					promoKey = incrUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
					if ( containskey( floatDict, promoKey )){
						extIncrPromo = extIncrPromo + get( floatDict, promoKey );
					}
					
					priceLookupKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {
									
						incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
						
					}
					// Zero out the prices of the unified PI
					listPriceKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
					put(floatDict, listPriceKey, 0.0);
				}
			} elif(childPO == POArr[1] AND childItemType == INCR_FEE) {
				incrUnifiedDocNum = childNum;
				priceLookupKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {
						
					incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
					
				}
				// Added by Lawrence for promo integration
				promoKey = incrUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					incrPromo = incrPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = incrUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extIncrPromo = extIncrPromo + get( floatDict, promoKey );
				}
				
				priceLookupKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {
						
					incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
				
				}
				// Zero out the prices of the unified PI
				listPriceKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			} elif(childPO <> POArr[0] AND childPO <> POArr[1] AND childItemType == INCR_FEE AND ((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <> CORE_SERVICE_CATEGORY))) {
				incrUnifiedDocNum = childNum;
				priceLookupKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {
							
					incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
					
				}
				// Added by Lawrence for promo integration
				promoKey = incrUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					incrPromo = incrPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = incrUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extIncrPromo = extIncrPromo + get( floatDict, promoKey );
				}
				
				priceLookupKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {
							
					incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
					
				}
		
										  
							   
	 
				// Zero out the prices of the unified PI
				listPriceKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			} elif(childPO == POArr[0] AND childItemType == PRE_PROD) {
				if(childRollUp == "Y") {
					preProdCoreDocNum = childNum;
					priceLookupKey = preProdCoreDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {			
						preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
					}
					// Added by Lawrence for promo integration
				promoKey = preProdCoreDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					preProdPromo = preProdPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = preProdCoreDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extPreProdPromo = extPreProdPromo + get( floatDict, promoKey );
				}
				
				
					priceLookupKey = preProdCoreDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {			
						preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
				} else {
					preProdUnifiedDocNum = childNum;
					priceLookupKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
					if (containskey(floatDict, priceLookupKey)) {			
						preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
					}
						// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					preProdPromo = preProdPromo + get( floatDict, promoKey );
				}
				// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extPreProdPromo = extPreProdPromo + get( floatDict, promoKey );
				}
					priceLookupKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
					if (containskey(floatDict, priceLookupKey)) {			
						preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
					}
					// Zero out the prices of the unified PI
					listPriceKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
					put(floatDict, listPriceKey, 0.0);
					listPriceKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
					put(floatDict, listPriceKey, 0.0);
				}
			} elif(childPO == POArr[1] AND childItemType == PRE_PROD) {
				preProdUnifiedDocNum = childNum;
				priceLookupKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
				}
						// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					preProdPromo = preProdPromo + get( floatDict, promoKey );
				}
					// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extPreProdPromo = extPreProdPromo + get( floatDict, promoKey );
				}
				
				
				priceLookupKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {			
					preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
				}
				// Zero out the prices of the unified PI
				listPriceKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			} elif(childPO <> POArr[0] AND childPO <> POArr[1] AND childItemType == PRE_PROD AND ((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <> CORE_SERVICE_CATEGORY))) {
				preProdUnifiedDocNum = childNum;
				priceLookupKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
				if (containskey(floatDict, priceLookupKey)) {			
					preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
				}
						// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "promotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					preProdPromo = preProdPromo + get( floatDict, promoKey );
				}
					// Added by Lawrence for promo integration
				promoKey = preProdUnifiedDocNum + DELIMITER + "extPromotionPriceAppliedToList";
				if ( containskey( floatDict, promoKey )){
					extPreProdPromo = extPreProdPromo + get( floatDict, promoKey );
				}
				
				
				priceLookupKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
				if (containskey(floatDict, priceLookupKey)) {			
					preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
				}
				// Zero out the prices of the unified PI
				listPriceKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}
		}
		// Assign the unified price to the list price of the line item corresponding to the coreDocNum
		listPriceKey = baseCoreDocNum + DELIMITER + LIST_PRICE;
		put(floatDict, listPriceKey, baseUnifiedPrice);
		listPriceKey = setUpCoreDocNum + DELIMITER + LIST_PRICE;
		put(floatDict, listPriceKey, setUpUnifiedPrice);
		listPriceKey = incrCoreDocNum + DELIMITER + LIST_PRICE;
		put(floatDict, listPriceKey, incrUnifiedPrice);
		listPriceKey = preProdCoreDocNum + DELIMITER + LIST_PRICE;
		put(floatDict, listPriceKey, preProdUnifiedPrice);
		
		// Lawrence
		// Assign the total promotion prices to the core line items to be used in net price calculations
		promoKey = baseCoreDocNum + DELIMITER + "unifiedBasePromoPrice";
		put( floatDict, promoKey, basePromo );
		promoKey = setUpCoreDocNum + DELIMITER + "unifiedSetupPromoPrice";
		put( floatDict, promoKey, setupPromo );
		promoKey = incrCoreDocNum + DELIMITER + "unifiedIncrPromoPrice";
		put( floatDict, promoKey, incrPromo);
		promoKey = preProdCoreDocNum + DELIMITER + "unifiedPreProdPromoPrice";
		put( floatDict, promoKey, preProdPromo );
		
		
		listPriceKey = baseCoreDocNum + DELIMITER + EXT_LIST;
		put(floatDict, listPriceKey, baseUnifiedPriceExt);
		listPriceKey = setUpCoreDocNum + DELIMITER + EXT_LIST;
		put(floatDict, listPriceKey, setUpUnifiedPriceExt);
		listPriceKey = incrCoreDocNum + DELIMITER + EXT_LIST;
		put(floatDict, listPriceKey, incrUnifiedPriceExt);
		listPriceKey = preProdCoreDocNum + DELIMITER + EXT_LIST;
		put(floatDict, listPriceKey, preProdUnifiedPriceExt);
		
		// Initialize the summedUpList Array here
		for baseList in summedUpBaseListCountArr {
			append(summedUpBaseListArr, 0.0);
		}
		
		// Calculate Ramp level list prices
		rampPriceForNonRampableBase = 0.0;
		for priceStr in baseListArr {
			eachLineRampPriceArr = split(priceStr, PRICE_DELIMITER);
			priceIndex = 0;
			for eachLineRampPrice in eachLineRampPriceArr {
				if(eachLineRampPrice <> "" AND isnumber(eachLineRampPrice)) {
					summedUpBaseListArr[priceIndex] = summedUpBaseListArr[priceIndex] + atof(eachLineRampPrice);
				}
				priceIndex = priceIndex + 1;
			}
		}
		if(rampValidationMessage == "") {
			index = 0;
			for summedUpBaseList in summedUpBaseListArr {
				rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
				extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
				put(floatDict, extListLookUpKey, summedUpBaseList);
				index = index + 1;
			}
		}
		
		for priceStr in incrListArr {
			eachLineRampPriceArr = split(priceStr, PRICE_DELIMITER);
			priceIndex = 0;
			for eachLineRampPrice in eachLineRampPriceArr {
				if(eachLineRampPrice <> "" AND isnumber(eachLineRampPrice)) {
					summedUpIncrListArr[priceIndex] = summedUpIncrListArr[priceIndex] + atof(eachLineRampPrice);
				}
				priceIndex = priceIndex + 1;
			}
		}
		
		for priceStr in prodPriceArr{
			eachLineRampPriceArr = split(priceStr, PRICE_DELIMITER);
			priceIndex = 0;
			for eachLineRampPrice in eachLineRampPriceArr{
				if(eachLineRampPrice <> "" AND isnumber(eachLineRampPrice)){
					summedUpProdPriceArr[priceIndex] = summedUpProdPriceArr[priceIndex] + atof(eachLineRampPrice);
				}
				priceIndex = priceIndex + 1;
			}
		}
		if(rampValidationMessage == "") {
			index = 0;
			for summedUpIncrList in summedUpIncrListArr {
				rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
				incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
				put(floatDict, incrListLookUpKey, summedUpIncrList);
				index = index + 1;
			}
			
			index = 0;
			for summedUpProdPrice in summedUpProdPriceArr{
				rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
				prodPriceKey = rampKey + DELIMITER + PROD_ROLL;
				put(floatDict, prodPriceKey, summedUpProdPrice );
				index = index + 1;
			}
		}
		// Calculate Unified Net Prices
		// Get the model level discount
		/*discountLookupKey = currentDocNum + DELIMITER + DISCOUNT;
		if(containskey(floatDict, discountLookupKey)) {
			modelDisc = get(floatDict, discountLookupKey);
		}
		discTypeLookupKey = currentDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, discTypeLookupKey)) {
			modelDiscType = get(stringsDict, discTypeLookupKey);
		}*/
		//Base
		discountLookupKey = baseCoreDocNum + DELIMITER + DISCOUNT;
		totalDiscountAmount = 0.0;
		discountSaveKey = baseCoreDocNum + DELIMITER + DISCOUNT_AMOUNT;
		if(containskey(floatDict, discountLookupKey)) {
			disc = get(floatDict, discountLookupKey);
		}
		discTypeLookupKey = baseCoreDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, discTypeLookupKey)) {
			discType = get(stringsDict, discTypeLookupKey);
		}
		incrDiscountLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT;
		if(containskey(floatDict, incrDiscountLookupKey)) {
			incrDisc = get(floatDict, incrDiscountLookupKey);
		}
		incrDiscTypeLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, incrDiscTypeLookupKey)) {
			incrDiscType = get(stringsDict, incrDiscTypeLookupKey);
		}
		
		// Modified by Lawrence to add in promo
		baseNetPriceEa = 0.0;
		baseNetPriceExt = 0.0;
		if(discType == AMOUNT_DISCOUNT_TYPE) {
			baseNetPriceEa = baseUnifiedPrice - basePromo;
			promoUnifiedPriceExt = baseUnifiedPriceExt - extBasePromo;
			if(promoUnifiedPriceExt <> 0){
				baseNetPriceEa = baseNetPriceEa - ((disc/promoUnifiedPriceExt) * baseNetPriceEa);
			}
			
			baseNetPriceExt = promoUnifiedPriceExt - disc;
			totalDiscountAmount = disc;
		} else {
			baseNetPriceEa = baseUnifiedPrice - basePromo;
			baseNetPriceEa = baseNetPriceEa - (disc * baseNetPriceEa/100);
			promoUnifiedPriceExt = baseUnifiedPriceExt - extBasePromo;
			baseNetPriceExt = promoUnifiedPriceExt - (disc * promoUnifiedPriceExt/100);	
			totalDiscountAmount = (disc * promoUnifiedPriceExt/100);
		}
		
		
		put( floatDict, discountSaveKey, totalDiscountAmount);
		netPriceKey = baseCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
		put(floatDict, netPriceKey, baseNetPriceEa);
		extNetKey = baseCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
		put(floatDict, extNetKey, baseNetPriceExt);
		netPriceKey = baseCoreDocNum + DELIMITER + NET_EACH;
		put(floatDict, netPriceKey, baseNetPriceEa);
		extNetKey = baseCoreDocNum + DELIMITER + EXT_NET;
		put(floatDict, extNetKey, baseNetPriceExt);
		
		// Calculate Ramp Level Net prices
		if(rampValidationMessage == "") {
			index = 0;
			
			// This information is used to properly unify the incremental fees of non rampable base fees
			nonRampableIncKey = baseCoreDocNum + DELIMITER + NON_RAMPABLE_BASE_INCREMENTAL_STRING;
			nonRampableIncString = "";
			if ( containskey( stringsDict, nonRampableIncKey ) ){
				nonRampableIncString = get( stringsDict, nonRampableInckey );
			}
			nonRampableIncArr = split( nonRampableIncString, DELIMITER );
			nonRampableIncFloat = Float[];
			for nonRampableInc in nonRampableIncArr{
				if ( isnumber ( nonRampableInc ) ){
					append( nonRampableIncFloat, atof( nonRampableInc ) );
				}
				else{
					append( nonRampableIncFloat, 0.0 );
				}
			}
						
			for summedUpBaseList in summedUpBaseListArr {
				priceLookupKey = baseCoreDocNum + DELIMITER + EXT_LIST;
				nonRampableBaseKey = currentDocNum + DELIMITER + RAMP_PRICE_FOR_NON_RAMPABLE_BASE;
				rampPriceForNonRampableBase = 0.0;
				
				if ( containskey( floatDict, nonRampableBaseKey ) ){
					rampPriceForNonRampableBase = get( floatDict, nonRampableBaseKey );
				}
				rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
				extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
				incrNetLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_NET;
				summedUpTotal = rampPriceForNonRampableBase + summedUpBaseList;		
				
				//if ( containskey( floatDict, discountSaveKey ) ) {
				//	summedUpTotalDiscount = get( floatDict, discountSaveKey );
				
				//}		
				basePromoDiscPercentKey = baseCoreDocNum + DELIMITER + "promoDiscPercent_line";
				basePromoDiscPercent = 0.0;
				incrPromoDiscPercentKey = incrCoreDocNum + DELIMITER + "promoDiscPercent_line";
				incrPromoDiscPercent = 0.0;

				if (containskey(floatDict, basePromoDiscPercentKey)){
					basePromoDiscPercent = get(floatDict, basePromoDiscPercentKey);
				}
				if (containskey(floatDict, incrPromoDiscPercentKey)){
					incrPromoDiscPercent = get(floatDict, incrPromoDiscPercentKey);
				}
				
				extProdBasedPriceBaseKey = rampKey + DELIMITER + "extProductBasedPrice_line";
				extProdBasedPriceBase = 0.0;
				incrRampKey = incrCoreDocNum + RAMP_DELIMITER + string(index);
				prodBasedPriceIncrKey = incrRampKey + DELIMITER + "productBasedPrice_line";
				prodBasedPriceIncr = 0.0;
				if (containskey(floatDict, extProdBasedPriceBaseKey)){
					extProdBasedPriceBase = get(floatDict, extProdBasedPriceBaseKey);
				}
				if (containskey(floatDict, prodBasedPriceIncrKey)){
					prodBasedPriceIncr = get(floatDict, prodBasedPriceIncrKey);
				}

				if(discType == AMOUNT_DISCOUNT_TYPE) {
					summedUpBaseNet = summedUpTotal - disc;	
				} 
				else {
					//need to add in promo discount here
					promoAppliedPriceBase = extProdBasedPriceBase - (basePromoDiscPercent * extProdBasedPriceBase/100);
					summedUpPromoUnifiedPriceBase = (summedUpTotal - extProdBasedPriceBase) + promoAppliedPriceBase;
					summedUpBaseNet = summedUpPromoUnifiedPriceBase - (disc * summedUpPromoUnifiedPriceBase/100);
					promoUnifiedPriceExtTest = summedUpTotal - extBasePromo;
					baseNetPriceExtTest = promoUnifiedPriceExtTest - (disc * promoUnifiedPriceExtTest /100);
				}
				summedUpIncrTotal = summedUpIncrListArr[index] + nonRampableIncFloat[index];
				if(incrDiscType == AMOUNT_DISCOUNT_TYPE) {
					summedUpIncrNet = summedUpIncrTotal - incrDisc;
					
				} else {
					//summedUpIncrNet = summedUpIncrTotal - (incrDisc * summedUpIncrTotal/100);
					promoAppliedPriceIncr = prodBasedPriceIncr - (incrPromoDiscPercent * prodBasedPriceIncr/100);
					summedUpPromoUnifiedPriceIncr = (summedUpIncrTotal - prodBasedPriceIncr) + promoAppliedPriceIncr;
					summedUpIncrNet = summedUpPromoUnifiedPriceIncr - (incrDisc * summedUpPromoUnifiedPriceIncr/100);
				}
				
				//put(floatDict, extNetLookUpKey, summedUpBaseNet);
				//put(floatDict, incrNetLookUpKey, summedUpIncrNet);
				extNetUnifiedLookUpKey = rampKey + DELIMITER + EXT_NET_PRICE_UNIFIED;
				incrNetUnifiedLookUpKey = rampKey + DELIMITER + NET_PRICE_UNIFIED;
				baseListUnifiedLookUpKey = rampKey + DELIMITER + BASE_LIST_PRICE_UNIFIED;

				//CSYS-86113 (KA. 10-24-2017):
				userBaseFeeNetKey = rampKey + DELIMITER + "userBaseFeeNet";
				userIncFeeNetKey = rampKey + DELIMITER + "userIncFeeNet";
				systemBaseFeeNetKey = rampKey + DELIMITER + "systemBaseFeeNet";
				systemIncFeeNetKey = rampKey + DELIMITER + "systemIncFeeNet";
				systemIncFeeNetUSDKey = rampKey + DELIMITER + "systemIncFeeNetUSD";//CSYS-95310 
				regularDocNum = "";
				rampIndex = "";
				userEnteredBaseFlag = false;
				userEnteredIncFlag = false;
				if(find(rampKey, RAMP_DELIMITER) <> -1){
					rampIndexArr = split( rampKey, RAMP_DELIMITER );
     				rampIndex = rampIndexArr[1];
     			 	regularDocNum = rampIndexArr[0];
				}
				howManyRamps = util.getIntegerAttribute( integersDict, regularDocNum, DELIMITER, NUMBER_RAMP_ENTRIES );
				overrideRampPrice = "";
				if(containskey(stringsDict, baseCoreDocNum + DELIMITER + "overrideRampPrice")){
					overrideRampPrice = get(stringsDict, baseCoreDocNum + DELIMITER + "overrideRampPrice");
				}
				if(overrideRampPrice == TRUE_STR AND howManyRamps <> 0 AND rampIndex <> ""){
					//check if we're not dealing with the last ramp:
					if(isnumber(rampIndex) AND atoi(rampIndex) < howManyRamps - 1){
						if(containskey(floatDict, userBaseFeeNetKey)){
							//if user elected to overwrite the baseFeeNet:
							userBaseFeeNet = get(floatDict, userBaseFeeNetKey);
							//summedUpBaseNet = userBaseFeeNet;
							put(floatDict, extNetLookUpKey, userBaseFeeNet);
							put(floatDict, extNetUnifiedLookUpKey, userBaseFeeNet);
							userEnteredBaseFlag = true;
							if(find(rampKey, RAMP_DELIMITER) <> -1){
								put(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing", TRUE_STR);
							}
						}
						if(containskey(floatDict, userIncFeeNetKey)){
							//if user elected to overwrite the incrFeeNet:
							userIncFeeNet = get(floatDict, userIncFeeNetKey);
							//summedUpIncrNet = userIncFeeNet;
							put(floatDict, extNetLookUpKey, userIncFeeNet);
							put(floatDict, incrNetUnifiedLookUpKey, userIncFeeNet);
							userEnteredIncFlag = true;
							if(find(rampKey, RAMP_DELIMITER) <> -1){
								put(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing", TRUE_STR);
							}
						}
					}
				}

				if(NOT userEnteredBaseFlag){
					put(floatDict, extNetLookUpKey, summedUpBaseNet);
					put(floatDict, extNetUnifiedLookUpKey, summedUpBaseNet);
				}
				if(NOT userEnteredIncFlag){
					put(floatDict, incrNetLookUpKey, summedUpIncrNet);
					put(floatDict, incrNetUnifiedLookUpKey, summedUpIncrNet);
				}

				put(floatDict, systemBaseFeeNetKey, summedUpBaseNet);
				put(floatDict, systemIncFeeNetKey, summedUpIncrNet);
				put(floatDict, systemIncFeeNetUSDKey, summedUpIncrNet);//CSYS-95310 
				put(floatDict, baseListUnifiedLookupKey, summedUpTotal);
				index = index + 1;
			}
		}		
		// Setup
		discountLookupKey = setUpCoreDocNum + DELIMITER + DISCOUNT;
		totalDiscountAmount = 0.0;
		discountSaveKey = setUpCoreDocNum + DELIMITER + DISCOUNT_AMOUNT;
		if(containskey(floatDict, discountLookupKey)) {
			disc = get(floatDict, discountLookupKey);
		}
		discTypeLookupKey = setUpCoreDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, discTypeLookupKey)) {
			discType = get(stringsDict, discTypeLookupKey);
		}
		// Lawrence : Promo modifications
		setUpNetPriceEa = 0.0;
		setUpNetPriceExt = 0.0;
		if(discType == AMOUNT_DISCOUNT_TYPE) {
			setUpNetPriceEa = setUpUnifiedPrice - setupPromo;
			promoUnifiedPriceExt = setUpUnifiedPriceExt - extSetupPromo;
			if(promoUnifiedPriceExt <> 0){
				setUpNetPriceEa = setUpNetPriceEa - ((disc/promoUnifiedPriceExt) * setUpNetPriceEa);
			}

			setUpNetPriceExt = promoUnifiedPriceExt - disc;
			totalDiscountAmount = disc;
		} else {
		promoUnifiedPriceExt = setUpUnifiedPriceExt - extSetupPromo;
			setUpNetPriceEa = setUpUnifiedPrice - setupPromo;
			setUpNetPriceEa = setUpNetPriceEa - (disc * setUpNetPriceEa/100);
			setUpNetPriceExt = promoUnifiedPriceExt - (disc * promoUnifiedPriceExt/100);
			totalDiscountAmount = (disc * promoUnifiedPriceExt/100);
		}
		put( floatDict, discountSaveKey, totalDiscountAmount);
		netPriceKey = setUpCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
		put(floatDict, netPriceKey, setUpNetPriceEa);
		extNetKey = setUpCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
		put(floatDict, extNetKey, setUpNetPriceExt);
		netPriceKey = setUpCoreDocNum + DELIMITER + NET_EACH;
		put(floatDict, netPriceKey, setUpNetPriceEa);
		extNetKey = setUpCoreDocNum + DELIMITER + EXT_NET;
		put(floatDict, extNetKey, setUpNetPriceExt);
		// Incremental
		discountLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT;
		totalDiscountAmount = 0.0;
		discountSaveKey = incrCoreDocNum + DELIMITER + DISCOUNT_AMOUNT;
		if(containskey(floatDict, discountLookupKey)) {
			disc = get(floatDict, discountLookupKey);
		}
		discTypeLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, discTypeLookupKey)) {
			discType = get(stringsDict, discTypeLookupKey);
		}
		// Lawrence : Promo Modifications
		incrNetPriceEa = 0.0;
		incrNetPriceExt = 0.0;
		if(discType == AMOUNT_DISCOUNT_TYPE) {
			incrNetPriceEa = incrUnifiedPrice - incrPromo;
			promoUnifiedPriceExt = incrUnifiedPriceExt - extIncrPromo;
			if(promoUnifiedPriceExt <> 0){
				incrNetPriceEa = incrNetPriceEa - ((disc/promoUnifiedPriceExt) * incrNetPriceEa);
			}

			incrNetPriceExt = promoUnifiedPriceExt - disc;
			totalDiscountAmount = disc;
		} else {
			incrNetPriceEa = incrUnifiedPrice - incrPromo;
			promoUnifiedPriceExt = incrUnifiedPriceExt - extIncrPromo;
			incrNetPriceEa = incrNetPriceEa - (disc * incrNetPriceEa/100);
			incrNetPriceExt = promoUnifiedPriceExt - (disc * promoUnifiedPriceExt/100);
			totalDiscountAmount = (disc * promoUnifiedPriceExt/100);
		}
		put( floatDict, discountSaveKey, totalDiscountAmount);
		netPriceKey = incrCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
		put(floatDict, netPriceKey, incrNetPriceEa);
		extNetKey = incrCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
		put(floatDict, extNetKey, incrNetPriceExt);
		netPriceKey = incrCoreDocNum + DELIMITER + NET_EACH;
		put(floatDict, netPriceKey, incrNetPriceEa);
		extNetKey = incrCoreDocNum + DELIMITER + EXT_NET;
		put(floatDict, extNetKey, incrNetPriceExt);
		// Pre Prod
		discountLookupKey = preProdCoreDocNum + DELIMITER + DISCOUNT;
		totalDiscountAmount = 0.0;
		discountSaveKey = preProdCoreDocNum + DELIMITER + DISCOUNT_AMOUNT;
		if(containskey(floatDict, discountLookupKey)) {
			disc = get(floatDict, discountLookupKey);
		}
		discTypeLookupKey = preProdCoreDocNum + DELIMITER + DISCOUNT_TYPE;
		if(containskey(stringsDict, discTypeLookupKey)) {
			discType = get(stringsDict, discTypeLookupKey);
		}
		
		preProdNetPriceEa = 0.0;
		preProdNetPriceExt = 0.0;
		if(discType == AMOUNT_DISCOUNT_TYPE) {
			preProdNetPriceEa = preProdUnifiedPrice - preProdPromo;
			promoUnifiedPriceExt = preProdUnifiedPriceExt - extPreProdPromo;
			if(promoUnifiedPriceExt <> 0){
				preProdNetPriceEa = preProdNetPriceEa - ((disc/promoUnifiedPriceExt) * preProdNetPriceEa);
			}

			preProdNetPriceExt = promoUnifiedPriceExt - disc;
			totalDiscountAmount = disc;
		} else {
			preProdNetPriceEa = preProdUnifiedPrice - preProdPromo;
			promoUnifiedPriceExt = preProdUnifiedPriceExt - extPreProdPromo;
			preProdNetPriceEa = preProdNetPriceEa - (disc * preProdNetPriceEa/100);
			preProdNetPriceExt = promoUnifiedPriceExt - (disc * promoUnifiedPriceExt/100);
			totalDiscountAmount = (disc * promoUnifiedPriceExt/100);
		}
		put( floatDict, discountSaveKey, totalDiscountAmount);
		netPriceKey = preProdCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
		put(floatDict, netPriceKey, preProdNetPriceEa);
		extNetKey = preProdCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
		put(floatDict, extNetKey, preProdNetPriceExt);
		netPriceKey = preProdCoreDocNum + DELIMITER + NET_EACH;
		put(floatDict, netPriceKey, preProdNetPriceEa);
		extNetKey = preProdCoreDocNum + DELIMITER + EXT_NET;
		put(floatDict, extNetKey, preProdNetPriceExt);
		result = true;
	} 
}

// If there is no entry in the "unifiedPricing" datatable

if(NOT(result)) { 
	baseUnifiedPrice = 0.0;
	setUpUnifiedPrice = 0.0;
	incrUnifiedPrice = 0.0;
	preProdUnifiedPrice = 0.0;
	baseUnifiedPriceExt = 0.0;
	setUpUnifiedPriceExt = 0.0;
	incrUnifiedPriceExt = 0.0;
	preProdUnifiedPriceExt = 0.0;
	baseCoreDocNum = "";
	setUpCoreDocNum = "";
	incrCoreDocNum = "";
	preProdCoreDocNum = "";
	baseUnifiedDocNum = "";
	setUpUnifiedDocNum = "";
	incrUnifiedDocNum = "";
	preProdUnifiedDocNum = "";
	disc = 0.0;
	discType = "";
	incrDisc = 0.0;
	incrDiscType = "";
	modelDisc = 0.0;
	modelDiscType = "";
	numTrxns = 0;
	baseListArr = string[];
	summedUpBaseListArr = float[];
	summedUpBaseListCountArr = integer[];
	incrListArr = string[];
	summedUpIncrListArr = float[];
	summedUpIncrListCountArr = integer[];
	for childNum in childNumArr {
		childPO = "";
		childPOCat = "";
		childItemType = "";
		childRollUp = "";
		childNumOfRamps = 0;
		if(containskey(docNumPODict, childNum)) {
			childPO = get(docNumPODict, childNum);
		}
		if(containskey(docNumItemTypeDict, childNum)) {
			childItemType = get(docNumItemTypeDict, childNum);
		}
		if(containskey(docNumRollUpDict, childNum)) {
			childRollUp = get(docNumRollUpDict, childNum);
		}
		if(containskey(docNumPOCatDict, childNum)) {
			childPOCat = get(docNumPOCatDict, childNum);
		}
		if(containskey(docNumNumOfRampsDict, childNum)) {
			childNumOfRamps = get(docNumNumOfRampsDict, childNum);
		}
		rampsArr = range(childNumOfRamps);
		if(childPOCat == CORE_SERVICE_CATEGORY AND childItemType == BASE_FEE AND childRollUp == "Y") {
			baseCoreDocNum = childNum;
			priceLookupKey = baseCoreDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = baseCoreDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
			if(rampValidationMessage == "") {
				index = 0;
				listPriceStr = "";
				incrListPriceStr = "";
				summedUpBaseListCountArr = range(childNumOfRamps); // Set the size here
				summedUpIncrListCountArr = range(childNumOfRamps); // Set the size here
				for ramp in rampsArr {
					rampKey = childNum + RAMP_DELIMITER + string(index);
					extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
					incrListLookUpKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
					if(containskey(floatDict, extListLookUpKey)) {
						listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey)) + PRICE_DELIMITER; 
					}
					if(containskey(floatDict, incrListLookUpKey)) {
						incrListPriceStr = incrListPriceStr + string(get(floatDict, incrListLookUpKey)) + PRICE_DELIMITER; 
					}
					index = index + 1;
				}
				append(baseListArr, listPriceStr);
				append(incrListArr, incrListPriceStr);
			}
		} elif(((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <> CORE_SERVICE_CATEGORY)) AND childItemType == BASE_FEE) {
			baseUnifiedDocNum = childNum;
			priceLookupKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				baseUnifiedPrice = baseUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				baseUnifiedPriceExt = baseUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
			// Zero out the prices of the unified PI if there is a core PI to roll the prices to.
			if(baseCoreDocNum <> "") {
				listPriceKey = baseUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = baseUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}
			if(rampValidationMessage == "") {
				index = 0;
				listPriceStr = "";
				for ramp in rampsArr {
					rampKey = childNum + RAMP_DELIMITER + string(index);
					extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
					extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
					incrListLookUpKey = rampKey + DELIMITER + LIST_PRICE;
					if(containskey(floatDict, extListLookUpKey)) {
						listPriceStr = listPriceStr + string(get(floatDict, extListLookUpKey) )+ PRICE_DELIMITER; 
					}
					if(containskey(floatDict, incrListLookUpKey)) {
						listPriceStr = listPriceStr + string(get(floatDict, incrListLookUpKey) )+ PRICE_DELIMITER; 
					}
					// Zero out the prices for non Core
					put(floatDict, extListLookUpKey, 0.0);
					put(floatDict, extNetLookUpKey, 0.0);
					incrListKey = rampKey + DELIMITER + INCREMENTAL_FEE_LIST;
					incrNetKey = rampKey + DELIMITER + INCREMENTAL_FEE_NET;
					put(floatDict, incrListKey, 0.0);
					put(floatDict, incrNetKey, 0.0);
					index = index + 1;
				}
				append(baseListArr, listPriceStr);
			}
		} elif(childPOCat == CORE_SERVICE_CATEGORY AND childItemType == SETUP_FEE AND childRollUp == "Y") {
			setUpCoreDocNum = childNum;
			priceLookupKey = setUpCoreDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = setUpCoreDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
		} elif(((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <>CORE_SERVICE_CATEGORY)) AND childItemType == SETUP_FEE) {
			setUpUnifiedDocNum = childNum;
			priceLookupKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				setUpUnifiedPrice = setUpUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				setUpUnifiedPriceExt = setUpUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
			// Zero out the prices of the unified PI if there is a core PI to roll the prices to.
			if(setUpCoreDocNum <> "") {
				listPriceKey = setUpUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = setUpUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}
		} elif(childPOCat == CORE_SERVICE_CATEGORY AND childItemType == INCR_FEE AND childRollUp == "Y") {
			incrCoreDocNum = childNum;
			priceLookupKey = incrCoreDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
				
			}
			priceLookupKey = incrCoreDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
		} elif(((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <>CORE_SERVICE_CATEGORY)) AND childItemType == INCR_FEE) {
			incrUnifiedDocNum = childNum;
			priceLookupKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				incrUnifiedPrice = incrUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				incrUnifiedPriceExt = incrUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
			// Zero out the prices of the unified PI if there is a core PI to roll the prices to.
			if(incrCoreDocNum <> "") {
				listPriceKey = incrUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = incrUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}
		} elif(childPOCat == CORE_SERVICE_CATEGORY AND childItemType == PRE_PROD AND childRollUp == "Y") {
			preProdCoreDocNum = childNum;
			priceLookupKey = preProdCoreDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = preProdCoreDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
		} elif(((childPOCat == CORE_SERVICE_CATEGORY AND childRollUp == "N") OR (childPOCat <>CORE_SERVICE_CATEGORY)) AND childItemType == PRE_PROD) {
			preProdUnifiedDocNum = childNum;
			priceLookupKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
			if (containskey(floatDict, priceLookupKey)) {			
				preProdUnifiedPrice = preProdUnifiedPrice + get(floatDict, priceLookupKey);
			}
			priceLookupKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
			if (containskey(floatDict, priceLookupKey)) {			
				preProdUnifiedPriceExt = preProdUnifiedPriceExt + get(floatDict, priceLookupKey);
			}
			// Zero out the prices of the unified PI if there is a core PI to roll the prices to.
			if(preProdCoreDocNum <> "") {
				listPriceKey = preProdUnifiedDocNum + DELIMITER + LIST_PRICE;
				put(floatDict, listPriceKey, 0.0);
				listPriceKey = preProdUnifiedDocNum + DELIMITER + EXT_LIST;
				put(floatDict, listPriceKey, 0.0);
			}
		}
	}
	// Assign the unified price to the list price of the line item corresponding to the coreDocNum
	listPriceKey = baseCoreDocNum + DELIMITER + LIST_PRICE;
	put(floatDict, listPriceKey, baseUnifiedPrice);
	listPriceKey = setUpCoreDocNum + DELIMITER + LIST_PRICE;
	put(floatDict, listPriceKey, setUpUnifiedPrice);
	listPriceKey = incrCoreDocNum + DELIMITER + LIST_PRICE;
	put(floatDict, listPriceKey, incrUnifiedPrice);
	listPriceKey = preProdCoreDocNum + DELIMITER + LIST_PRICE;
	put(floatDict, listPriceKey, preProdUnifiedPrice);
		
	listPriceKey = baseCoreDocNum + DELIMITER + EXT_LIST;
	put(floatDict, listPriceKey, baseUnifiedPriceExt);
	listPriceKey = setUpCoreDocNum + DELIMITER + EXT_LIST;
	put(floatDict, listPriceKey, setUpUnifiedPriceExt);
	listPriceKey = incrCoreDocNum + DELIMITER + EXT_LIST;
	put(floatDict, listPriceKey, incrUnifiedPriceExt);
	listPriceKey = preProdCoreDocNum + DELIMITER + EXT_LIST;
	put(floatDict, listPriceKey, preProdUnifiedPriceExt);	
	// Initialize the summedUpList Array here
	for baseList in summedUpBaseListCountArr {
		append(summedUpBaseListArr, 0.0);
	}
		
	// Calculate Ramp level list prices
	for priceStr in baseListArr {
		eachLineRampPriceArr = split(priceStr, PRICE_DELIMITER);
		priceIndex = 0;
		for eachLineRampPrice in eachLineRampPriceArr {
			if(eachLineRampPrice <> "" AND isnumber(eachLineRampPrice)) {
				summedUpBaseListArr[priceIndex] = summedUpBaseListArr[priceIndex] + atof(eachLineRampPrice);
			}
				priceIndex = priceIndex + 1;
		}
	}
	if(rampValidationMessage == "") {
		index = 0;
		for summedUpBaseList in summedUpBaseListArr {
			rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
			extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
			put(floatDict, extListLookUpKey, summedUpBaseList);
			index = index + 1;
		}
	}	
	
	for priceStr in incrListArr {
		eachLineRampPriceArr = split(priceStr, PRICE_DELIMITER);
		priceIndex = 0;
		for eachLineRampPrice in eachLineRampPriceArr {
			if(eachLineRampPrice <> "" AND isnumber(eachLineRampPrice)) {
				summedUpIncrListArr[priceIndex] = summedUpIncrListArr[priceIndex] + atof(eachLineRampPrice);
			}
				priceIndex = priceIndex + 1;
		}
	}
	if(rampValidationMessage == "") {
		index = 0;
		for summedUpIncrList in summedUpIncrListArr {
			rampKey = incrCoreDocNum + RAMP_DELIMITER + string(index);
			extListLookUpKey = rampKey + DELIMITER + EXT_LIST;
			put(floatDict, extListLookUpKey, summedUpIncrList);
			index = index + 1;
		}
	}	
	// Calculate Unified Net Prices
	//Base
	discountLookupKey = baseCoreDocNum + DELIMITER + DISCOUNT;
	if(containskey(floatDict, discountLookupKey)) {
		disc = get(floatDict, discountLookupKey);
	}
	discTypeLookupKey = baseCoreDocNum + DELIMITER + DISCOUNT_TYPE;
	if(containskey(stringsDict, discTypeLookupKey)) {
		discType = get(stringsDict, discTypeLookupKey);
	}
	if(discType == AMOUNT_DISCOUNT_TYPE) {
		baseNetPriceEa = baseUnifiedPrice;
		if(baseUnifiedPriceExt <> 0){
			baseNetPriceEa = baseUnifiedPrice - ((disc/baseUnifiedPriceExt) * baseUnifiedPrice);
		}
		baseNetPriceExt = baseUnifiedPriceExt - disc;
	} else {
		baseNetPriceEa = baseUnifiedPrice - (disc * baseUnifiedPrice/100);
		baseNetPriceExt = baseUnifiedPriceExt - (disc * baseUnifiedPriceExt/100);
	}
	incrDiscountLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT;
	if(containskey(floatDict, incrDiscountLookupKey)) {
		incrDisc = get(floatDict, incrDiscountLookupKey);
	}
	incrDiscTypeLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT_TYPE;
	if(containskey(stringsDict, incrDiscTypeLookupKey)) {
		incrDiscType = get(stringsDict, incrDiscTypeLookupKey);
	}
	netPriceKey = baseCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
	put(floatDict, netPriceKey, baseNetPriceEa);
	extNetKey = baseCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
	put(floatDict, extNetKey, baseNetPriceExt);
	netPriceKey = baseCoreDocNum + DELIMITER + NET_EACH;
	put(floatDict, netPriceKey, baseNetPriceEa);
	extNetKey = baseCoreDocNum + DELIMITER + EXT_NET;
	put(floatDict, extNetKey, baseNetPriceExt);
	// Calculate Ramp Level Net prices
	if(rampValidationMessage == "") {
		index = 0;
		for summedUpBaseList in summedUpBaseListArr {
			rampKey = baseCoreDocNum + RAMP_DELIMITER + string(index);
			extNetLookUpKey = rampKey + DELIMITER + EXT_NET;
			if(discType == AMOUNT_DISCOUNT_TYPE) {
				summedUpBaseNet = summedUpBaseList - disc;
			} else {
				summedUpBaseNet = summedUpBaseList - (disc * summedUpBaseList/100);
			}
			if(incrDiscType == AMOUNT_DISCOUNT_TYPE) {
				summedUpIncrNet = summedUpIncrListArr[index] - incrDisc;
			} else {
				summedUpIncrNet = summedUpIncrListArr[index] - (incrDisc * summedUpIncrListArr[index]/100);
			}
			put(floatDict, extNetLookUpKey, summedUpBaseNet);
			put(floatDict, extNetLookUpKey, summedUpIncrNet);
			index = index + 1;
		}
	}
	// Setup
	discountLookupKey = setUpCoreDocNum + DELIMITER + DISCOUNT;
	if(containskey(floatDict, discountLookupKey)) {
		disc = get(floatDict, discountLookupKey);
	}
	discTypeLookupKey = setUpCoreDocNum + DELIMITER + DISCOUNT_TYPE;
	if(containskey(stringsDict, discTypeLookupKey)) {
		discType = get(stringsDict, discTypeLookupKey);
	}
	if(discType == AMOUNT_DISCOUNT_TYPE) {
		setUpNetPriceEa = setUpUnifiedPrice;
		if(setUpUnifiedPriceExt <> 0){
			setUpNetPriceEa = setUpUnifiedPrice - ((disc/setUpUnifiedPriceExt) * setUpUnifiedPrice);
		}
		setUpNetPriceExt = setUpUnifiedPriceExt - disc;
	} else {
		setUpNetPriceEa = setUpUnifiedPrice - (disc * setUpUnifiedPrice/100);
		setUpNetPriceExt = setUpUnifiedPriceExt - (disc * setUpUnifiedPriceExt/100);
	}
	netPriceKey = setUpCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
	put(floatDict, netPriceKey, setUpNetPriceEa);
	extNetKey = setUpCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
	put(floatDict, extNetKey, setUpNetPriceExt);
	netPriceKey = setUpCoreDocNum + DELIMITER + NET_EACH;
	put(floatDict, netPriceKey, setUpNetPriceEa);
	extNetKey = setUpCoreDocNum + DELIMITER + EXT_NET;
	put(floatDict, extNetKey, setUpNetPriceExt);
	// Incremental
	discountLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT;
	if(containskey(floatDict, discountLookupKey)) {
		disc = get(floatDict, discountLookupKey);
	}
	discTypeLookupKey = incrCoreDocNum + DELIMITER + DISCOUNT_TYPE;
	if(containskey(stringsDict, discTypeLookupKey)) {
		discType = get(stringsDict, discTypeLookupKey);
	}
	if(discType == AMOUNT_DISCOUNT_TYPE) {
		incrNetPriceEa = incrUnifiedPrice;
		if(incrUnifiedPriceExt <> 0){
			incrNetPriceEa = incrUnifiedPrice - ((disc/incrUnifiedPriceExt) * incrUnifiedPrice);
		}
		incrNetPriceExt = incrUnifiedPriceExt - disc;
	} else {
		incrNetPriceEa = incrUnifiedPrice - (disc * incrUnifiedPrice/100);
		incrNetPriceExt = incrUnifiedPriceExt - (disc * incrUnifiedPriceExt/100);
	}
	netPriceKey = incrCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
	put(floatDict, netPriceKey, incrNetPriceEa);
	extNetKey = incrCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
	put(floatDict, extNetKey, incrNetPriceExt);
	netPriceKey = incrCoreDocNum + DELIMITER + NET_EACH;
	put(floatDict, netPriceKey, incrNetPriceEa);
	extNetKey = incrCoreDocNum + DELIMITER + EXT_NET;
	put(floatDict, extNetKey, incrNetPriceExt);
	// Pre Prod
	discountLookupKey = preProdCoreDocNum + DELIMITER + DISCOUNT;
	if(containskey(floatDict, discountLookupKey)) {
		disc = get(floatDict, discountLookupKey);
	}
	discTypeLookupKey = preProdCoreDocNum + DELIMITER + DISCOUNT_TYPE;
	if(containskey(stringsDict, discTypeLookupKey)) {
		discType = get(stringsDict, discTypeLookupKey);
	}
	preProdNetPriceEa = 0.0;
	if(discType == AMOUNT_DISCOUNT_TYPE) {
		preProdNetPriceEa = preProdUnifiedPrice;
		if(preProdUnifiedPriceExt <> 0){
			preProdNetPriceEa = preProdUnifiedPrice - ((disc/preProdUnifiedPriceExt) * preProdUnifiedPrice);
		}
		preProdNetPriceExt = preProdUnifiedPriceExt - disc;
	} else {
		preProdNetPriceEa = preProdUnifiedPrice - (disc * preProdUnifiedPrice/100);
		preProdNetPriceExt = preProdUnifiedPriceExt - (disc * preProdUnifiedPriceExt/100);
	}
	netPriceKey = preProdCoreDocNum + DELIMITER + NET_PRICE_UNIFIED;
	put(floatDict, netPriceKey, preProdNetPriceEa);
	extNetKey = preProdCoreDocNum + DELIMITER + EXT_NET_PRICE_UNIFIED;
	put(floatDict, extNetKey, preProdNetPriceExt);
	netPriceKey = preProdCoreDocNum + DELIMITER + NET_EACH;
	put(floatDict, netPriceKey, preProdNetPriceEa);
	extNetKey = preProdCoreDocNum + DELIMITER + EXT_NET;
	put(floatDict, extNetKey, preProdNetPriceExt);
}
put(stringsDict, "1" + DELIMITER + RAMP_MESSAGE, rampValidationMessage);
return result;]]></script_text><_children><bm_lib_func_assoc><id>446107469</id><caller_func_id>5190926</caller_func_id><called_lib_func_id>4906069</called_lib_func_id><rule_area><![CDATA[calculateUnifiedPricing]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1626948716000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[ad7b161a-5c01-4876-8ad0-4a2b12db2704]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>5190929</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[unifiedPricingDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1626948716000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_unifiedPricingDataDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190930</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[unifiedPricingDataRowCount]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1626948716000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_unifiedPricingDataRowCount_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190931</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[docToChildNumListDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1626948716000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_docToChildNumListDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190932</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[currentDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948716000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_currentDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190933</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948716000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190934</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1626948716000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5190935</id><bm_lib_func_id>5190927</bm_lib_func_id><param_name><![CDATA[floatDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1626948716000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_calculateUnifiedPricing.bm_lib_func_param_floatDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839292</id><name><![CDATA[getBillingCycleNumber]]></name><variable_name><![CDATA[getBillingCycleNumber]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>989839291</function_id><date_modified>1599705696000</date_modified><guid><![CDATA[bm_lib_func_util_getBillingCycleNumber]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839291</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getBillingCycleNumber_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705697000</date_modified><guid><![CDATA[3daa2548-487d-42d5-9e86-646849384bc0]]></guid><script_size>175</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getBillingCycleNumber
billingCycle - String
*/
miscDataSet = bmql("SELECT miscDataKey FROM miscCommerceData WHERE miscDataVal = $billingCycle" );
billingCycleNumber = "";
for dataValue in miscDataSet{
    billingCycleNumber = get( dataValue, "miscDataKey" );
}
return billingCycleNumber;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839293</id><bm_lib_func_id>989839292</bm_lib_func_id><param_name><![CDATA[billingCycle]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1599705696000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getBillingCycleNumber.bm_lib_func_param_billingCycle_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4904460</id><name><![CDATA[getPriceList]]></name><variable_name><![CDATA[getPriceList]]></variable_name><description><![CDATA[Returns a dictionary containing the price list for the current companyName, businessUnit and currencyCode. The returned dictionary also contains any error messages.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4904459</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getPriceList]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4904459</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPriceList_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435917000</date_modified><guid><![CDATA[LEGACY_4904459]]></guid><script_size>502</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[errorMsg = "";
priceList = "";
priceListDict = dict("string");

internalCount = 0;
records = bmql("select priceList from companyToPriceList where companyName = $companyName and businessUnit = $businessUnit and currencyCode = $currencyCode");

for record in records {
	priceList = get(record, "priceList");
	internalCount = internalCount + 1;
}

if (internalCount < 1) {
	priceList = "";
	errorMsg = "No price lists found for companyName: " + companyName + ", businessUnit: " + businessUnit + " and currencyCode: " + currencyCode;
} elif (internalCount > 1) {
	priceList = "";
	errorMsg = "Multiple price lists found for companyName: " + companyName + ", businessUnit: " + businessUnit + " and currencyCode: " + currencyCode;
}

put(priceListDict, "pricelist", priceList);
put(priceListDict, "error", errorMsg);

return priceListDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4904462</id><bm_lib_func_id>4904460</bm_lib_func_id><param_name><![CDATA[companyName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getPriceList.bm_lib_func_param_companyName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904463</id><bm_lib_func_id>4904460</bm_lib_func_id><param_name><![CDATA[businessUnit]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getPriceList.bm_lib_func_param_businessUnit_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4904464</id><bm_lib_func_id>4904460</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getPriceList.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839285</id><name><![CDATA[getInitialRampTransactionsForAO]]></name><variable_name><![CDATA[getInitialRampTransactionsForAO]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>989839284</function_id><date_modified>1599705696000</date_modified><guid><![CDATA[bm_lib_func_util_getInitialRampTransactionsForAO]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839284</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getInitialRampTransactionsForAO_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705696000</date_modified><guid><![CDATA[b9a8cc35-c2cb-441f-b894-979c3dbf4e66]]></guid><script_size>620</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getInitialRampTransactionsForAO
assetsInfo - String
*/
//Logic borrowed from addOnPopulation script to grab the first core base transactions from the asset string
quoteRampTrxn = string[];
corePis = string[];
ASSET_DELIMITER = "@@";
INTERNAL_DELIMITER = "$$";
BASE_FEE = "Base";

corePIset = bmql("SELECT PI FROM PiToCoreOfferingMap");
for entry in corePIset {
	tablePi = get(entry, "PI");
	append(corePis, tablePi);
}

//capture correct transactions to assign to quote ramp transactions:
firstCoreBaseAssetTrans = 0;
comment = split(assetsInfo, ASSET_DELIMITER);
count = 0;
for eachindex in comment {
	assetArray = split(comment[count],INTERNAL_DELIMITER);
	if(NOT isnull(assetArray[7]) AND assetArray[4] == BASE_FEE AND findinarray(corePis, assetArray[0]) <> -1){
		firstCoreBaseAssetTrans = util.customAtof(assetArray[7], 0.0);
		orgQuoteTransactions = string(integer(firstCoreBaseAssetTrans));
		quoteRampTrxn = string[]{orgQuoteTransactions};
		break;
	}
	count = count + 1;
}
return quoteRampTrxn;]]></script_text><_children><bm_lib_func_assoc><id>989839287</id><caller_func_id>989839284</caller_func_id><called_lib_func_id>4814698</called_lib_func_id><rule_area><![CDATA[getInitialRampTransactionsForAO]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1599705696000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[65ee2a79-e7ba-492e-a62b-d8785a193f27]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>989839286</id><bm_lib_func_id>989839285</bm_lib_func_id><param_name><![CDATA[assetsInfo]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1599705696000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getInitialRampTransactionsForAO.bm_lib_func_param_assetsInfo_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>989839279</id><name><![CDATA[getQuoteRampPlanTrxnRatios]]></name><variable_name><![CDATA[getQuoteRampPlanTrxnRatios]]></variable_name><description></description><return_type>9</return_type><func_type>1</func_type><function_id>989839278</function_id><date_modified>1599705694000</date_modified><guid><![CDATA[bm_lib_func_util_getQuoteRampPlanTrxnRatios]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>989839278</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getQuoteRampPlanTrxnRatios_1]]></java_class_name><child_class_names></child_class_names><date_modified>1599705694000</date_modified><guid><![CDATA[4f3eaeb1-928a-4a2b-8f05-f9acd16d9fb6]]></guid><script_size>536</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getQuoteRampPlanTrxnRatios
trxnArray - string[]
*/
transactionValues = integer[];
quoteRampPlanTrxnRatios = float[];
maxValue = -1;


for transactionString in trxnArray {
    if (isnumber(transactionString)) {
        transactionValue = integer(atof(transactionString));    //Immediately casting something like 100.23 with atoi() will throw an error. Casting a float will truncate the decimal.

        if (transactionValue > maxValue) {
            maxValue = transactionValue;
        }
        append(transactionValues, transactionValue);    //This will be an integer array, e.g. [100, 200, 300, 400, 500]
    }
}

index = 1;
for transactionVal in transactionValues {

    ratio = index / sizeofarray(transactionValues) * 1.0;   //If maxValue is not greater than zero, just default this to be proportional to the ramp level
    if (maxValue > 0 AND quoteTrxns > 0) {
        ratio = transactionVal / (quoteTrxns * 1.0);
    }
    else{
        ratio = 1.0;
    }

    append(quoteRampPlanTrxnRatios, ratio);
    index = index + 1;
}

return quoteRampPlanTrxnRatios;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>989839280</id><bm_lib_func_id>989839279</bm_lib_func_id><param_name><![CDATA[trxnArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1599705694000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getQuoteRampPlanTrxnRatios.bm_lib_func_param_trxnArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>989839281</id><bm_lib_func_id>989839279</bm_lib_func_id><param_name><![CDATA[quoteTrxns]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1599705694000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getQuoteRampPlanTrxnRatios.bm_lib_func_param_quoteTrxns_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>126181591</id><name><![CDATA[x- Systematized Terminations]]></name><variable_name><![CDATA[systematizedTerminations]]></variable_name><description><![CDATA[MOVED TO COMMERCE LIBRARY.

Per CSYS-40346, this util sets the attribute terminatedCoreMapping_line for use by the Document Engine, in order to systematize product terminations. Also, it builds out termination notes for the opportunity.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>126181590</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_systematizedTerminations]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>126181590</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_systematizedTerminations_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435936000</date_modified><guid><![CDATA[2f4bff1b-27ee-4f1b-bb49-f10c180f193d]]></guid><script_size>4918</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// Moved to commerce library -- ATG on 03/08/16
//SYSTEMATIZED CONTRACTS PHASE 5 UTIL LIBRARY
/*****ALLOW CONTRACTS TO BE SYSTEMATIZED IF THERE ARE TERMINATED LINE ITEMS*****/
//This library:
//1. Feeds the appropriate attribute mapping to the document engine to generate the correct SOF verbage
//2. Builds out Termination Notes to be sent back to the opportunity

DOCNUM_DELIM = "$*$";
QUOTE_DOCNUM = "1";
TRUE_STR = "true";
FALSE_STR = "false";
BASE_FEE = "Base";
CORE_SERVICE = "Core Service";
EXTENDED_SERVICE = "Extended Service";
NONE_ACTION = "NONE";
MODIFY_ACTION = "MODIFY";
CREATE_ACTION = "CREATE";
TERMINATE_ACTION = "TERMINATE";
BLANK = "";
TERMINATED_CORE_MAPPING = "terminatedCoreMapping_line";
terminationNotes = "";

coreTerminatesDict = dict("string"); //for CSYS-40346 part 1
terminateCoreDescDict = dict("string"); //for CSYS-40346 part 1
coreCreatesDict = dict("string"); //for CSYS-40346 part 1
coreNonePlusModifyDict = dict("string"); //for CSYS-46907 part 1

familyNoneModifyDict = dict("string");
familyCreateDict = dict("string");
familyTerminateDict = dict("string");

hasTripLinkCore = false;
hasRiskMessagingCore = false;
expenseCreated = false;
teTerminated = false;
teToExpense = false;

for key in seqNumArray { //loop to map terminate and create related components to each model
	seqNumber = string(key);
	docNum = get(seqNumAttributeMappingDict, seqNumber);
	parentDocNum = get(primeStringsDict, docNum + DOCNUM_DELIM + "_parent_doc_number");
	
	poCategory = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field20");
	assetAction = get(primeStringsDict, docNum + DOCNUM_DELIM + "assetAction_line");
	familyName = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field23");
	lineDesc = get(primeStringsDict, docNum + DOCNUM_DELIM + "lineDescription_line");
	isCoreChanged = get(isCoreChangedDict, parentDocNum);
	isEditionChanged = get(isEditionChangedDict, parentDocNum);
	
	if (poCategory == CORE_SERVICE AND assetAction == TERMINATE_ACTION AND (isCoreChanged == TRUE_STR OR isEditionChanged == TRUE_STR)){
		put(coreTerminatesDict, parentDocNum, TERMINATE_ACTION); //core has TERMINATE's and CREATE's. original core is getting replaced with another since there's a core/edition change.
		put(terminateCoreDescDict, parentDocNum, lineDesc);
	}
	if (poCategory == CORE_SERVICE AND assetAction == CREATE_ACTION){
		put(coreCreatesDict, parentDocNum, CREATE_ACTION); //core has CREATE's
	}
	if (poCategory == CORE_SERVICE AND (assetAction == NONE_ACTION OR assetAction == MODIFY_ACTION)){ //CSYS-46907 part 2
		put(coreNonePlusModifyDict, parentDocNum, NONE_ACTION); //core has NONE/MODIFY lines, obviously no terminated lines
	}
	if (isnull(get(coreTerminatesDict, parentDocNum))){
		put(coreTerminatesDict, parentDocNum, "BLANK");
	}
	if (isnull(get(terminateCoreDescDict, parentDocNum))){
		put(terminateCoreDescDict, parentDocNum, "BLANK");
	}
	
	//for SC P5 Step 7:
	if (assetAction == NONE_ACTION OR assetAction == MODIFY_ACTION){ //if we run into a NONE or MODIFY line
		put(familyNoneModifyDict, familyName, assetAction); //family has NONEs
	}
	
	if (assetAction == CREATE_ACTION){ //if we run into a CREATE line
		put(familyCreateDict, familyName, assetAction); //family has CREATEs
	}
	
	if (assetAction == TERMINATE_ACTION){ //if we run into a TERMINATE line
		put(familyTerminateDict, familyName, assetAction); //Family has TERMINATEs
	}
	
	if (assetAction == CREATE_ACTION AND poCategory == CORE_SERVICE AND find(lineDesc, "TripLink") <> -1){ 
		hasTripLinkCore = true;
	}
	
	if (assetAction == CREATE_ACTION AND poCategory == CORE_SERVICE AND find(lineDesc, "Risk Messaging") <> -1){ 
		hasRiskMessagingCore = true;
	}
	
	if (assetAction == CREATE_ACTION AND poCategory == CORE_SERVICE AND find(lineDesc, "Expense -") <> -1 AND find(lineDesc, "&") == -1){ //Expense core
		expenseCreated = true;
	}
	
	if (assetAction == TERMINATE_ACTION AND poCategory == CORE_SERVICE AND find(lineDesc, "Travel & Expense -") <> -1){ //Travel & Expense core
		teTerminated = true;
	}
}

if (expenseCreated AND teTerminated){
	teToExpense = true;
}

skipDict1 = dict("string"); //only 1 of the core service create lines will get written to (prevent doc engine from printing multiple paragraphs). 
skipDict2 = dict("string"); //only 1 of the core service terminate lines will get written to (prevent doc engine from printing multiple paragraphs)
skipDict3 = dict("string");
skipDict4 = dict("string"); // only 1 unique PI per product will get written to (avoid duplicate PI's getting printed in doc engine twice per CSYS-52506).

customIntellArray = string[]{"459964", "596", "866", "873", "596", "866", "873", "307", "279", "657"};

for key in seqNumArray { //loop for edition/core change mapping, as well as a completely terminated core. This loop also builds termination notes
	seqNumber = string(key);
	docNum = get(seqNumAttributeMappingDict, seqNumber); 
	parentDocNum = get(primeStringsDict, docNum + DOCNUM_DELIM + "_parent_doc_number");
	lineDesc = get(primeStringsDict, docNum + DOCNUM_DELIM + "lineDescription_line");
	
	familyName = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field23");
	poCategory = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field20");
	assetAction = get(primeStringsDict, docNum + DOCNUM_DELIM + "assetAction_line");
	piItemType = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field8");
	poID = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field1");
	
	pi = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_number"); //CSYS-52506 fix. KA. 10-6-2015
	
	if (poCategory == CORE_SERVICE AND assetAction == CREATE_ACTION){
		if (get(coreTerminatesDict, parentDocNum) == TERMINATE_ACTION AND get(skipDict1, parentDocNum) <> TRUE_STR){ //3. core is being replaced with another (has edition or core change)
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, get(terminateCoreDescDict, parentDocNum));
			put(skipDict1, parentDocNum, TRUE_STR);
		}
		else {
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, BLANK);
		}
	}
	
	if (poCategory == CORE_SERVICE AND assetAction == TERMINATE_ACTION AND piItemType == BASE_FEE AND get(coreCreatesDict, parentDocNum) <> CREATE_ACTION){ //2. line is a terminated core. core contains no creates. it's being terminated completely.
		if (get(skipDict2, parentDocNum) <> TRUE_STR){ 
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, "NOMATCH");
			put(skipDict2, parentDocNum, TRUE_STR);
		}
		else {
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, BLANK);
		}
	}
	
	if (poCategory == CORE_SERVICE AND assetAction == TERMINATE_ACTION AND piItemType == BASE_FEE AND get(coreCreatesDict, parentDocNum) == CREATE_ACTION){ //3. Line is a terminated core base, and there's an edition/core change
		if (get(skipDict3, parentDocNum) <> TRUE_STR){ 
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, "TERMINATEDCOREBASE");
			put(skipDict3, parentDocNum, TRUE_STR);
		}
		else{
			utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, BLANK);
		}
	}
	
	if (get(coreNonePlusModifyDict, parentDocNum) == NONE_ACTION){ //CSYS-46907 part 3
		utilResultString = util.formAttrValueStr(attributesDict, TERMINATED_CORE_MAPPING, docNum, BLANK); //Since the core doesn't have any core service terminated lines, make sure all terminated core mappings in that core get set back to blank
	}
	
	//SC P5 Step 7 continued:
	//Core services:
	if (poCategory == CORE_SERVICE){
		if (get(familyCreateDict, familyName) <> CREATE_ACTION AND get(familyTerminateDict, familyName) == TERMINATE_ACTION AND lineDesc <> "TripIt Pro - User Based Pricing"){ //family contains terminates and no creates, exclude TripIt Pro - User Based Pricing
			if (assetAction == TERMINATE_ACTION AND find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
		
		if (lineDesc == "TripIt Pro - User Based Pricing" AND assetAction == TERMINATE_ACTION){
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
	}
	
	//TE to Expense Scenario:
	if (poCategory == CORE_SERVICE){
		if (get(familyCreateDict, familyName) == CREATE_ACTION AND get(familyTerminateDict, familyName) == TERMINATE_ACTION AND lineDesc <> "TripIt Pro - User Based Pricing"){
			print "teToExpense Var: " + string(teToExpense);
			if (teToExpense){
				if (find(terminationNotes, "TRAVEL") == -1){
					terminationNotes = terminationNotes + "TRAVEL" + "; ";
				}
			}
		}
	}
	
	//Extended services:
	if (poCategory == EXTENDED_SERVICE){
		if (get(familyCreateDict, familyName) <> CREATE_ACTION AND get(familyTerminateDict, familyName) == TERMINATE_ACTION AND poID <> "36374" AND find(lineDesc, "Risk Management") == -1 AND find(lineDesc, "TripLink") == -1 AND find(lineDesc, "TripIt Pro") == -1 AND find(lineDesc, "TripIt for Teams") == -1 AND find(familyName, "Intelligence") == -1 AND poID <> "1055"){ //family contains terminates and no creates. Exclude Total Advantage, Risk Management, TripIt, Intelligence, Triplink, and Concur Connector for Salesforce extended services
			if (assetAction == TERMINATE_ACTION AND find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}	
	
		if (find(lineDesc, "Total Advantage") <> -1 AND assetAction == TERMINATE_ACTION){ //Total Advantage terminations
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
	
		if (find(lineDesc, "Risk Management") <> -1 AND assetAction == TERMINATE_ACTION AND NOT hasRiskMessagingCore){ //Risk Management terminations
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
		
		if (find(lineDesc, "TripLink") <> -1 AND assetAction == TERMINATE_ACTION AND NOT hasTripLinkCore AND get(familyCreateDict, familyName) <> CREATE_ACTION AND get(familyTerminateDict, familyName) == TERMINATE_ACTION){ //TripLink terminations: no TripLink core, family contains Terminates but no creates
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
		
		if ((find(lineDesc, "TripIt Pro") <> -1 OR find(lineDesc, "TripIt for Teams") <> -1) AND assetAction == TERMINATE_ACTION){ //TripIt terminations
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}
		}
		
		if (poID == "1055" AND assetAction == TERMINATE_ACTION){ //Concur Connector for Salesforce terminations
			if (find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}	
		}
		
		if ((get(familyTerminateDict, familyName) == TERMINATE_ACTION AND get(familyNoneModifyDict, familyName) <> NONE_ACTION AND get(familyNoneModifyDict, familyName) <> MODIFY_ACTION AND get(familyCreateDict, familyName) <> CREATE_ACTION AND find(familyName, "Intelligence") <> -1) OR (findinarray(customIntellArray, poID) <> -1)){ //Intelligence family has Terminates but doesn't have Create's or None's or Modify's. OR one of the *related* intelligence products is being terminated (CSYS-46753 KA 6-29-2015)
			if (assetAction == TERMINATE_ACTION AND find(terminationNotes, lineDesc) == -1){
				terminationNotes = terminationNotes + lineDesc + "; ";
			}	
		}

	} //end Extended Services check
}

terminationNotes2 = "";
if (terminationNotes <> ""){
	terminationNotes2 = "BMI: " + terminationNotes;
}

terminationNotes3 = "";
if (terminationNotes2 <> ""){
	terminationNotes3 = substring(terminationNotes2,0,-2); //trim the semi-colon
}

if (terminationNotes3 == ""){ //if we don't have notes, blank out the terminated date
	utilResultString = util.formAttrValueStr(attributesDict, "terminatedDate_quote", QUOTE_DOCNUM, "");
}

utilResultString = util.formAttrValueStr(attributesDict, "terminationNotes_quote", QUOTE_DOCNUM, terminationNotes3);

return "";]]></script_text><_children><bm_lib_func_assoc><id>126181598</id><caller_func_id>126181590</caller_func_id><called_lib_func_id>15722747</called_lib_func_id><rule_area><![CDATA[x- Systematized Terminations]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1486584936000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[fc474585-2905-43d3-b7d4-4996ddd2595e]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>126181592</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[seqNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_seqNumArray_7]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>126181593</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[seqNumAttributeMappingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_seqNumAttributeMappingDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>126181594</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[primeStringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_primeStringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>126181595</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[isCoreChangedDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_isCoreChangedDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>126181596</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[isEditionChangedDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_isEditionChangedDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>126181597</id><bm_lib_func_id>126181591</bm_lib_func_id><param_name><![CDATA[attributesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_systematizedTerminations.bm_lib_func_param_attributesDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4772381</id><name><![CDATA[convert2DArrayToDict]]></name><variable_name><![CDATA[convert2DArrayToDict]]></variable_name><description><![CDATA[String Dictionary =  convert2DArrayToDict (String[][]);
  param: array
  return: String Dictionary]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4772380</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_convert2DArrayToDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4772380</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convert2DArrayToDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435902000</date_modified><guid><![CDATA[LEGACY_4772380]]></guid><script_size>201</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* BML Utilities Libraries (convert2DArrayToDict)
   - Convert a string array into dictionary 
   
   @param: array - String[][]
   @return: String Dictionary
   
*/

resultDict = dict("string");

for row in array {
  put(resultDict, row[0], row[1]);
} 

return resultDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4772382</id><bm_lib_func_id>4772381</bm_lib_func_id><param_name><![CDATA[array]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>10</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_convert2DArrayToDict.bm_lib_func_param_array_10]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5126934</id><name><![CDATA[getTermBasedDisc]]></name><variable_name><![CDATA[getTermBasedDisc]]></variable_name><description></description><return_type>2</return_type><func_type>1</func_type><function_id>5126926</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getTermBasedDisc]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5126926</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getTermBasedDisc_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435914000</date_modified><guid><![CDATA[LEGACY_5126926]]></guid><script_size>294</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// Parameters:
// commerceTerm - Term value from Commerce
// defaultVal - Default value if there is no term discount based on Commerce term in the data table
resTerm = 0.0;
tableRes = false;
termDiscResSet = bmql("SELECT termBasedDisc FROM termBasedDiscount WHERE term=$commerceTerm");
for termDiscRes in termDiscResSet {
  term = get(termDiscRes, "termBasedDisc");
  if(NOT(isnull(term)) AND isnumber(term)) {
    resTerm = atof(term);
  }
  tableRes = true;
}
if(NOT(tableRes)) { // If there is no table entry, use default value 
  resTerm = defaultVal;
}
return resTerm;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5126936</id><bm_lib_func_id>5126934</bm_lib_func_id><param_name><![CDATA[commerceTerm]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getTermBasedDisc.bm_lib_func_param_commerceTerm_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5126937</id><bm_lib_func_id>5126934</bm_lib_func_id><param_name><![CDATA[defaultVal]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getTermBasedDisc.bm_lib_func_param_defaultVal_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5400329</id><name><![CDATA[Convert To Non Sci Notation]]></name><variable_name><![CDATA[convertToNonSciNotation]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>5400328</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_convertToNonSciNotation]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5400328</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convertToNonSciNotation_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435929000</date_modified><guid><![CDATA[LEGACY_5400328]]></guid><script_size>1715</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
  convertToNonScientificNotation
  param:
    inputValue  - String
    dataType    - String : Integer, float
    numDecimal  - Integer
  return:
    result      - String 
*/
result = inputValue  ;
if ( dataType == "float" ) {
  temp = atof(inputValue);
  temp = round(temp, numDecimal);
  result = string(temp);
}

value = lower(result);
valueFloat = "";

pos = find(value, "e");
powerOf = 0;
resultArray = string[];

if ( pos <> -1 ) {
  txt = substring(value, pos+1);
  if ( isnumber(txt) ) {
    powerOf = integer(atof(txt));
  }
  valueFloat = substring(value, 0, pos);
  valueLen = len(valueFloat);
  
  // move the decimal point
  decimalPos = find(valueFloat, ".");
  if ( powerOf > 0 ) {
    list = range(powerOf+2);
    for item in list {
      if ( item < len( valueFloat ) ) {
        txt =  substring(valueFloat, item, item+1);
        if ( txt <> "." ) {
          append(resultArray, txt);
        } 
      }
      else {
        append(resultArray, "0");
      } 
    }
    // Add the rest decimal to the array 
    decimal = "";
    if ( valueLen > powerOf+2 ) {
      //append(resultArray, ".");
      decimal = substring(valueFloat, powerOf+2);
    } 
    else {
      decimal = "00";  
    } 
    if ( decimal <> "" ) {
      append(resultArray, ".");
      append(resultArray, decimal);
    }
  }
  elif ( powerOf < 0 ) {
    list = range(integer(fabs(powerOf*1.0))-1);
    resultArray = string[]{"0", "."};
    decimalPos = find(valueFloat, ".");
    for item in list {
      append( resultArray, "0");
    } 
    list = range(len(valueFloat));  // ignore the decimal place 
    for item in list {
      txt = substring(valueFloat, item, item+1);
      if ( txt <> "." ) {
        append(resultArray, txt);
      } 
    }
  } 
}
else {
  list = range(len(value));
  for item in list {
    txt =  substring(value, item, item+1);
    append(resultArray, txt);
  }
} 

newArray = String[];
index = sizeofarray(resultArray) - 1;
thousandCount = 0;
decimalFound = false;
if ( findinarray(resultArray, ".") == -1 ) {
  decimalFound = true;  
} 
for item in resultArray {
  val = resultArray[index];
  append(newArray, val);
  if ( decimalFound ) {
    thousandCount = thousandCount + 1;
    if ( thousandCount == 3 ) {
      if ( index <> 0 ) {
        append(newArray, ",");
      }
      thousandCount = 0;
    } 
  }
  if ( val == "." ) {
    decimalFound = true;
  }
  index = index - 1;
}
newArray = reverse(newArray);
result = join(newArray, "");

if ( dataType == "integer" ) {
  pos = find(result, ".");
  if ( pos <> -1 ) {
    result = substring(result, 0, pos);
  }
} 
result = replace(result, ",", "");

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5400331</id><bm_lib_func_id>5400329</bm_lib_func_id><param_name><![CDATA[inputValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_convertToNonSciNotation.bm_lib_func_param_inputValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5400332</id><bm_lib_func_id>5400329</bm_lib_func_id><param_name><![CDATA[dataType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_convertToNonSciNotation.bm_lib_func_param_dataType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5400333</id><bm_lib_func_id>5400329</bm_lib_func_id><param_name><![CDATA[numDecimal]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547404000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_convertToNonSciNotation.bm_lib_func_param_numDecimal_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5021969</id><name><![CDATA[Get Currency Data]]></name><variable_name><![CDATA[getCurrencyData]]></variable_name><description><![CDATA[Query currencyData table and return the correct value.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>5021968</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getCurrencyData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[// Unit Testing Script
/* Test cases
0//currencyCode Valid :
	currencyCode - "USD"
   Returned Values :
	conversionRate = "1.0"
	numDecimals = "2"
	error - Not Exist
	
1//currencyCode invalid :
	currencyCode - "ASDF"
   Returned Values :
	conversionRate = Not Exist
	numDecimals = Not Exist
	error - "No records found matching the given currency code."

*/


result = dict("string");
currencyCodeDict = dict("string");
conversionRateDict = dict("string");
numDecimalsDict = dict("string");
errorDict = dict("string");

index = 0;

put( currencyCodeDict, index, "USD" );
put( conversionRateDict, index, "1.0" );
put( numDecimalsDict, index, "2" );
put( errorDict, index, "***" );
index = index + 1;

put( currencyCodeDict, index, "ASDF" );
put( conversionRateDict, index, "***" );
put( numDecimalsDict, index, "***" );
put( errorDict, index, "No records found matching the given currency code." );
index = index + 1;


numTests = index;
numTestsRun = 0;
numFailures = 0;
testIndexes = range(numTests);

for i in testIndexes {
	numTestsRun = numTestsRun + 1;
	testCurrencyCode = get(currencyCodeDict,i);
	expectedConversionRate = get (conversionRateDict, i);
	expectednumDecimals = get (numDecimalsDict, i);
	expectedError = get (errorDict, i);
	
	expectedResult = expectedConversionRate + ":::" + expectedNumDecimals + ":::" + expectedError;
	conversionRateResult = "";
	numDecimalsResult = "";
	errorResult = "";
	print "Test " + string(i+1) + ": " + expectedResult; 
		
		// call function
	result = util.getCurrencyData(testCurrencyCode);
		
	fail = false;
	resultIndex = 0;
	if ( containskey( result, "conversionRate" ) <> true AND expectedConversionRate <> "***" ){
		conversionRateResult = "***";
		fail = true;
	}
	if ( containskey( result, "numDecimals" ) <> true AND expectednumDecimals <> "***" ){
		numDecimalsResult = "***";
		fail = true;
	}
	if ( containskey( result, "error" ) <> true AND expectedError <> "***" ){
		errorResult = "***";
		fail = true;
	}
	if ( containskey( result, "conversionRate" ) AND expectedConversionRate <> get( result, "conversionRate" ) ){
		conversionRateResult = get( result, "conversionRate" );
		fail = true;
	}
	if ( containskey( result, "numDecimals" ) AND expectednumDecimals <> get( result, "numDecimals" )){
		numDecimalsResult = get( result, "numDecimals" );
		fail = true;
	}
	if( containskey( result, "error" ) AND expectedError <> get( result, "error" )){
		errorResult = get( result, "error" );
		fail = true;
	}
	resultIndex = resultIndex + 1;
	actualResult = conversionRateResult + ":::" + numDecimalsResult + ":::" + errorResult;
	if(fail) {
		numFailures = numFailures + 1;
		print "FAIL";
		print "EXPECTED: ";
		print expectedResult;
		print "ACTUAL: ";
		print actualResult;
			
	} else {
		print "SUCCESS";
	}
	print "----";
		
}
if(numFailures == 0) {
	print "ALL " + string(numTestsRun) + " TESTS PASSED";
} else {
	print string(numFailures) + " FAILURES out of " + string(numTestsRun) + " TESTS";
}

nullResult = dict("string");
return nullResult;]]></main_script_text><_children><bm_function><id>5021968</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getCurrencyData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435914000</date_modified><guid><![CDATA[LEGACY_5021968]]></guid><script_size>401</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> getCurrencyData

Parameter:
1.	String currencyCode

Return:
	String Dictionary  Key: conversionRate, numDecimals, error
					   Value: table data from the currencyData table.
	
*/

retDict = dict("string");
// Expected : 1 Record returned.
currencySet = bmql( "SELECT conversionRate, numDecimals, currencySymbol FROM currencyData WHERE currencyCode = $currencyCode" );


// Assuming 1 record.
recordFound = false;
for record in currencySet{
	recordFound = true;
	put( retDict, "conversionRate", get( record, "conversionRate" ) );
	put( retDict, "numDecimals", get( record, "numDecimals" ) );
	put( retDict, "currencySymbol", get( record, "currencySymbol" ) );
}

// No records found
if( recordFound == false ){
	put( retDict, "error", "No records found matching the given currency code." );
}
return retDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5021971</id><bm_lib_func_id>5021969</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getCurrencyData.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>10172922</id><name><![CDATA[GetPOsforConcurForceAndPremierTravelSOF]]></name><variable_name><![CDATA[getPOsforConcurForceAndPremierTravelSOF]]></variable_name><description><![CDATA[This Util Library returns a dictionary with PO IDs and the SOF template required. Different template is required for Concurforce and Premier travel.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>10172921</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getPOsforConcurForceAndPremierTravelSOF]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>10172921</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPOsforConcurForceAndPremierTravelSOF_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435932000</date_modified><guid><![CDATA[devconcur_8926278]]></guid><script_size>2388</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*Util Library. getPOsforConcurForceAndPremierTravelSOF. Returns POs for concurforce and Premier Travel */
/*The calling function will always look for ~POID~*/
retstrDict = dict("string");
results = bmql("select POID,ConcurforceTempReq,PremierTravelTempReq, ClientWebServiceReq, IntelligenceRptReq, MeetingMgtReq, MultiCountryExpReq, SingleCountryExpReq, ConsultingSessionReq, SiteReviewReq, SiteReviewEliteReq  from POBasedSOFTemplates");
for result in results {
	po = get(result, "POID");
	concurForcetmpReq= get(result, "ConcurforceTempReq");
	premTraveltmpReq= get(result, "PremierTravelTempReq");	
	clientWebServiceReq= get(result, "ClientWebServiceReq");
	intelRptReq= get(result, "IntelligenceRptReq");
	meetMgtReq= get(result, "MeetingMgtReq");
	multiCountryExpReq = get(result, "MultiCountryExpReq");
	singleCountryExpReq = get(result, "SingleCountryExpReq");
	consultingSessionReq = get(result, "ConsultingSessionReq");
	siteReviewReq = get(result, "SiteReviewReq");
	siteReviewEliteReq = get(result, "SiteReviewEliteReq");
	
	if(upper(concurForcetmpReq) == "Y") {
		if (not containskey(retstrDict,"Concurforce")) {
			put(retstrDict,"Concurforce","~"+po+"~");
		} else {
			put(retstrDict,"Concurforce",get(retstrDict,"Concurforce")+po+"~");
		}
	}
	if(upper(premTraveltmpReq) == "Y") {
		if (not containskey(retstrDict,"PremierTravel")) {
			put(retstrDict,"PremierTravel","~"+po+"~");
		} else {
			put(retstrDict,"PremierTravel",get(retstrDict,"PremierTravel")+po+"~");
		}
		
	}	
	if(upper(clientWebServiceReq) == "Y") {
		if (not containskey(retstrDict,"ClientWebService")) {
			put(retstrDict,"ClientWebService","~"+po+"~");
		} else {
			put(retstrDict,"ClientWebService",get(retstrDict,"ClientWebService")+po+"~");
		}
		
	}
	if(upper(intelRptReq) == "Y") {
		if (not containskey(retstrDict,"IntelRpt")) {
			put(retstrDict,"IntelRpt","~"+po+"~");
		} else {
			put(retstrDict,"IntelRpt",get(retstrDict,"IntelRpt")+po+"~");
		}
		
	}
	if(upper(meetMgtReq) == "Y") {
		if (not containskey(retstrDict,"meetingMgt")) {
			put(retstrDict,"meetingMgt","~"+po+"~");
		} else {
			put(retstrDict,"meetingMgt",get(retstrDict,"meetingMgt")+po+"~");
		}
		
	}
	
	if(upper(singleCountryExpReq) == "Y") {
		if (not containskey(retstrDict,"singleCountryExpReq")) {
			put(retstrDict,"singleCountryExpReq","~"+po+"~");
		} else {
			put(retstrDict,"singleCountryExpReq",get(retstrDict,"singleCountryExpReq")+po+"~");
		}
		
	}
	
	if(upper(multiCountryExpReq) == "Y") {
		if (not containskey(retstrDict,"multiCountryExpReq")) {
			put(retstrDict,"multiCountryExpReq","~"+po+"~");
		} else {
			put(retstrDict,"multiCountryExpReq",get(retstrDict,"multiCountryExpReq")+po+"~");
		}
		
	}
	
	if(upper(consultingSessionReq) == "Y") {
		if (not containskey(retstrDict,"consultingSessionReq")) {
			put(retstrDict,"consultingSessionReq","~"+po+"~");
		} else {
			put(retstrDict,"consultingSessionReq",get(retstrDict,"consultingSessionReq")+po+"~");
		}
		
	}
	
	if(upper(siteReviewReq) == "Y") {
		if (not containskey(retstrDict,"siteReviewReq")) {
			put(retstrDict,"siteReviewReq","~"+po+"~");
		} else {
			put(retstrDict,"siteReviewReq",get(retstrDict,"siteReviewReq")+po+"~");
		}
		
	}
	if(upper(siteReviewEliteReq) == "Y") {
		if (not containskey(retstrDict,"siteReviewEliteReq")) {
			put(retstrDict,"siteReviewEliteReq","~"+po+"~");
		} else {
			put(retstrDict,"siteReviewEliteReq",get(retstrDict,"siteReviewEliteReq")+po+"~");
		}
		
	}
}
return retstrDict;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>4772384</id><name><![CDATA[eval]]></name><variable_name><![CDATA[eval]]></variable_name><description><![CDATA[OLD - DO NOT USE - Evaluates {expression} based on the dictionary passed {attrs} for truthiness]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4772383</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_eval]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4772383</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_eval_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435903000</date_modified><guid><![CDATA[LEGACY_4772383]]></guid><script_size>2970</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[debug = false;
wildcard = "NA";
null = "";
quote = "\"";
delim = "|^|";
returnVal = -1;
ORop = " || ";
ANDop = " && ";
plusOp = "+";
multOp = "*";
gtOp = ">";
ltOp = "<";
gteOp = ">=";
lteOp = "<=";
eqOp = "=";
neOp = "<>";
tilOp = "~";
findOp = "(contains)";
emptyStr = "''";
boolOps = String[]{gteOp,lteOp,neOp,gtOp,ltOp,eqOp,findOp};

if(expression == null) {
  return expression;
}
if (substring(expression,0,1) == quote and substring(expression,-1) == quote) {
  return substring(expression,1,-1);
}

clauses = split(expression,ANDop);

clauseVals = String[];

i = 0;
for clause in clauses {
  if(debug){print("AND-CLAUSE:" + clause);}
  clauseTrue = false;
  if(substring(clause,0,1) == quote and substring(clause,-1) == quote) {
    clauseTrue = true;
    clauseVals[i] = substring(clause,1,-1);
    i = i+1;
    continue;
  }
  subClauses = split(clause,ORop);
  subClauseVals = String[];
  j = 0;
  for subClause in subClauses {
    if(debug){print("   OR-CLAUSE: " + subClause);}
    if(substring(subclause,0,1) == quote and substring(subclause,-1) == quote) {
      j=j+1;
      continue;
    }
    comps = String[]{subClause};
    thisOp = null;
    for op in boolOps {
      if(find(subClause,op)>0) {
        thisOp = op;
        comps = split(subClause,op);
        break;
      }
    }
    k = 0;
    for comp in comps {
      if(debug){print("      Comp:"+comp);}
      valNum = 0;
      valStr = null;
      if(substring(comp,0,1) == quote and substring(comp,-1) == quote) {
        valStr = substring(comp,1,-1);
      } else {
        summands = split(comp,plusOp);
        if(debug){print "            SUMMANDS:" + join(summands,", ");}

        for summand in summands {
          if(summand == null) {
            continue;
          }
          if(isnumber(summand)) {
            valNum = valNum + atof(summand);
            continue;
          }
          mults = split(summand,multOp);
          mtotal = 1;
          if(debug){print "              MULTS:" + join(mults,",");}
          for mult in mults {
            mNum = 1;
            if(isnumber(mult)) {
              mtotal = mtotal * atof(mult);
              continue;
            }
            isVariable = containskey(attrs,mult);
            if(isVariable) {
              varVal = get(attrs,mult);
              if(isnumber(varVal)) {
                mNum = atof(varVal);
              }
              else {
                valStr = varVal;
				//mNum = 0;
              }
            }
            if(not(isVariable)) { 
              valStr = comp;
              break;
            }
            mtotal = mtotal * mNum;
          }
          valNum = valNum + mtotal;
        }
      }

      if(valStr == null ) {
        valStr = string(valNum);
      }
	  elif( valStr == emptyStr ){
		valStr = "1";
	}
      if(debug){print("                VAL: " + valStr);}
      comps[k] = valStr;
      k = k+1;
    }
    leftSide = 0;
    numbers = false;
    rightSide = 0;
    //rightSideNum = false;
    if(thisOp == null) {
      // no comparator, return value of expression
      clauseTrue = true;
      return comps[0];
    }
    if(isnumber(comps[0])) {
      leftSide = atof(comps[0]);
      numbers = true;
    }
    if(numbers) {
      if(not(isnumber(comps[1]))) {	



        numbers = false;
      } else {
        rightSide = atof(comps[1]);
      }
    }
    //if(debug){print(comps[0] + thisOp + comps[1] + "?");}
    //clauseTrue = false;
    if(thisOp == gtOp) {
      if(numbers and leftSide > rightSide or
          (not(numbers) and comps[0] > comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == ltOp) {
      //if(debug){print("ltOp");}
      if(numbers and leftSide < rightSide or
          (not(numbers) and comps[0] < comps[1])) {
        
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == lteOp) {
      if(numbers and leftSide <= rightSide or
          (not(numbers) and comps[0] <= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == gteOp) {
      if(numbers and leftSide >= rightSide or
          (not(numbers) and comps[0] >= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == eqOp) {
      //if(debug){print(comps[0] + thisOp + comps[1]);}
      if(numbers and leftSide == rightSide or
          (not(numbers) and comps[0] == comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == neOp) {
      if(numbers and leftSide <> rightSide or
          (not(numbers) and comps[0] <> comps[1])) {
        clauseTrue = true;
        break;
      }
      
    }
    elif (thisOp == findOp) {
    	compsSplitArray = split(comps[0],tilOp);
    	if(findinarray(compsSplitArray, comps[1])>=0)
    	{
    		clauseTrue = true;
       		print clauseTrue;
       		break;
    	}
      /*if(find(comps[0], comps[1])>=0){
       	clauseTrue = true;
       	print clauseTrue;
       	break;
      }*/
    }
    j = j+1;
  }
  if(not(clauseTrue)) {
    return "FALSE";
  }
}
return "TRUE";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4772385</id><bm_lib_func_id>4772384</bm_lib_func_id><param_name><![CDATA[expression]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_eval.bm_lib_func_param_expression_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4772386</id><bm_lib_func_id>4772384</bm_lib_func_id><param_name><![CDATA[attrs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_eval.bm_lib_func_param_attrs_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>10172918</id><name><![CDATA[GetPOsToBeGrouped]]></name><variable_name><![CDATA[isPOGrouped]]></variable_name><description><![CDATA[This Function returns all the PO IDs that need to be grouped]]></description><return_type>1</return_type><func_type>1</func_type><function_id>10172917</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_isPOGrouped]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>10172917</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isPOGrouped_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435931000</date_modified><guid><![CDATA[devconcur_8876219]]></guid><script_size>184</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getDefaultBasedOnBUAndMarket
None. This returns all distinct POs which have to be grouped. The calling function will always search for ~POID~
*/
retStr = "~";				//Initialize Return String
results = bmql("select DISTINCT PO from poToBeGrouped"); // Query the table for the POs
for result in results {			
	poNum= get(result, "PO");//If found
	retStr = retStr + poNum + "~";//Add to the return string separated by ~
}
return retStr; // Return]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>955432092</id><name><![CDATA[Get Hiding Status Of Products]]></name><variable_name><![CDATA[getHidingStatusOfProducts]]></variable_name><description><![CDATA[CSYS-99720 (SV. 09-07-2020) : Clone of getHidingStatus. Created to support products which are no longer available]]></description><return_type>4</return_type><func_type>1</func_type><function_id>955432091</function_id><date_modified>1603968139000</date_modified><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>955432091</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getHidingStatusOfProducts_1]]></java_class_name><child_class_names></child_class_names><date_modified>1603968139000</date_modified><guid><![CDATA[0e325bbc-5660-4f42-94fb-8d72c403568f]]></guid><script_size>982</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util - Get Hiding Status
coreOffering - String
implementationMethod - String
serviceAttr - String
*/
availibilityArray = String[];
//BM_VT. Business unit is required as additional filter. Getting the business unit from the commerce process
ownerBusUnit = "%"+ ownerBusinessUnit +"%";
theater = "%"+ ownerTheater +"%";
market = "%"+ ownerMarket +"%";
type = "%"+ quoteType +"%";

// Add Business unit filter
recordSet = bmql("select availability from serviceCompatibility where coreOffering = $coreOffering and implementationMethod = $implementationMethod and serviceAttr = $serviceAttr and (businessUnit like $ownerBusUnit or businessUnit = '' or businessUnit is null) and (ownerTheater like $theater or ownerTheater = '' or ownerTheater is null) and (ownerMarket like $market or ownerMarket = '' or ownerMarket is null) AND (quoteType like $type or quoteType = '' or quoteType is null)");

for rec in recordSet
{
	append(availibilityArray, get(rec,"availability"));
}

//New Changes Start
selectAssetArray = get(configAttribs, "selectAssetArray","string[]");
assetsImport = get(configAttribs, "assetsImport","string");
poID = get(configAttribs, "poID","string");
assetAccountServiceIDArray = get(configAttribs, "assetAccountServiceIDArray","string[]");
hasAsset = false;


if(quoteType == "Add-On Business"){
	YES = "Yes";
	loc = findinarray(selectAssetArray,YES); //current selected core in config		
	
	ASSET_DELIMITER = "@@";
	INTERNAL_DELIMITER = "$$";
	
	assetsArray = split(assetsImport,ASSET_DELIMITER);//split the entire assets delimited string
	size = range(sizeofarray(assetsArray));	
	
	for i in size {
		assetDetail = split(assetsArray[i],INTERNAL_DELIMITER);//split each asset
	
		if (assetDetail[1] == poID AND assetDetail[16] == assetAccountServiceIDArray[loc]) {
			hasAsset = true;  // Set to TRUE if any of the above declared PO's are found in the Asset string, relevant to the core we're dealing with in the current config trip
			break;
		}
	}
}
//New Changes end

//CSYS-100182 (BS 07/31/2020): Added below statements to remove Historical Data Services as an Extended Service, but support it on existing quotes which has this product
//Start
//CSYS-100982 (BS 10/27/2020): Added below condition to make all grandfathered services unavailable when Historical Data Services is selected as core service.
if(coreOffering == "Historical Data Services"){
	return true;
}
else{
	if(poID == "5005"){
		if((findinarray(availibilityArray,"TRUE")>-1) AND hasAsset AND quoteType == "Add-On Business"){
			return false;
		}
		else{
			return true;
		}
	}
	//CSYS-100182 End

	if((findinarray(availibilityArray,"TRUE")>-1) OR (hasAsset AND quoteType == "Add-On Business")) 
	{ 
		return false;
	}
	else
	{
		return true;
	}
}]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>955432094</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[coreOffering]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_coreOffering_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432095</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[implementationMethod]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_implementationMethod_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432096</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[serviceAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_serviceAttr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432097</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[ownerBusinessUnit]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_ownerBusinessUnit_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432098</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[ownerMarket]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_ownerMarket_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432099</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[ownerTheater]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_ownerTheater_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432100</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[quoteType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1603968139000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_quoteType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>955432101</id><bm_lib_func_id>955432092</bm_lib_func_id><param_name><![CDATA[configAttribs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>34</datatype><date_modified>1603968139000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusOfProducts.bm_lib_func_param_configAttribs_34]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4772391</id><name><![CDATA[getConfigMenuValue]]></name><variable_name><![CDATA[getConfigMenuValue]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4772390</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getConfigMenuValue]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4772390</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getConfigMenuValue_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435904000</date_modified><guid><![CDATA[LEGACY_4772390]]></guid><script_size>67</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[return "";]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>10172906</id><name><![CDATA[GetUnitBasedRecurringServicesPO]]></name><variable_name><![CDATA[getUnitBasedRecurringServicesPI]]></variable_name><description><![CDATA[This Library returns the list of PO for the unit based Recurring Service]]></description><return_type>1</return_type><func_type>1</func_type><function_id>10172905</function_id><date_modified>1691658959000</date_modified><guid><![CDATA[bm_lib_func_util_getUnitBasedRecurringServicesPI]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>10172905</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getUnitBasedRecurringServicesPI_1]]></java_class_name><child_class_names></child_class_names><date_modified>1691658959000</date_modified><guid><![CDATA[testconcur_8536677]]></guid><script_size>174</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* The return format is ~PO1~PO2~... */
retStr = "~";
//CSYS-106954 SV. 01-09-2022 Commented out the reference to UnitBasedRecServsPIs. Instead using trnsValidation datatable
//IESCNQRCPQ-770. LBN. 10-08-2023, Uncommenting UnitBasedRecServsPI line and commenting trnsValidation for updating description for PSE from Transaction to Unit Based
results = bmql("select POID from UnitBasedRecServsPIs");
//results = bmql("SELECT PO FROM trnsValidation");
for result in results {
	retStr = retStr + get(result, "POID") + "~";
}
return retStr;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>4912696</id><name><![CDATA[Get Service Compatible Data]]></name><variable_name><![CDATA[getServiceCompatibleData]]></variable_name><description><![CDATA[Based on the serviceCompatibilityMatrix data table, we will create a list of Constraint Rules to show the appropriate options from configuration attributes (in the Professional and Extended Services tab) dropdown. The Constraint Rules will only return the valid options to those attributes.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4912695</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getServiceCompatibleData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4912695</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getServiceCompatibleData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435906000</date_modified><guid><![CDATA[LEGACY_4912695]]></guid><script_size>722</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = "";
returnArray = String[];
pipe = "|^|";
returnArray[0] = pipe;

//BM_VT. Business unit is required as additional filter. Getting the business unit from the commerce process
ownerBusUnit = "";
ownerTheater = "";
ownerMarket = "";
quoteType = "";
resSet = bmql("SELECT ownerBU_quote, ownerTheater_quote, ownerMarket_quote, quoteType_quote FROM commerce.quote_process");

for res in resSet {
	ownerBusUnit = "%"+get(res, "ownerBU_quote")+"%";
	ownerTheater = "%"+get(res, "ownerTheater_quote")+"%";
	ownerMarket = "%"+get(res, "ownerMarket_quote")+"%";
	quoteType = "%"+get(res, "quoteType_quote")+"%";
}

// Add Business unit filter
recordSet = bmql("select serviceValue, availability from serviceCompatibility where serviceAttr = $serviceAttr and coreOffering = $coreOffer and implementationMethod = $implementationMethod and (businessUnit like $ownerBusUnit or businessUnit = '' or businessUnit is null) and (ownerTheater like $ownerTheater or ownerTheater = '' or ownerTheater is null) and (ownerMarket like $ownerMarket or ownerMarket = '' or ownerMarket is null) AND (quoteType like $quoteType or quoteType = '' or quoteType is null)");

for rec in recordSet
{
	if((upper(get(rec,"availability"))=="TRUE"))
	{
		append(returnArray, trim(get(rec,"serviceValue")));
	}
}

result = join(returnArray,pipe);

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4912698</id><bm_lib_func_id>4912696</bm_lib_func_id><param_name><![CDATA[serviceAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleData.bm_lib_func_param_serviceAttr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4912699</id><bm_lib_func_id>4912696</bm_lib_func_id><param_name><![CDATA[coreOffer]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleData.bm_lib_func_param_coreOffer_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4912700</id><bm_lib_func_id>4912696</bm_lib_func_id><param_name><![CDATA[implementationMethod]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleData.bm_lib_func_param_implementationMethod_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814651</id><name><![CDATA[getFloatDict]]></name><variable_name><![CDATA[getFloatDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>2</return_type><func_type>1</func_type><function_id>4814650</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getFloatDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814650</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getFloatDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435923000</date_modified><guid><![CDATA[LEGACY_4814650]]></guid><script_size>169</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
getFloatDict
*/

result = defaultValue;

if ( containskey(dictionary, key) ) {
	result = get(dictionary, key);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814652</id><bm_lib_func_id>4814651</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getFloatDict.bm_lib_func_param_dictionary_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814653</id><bm_lib_func_id>4814651</bm_lib_func_id><param_name><![CDATA[key]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getFloatDict.bm_lib_func_param_key_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814654</id><bm_lib_func_id>4814651</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getFloatDict.bm_lib_func_param_defaultValue_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>10172910</id><name><![CDATA[Get Default Based on BU, Implementation and Market (NOT USED)]]></name><variable_name><![CDATA[getDefaultBasedOnBUImplementationAndMarket]]></variable_name><description><![CDATA[This Library accepts BU, Market, Implementation and Attribute Name as inputs and gives the default value for the attribute name]]></description><return_type>1</return_type><func_type>1</func_type><function_id>10172909</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getDefaultBasedOnBUImplementationAndMarket]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>10172909</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getDefaultBasedOnBUImplementationAndMarket_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435931000</date_modified><guid><![CDATA[testconcur_8743801]]></guid><script_size>402</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getDefaultBasedOnBUImplementationAndMarket
businessUnit- String
market- String
attributeName - String
Implementation - String
*/
retStr = "";				//Initialize Return String
imp = "";
results =  recordset();
//Query the table using the filter for BU,Implementation Market and Attr Name

if(Implementation == "Concurforce"){
	results = bmql("select DefaultValue from DefaultUsgBUAndMKT where Implementation = 'Concurforce'  and BusinessUnit like $businessUnit and Market like $market and AttributeName like $attributeName");
} elif (Market == ""){
	results = bmql("select DefaultValue from DefaultUsgBUAndMKT where (Market = '' or Market is null)  and BusinessUnit like $businessUnit and AttributeName like $attributeName");
} else {
	results = bmql("select DefaultValue from DefaultUsgBUAndMKT where (Implementation = '' or Implementation is null)  and BusinessUnit like $businessUnit and Market like $market and AttributeName like $attributeName");
}

for result in results {
	retStr = get(result, "DefaultValue");	// Get the result
}
return retStr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>10172911</id><bm_lib_func_id>10172910</bm_lib_func_id><param_name><![CDATA[businessUnit]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getDefaultBasedOnBUImplementationAndMarket.bm_lib_func_param_businessUnit_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10172912</id><bm_lib_func_id>10172910</bm_lib_func_id><param_name><![CDATA[market]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getDefaultBasedOnBUImplementationAndMarket.bm_lib_func_param_market_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10172913</id><bm_lib_func_id>10172910</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getDefaultBasedOnBUImplementationAndMarket.bm_lib_func_param_attributeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10172914</id><bm_lib_func_id>10172910</bm_lib_func_id><param_name><![CDATA[Implementation]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547404000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getDefaultBasedOnBUImplementationAndMarket.bm_lib_func_param_Implementation_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4842303</id><name><![CDATA[getQuoteValueViaSoap]]></name><variable_name><![CDATA[getQuoteValueViaSoap]]></variable_name><description><![CDATA[NOT USED.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4842302</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getQuoteValueViaSoap]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4842302</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getQuoteValueViaSoap_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435925000</date_modified><guid><![CDATA[LEGACY_4842302]]></guid><script_size>330</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* BML Util: getQuoteValueViaSoap
  siteCompany
  sessionId
  bsid
  attrTag
  */
soapCallXml = "";
soapCallXml = "<?xml version='1.0' encoding='UTF-8'?><soapenv:Envelope xmlns:soapenv='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'><soapenv:Header><bm:userInfo xmlns:bm='urn:soap.bigmachines.com' soapenv:actor='http://schemas.xmlsoap.org/soap/actor/next' soapenv:mustUnderstand='0'><bm:sessionId>" + sessionId + "</bm:sessionId></bm:userInfo><bm:category xmlns:bm='urn:soap.bigmachines.com' soapenv:actor='http://schemas.xmlsoap.org/soap/actor/next' soapenv:mustUnderstand='0'>Commerce</bm:category><bm:xsdInfo xmlns:bm='urn:soap.bigmachines.com' soapenv:actor='http://schemas.xmlsoap.org/soap/actor/next' soapenv:mustUnderstand='0'><bm:schemaLocation>http://" + siteCompany + ".bigmachines.com/bmfsweb/harmonic/schema/v1_0/commerce/transaction_bmClone_1.xsd</bm:schemaLocation></bm:xsdInfo></soapenv:Header><soapenv:Body><bm:getTransaction xmlns:bm='urn:soap.bigmachines.com'><bm:transaction><bm:id>" + bsid + "</bm:id></bm:transaction></bm:getTransaction></soapenv:Body></soapenv:Envelope>";

soapCallResultXml = urldatabypost("https://" + siteCompany + ".bigmachines.com/v1_0/receiver", soapCallXml, "NA");
result = "";

if (soapCallResultXml <> "NA") {  
  quoteLevelTag = "<bm:" + attrTag + ">";
  quoteLevelEndTag = "</bm:" + attrTag + ">";
  quoteLevelIndex = find(soapCallResultXml,quoteLevelTag);
  if(quoteLevelIndex <> -1) {
    // found parent doc number
    quoteLevel = substring(soapCallResultXml,quoteLevelIndex + len(quoteLevelTag), find(soapCallResultXml, quoteLevelEndTag));
    result = quoteLevel;
  }
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4842305</id><bm_lib_func_id>4842303</bm_lib_func_id><param_name><![CDATA[siteCompany]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getQuoteValueViaSoap.bm_lib_func_param_siteCompany_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4842306</id><bm_lib_func_id>4842303</bm_lib_func_id><param_name><![CDATA[sessionId]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getQuoteValueViaSoap.bm_lib_func_param_sessionId_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4842307</id><bm_lib_func_id>4842303</bm_lib_func_id><param_name><![CDATA[bsid]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getQuoteValueViaSoap.bm_lib_func_param_bsid_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4842308</id><bm_lib_func_id>4842303</bm_lib_func_id><param_name><![CDATA[attrTag]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getQuoteValueViaSoap.bm_lib_func_param_attrTag_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5144118</id><name><![CDATA[spliceXMLNodeValuesExtended]]></name><variable_name><![CDATA[spliceXMLNodeValuesExtended]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>5144117</function_id><date_modified>1699521794000</date_modified><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValuesExtended]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[xmlString = "<rampPlanDetails className='rampPlanDetails' rowCounterDisplayName='Ramp Plans' parentNodeName='rampPlanDetails' childNodeName='rampPlanDetail'><rampPlanDetail><from displayName='From' readOnly='false'>1</from><to displayName='To' readOnly='true'>4</to><transactions displayName='Transactions' readOnly='false'>1000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>5</from><to displayName='To' readOnly='true'>14</to><transactions displayName='Transactions' readOnly='false'>2000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>15</from><to displayName='To' readOnly='true'>and beyond</to><transactions displayName='Transactions' readOnly='false'>3000</transactions></rampPlanDetail></rampPlanDetails>";

spliceNodeName = "transactions";

newNodeValues = string[]{"1", "2", "3"};

return util.spliceXMLNodeValuesExtended(xmlString, spliceNodeName, newNodeValues,"rampPlanDetail");]]></main_script_text><_children><bm_function><id>5144117</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_spliceXMLNodeValuesExtended_1]]></java_class_name><child_class_names></child_class_names><date_modified>1699521794000</date_modified><guid><![CDATA[LEGACY_5144117]]></guid><script_size>771</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> spliceXMLNodeValuesExtended

originalXMLString - String
spliceNodeName - String
newNodeValues - String[]
parentNode - String

*/
result = "";

openingTag = "<" + spliceNodeName;
spliceNodeIndex = -1;
spliceStartIndex = -1;
spliceEndIndex = -1;

remaining = originalXmlString;
indexAttr = find(remaining, openingTag + " " );
if ( indexAttr == -1  ){
	indexAttr = find( remaining, openingTag + ">" );
}
if ( indexAttr <> -1){
	for newValue in newNodeValues {
		spliceNodeIndex = find(remaining, openingTag + " ");
		if ( spliceNodeIndex == -1 ){
			spliceNodeIndex = find( remaining, openingTag + ">" );
		}
		spliceStartIndex = find(remaining, ">", spliceNodeIndex) + 1;	//Add 1, because otherwise this returns the index of the ">" in e.g. <transactions class="transactions">, and actually we want the index of where the value starts
		spliceEndIndex = find(remaining, "</", spliceStartIndex);
		
		soFar = substring(remaining, 0, spliceStartIndex);

		remaining = substring(remaining, spliceEndIndex);
		
		result = result + soFar + newValue;
	}
}
else{
	for newValue in newNodeValues{
		spliceNodeIndex = find( remaining, "</" + parentNode );
		//IESCNQRCPQ-1255 (OK. 11-1-2023) Comment out below line and move it down to prevent the runtime exception error
		//spliceEndIndex = find( remaining, ">", spliceNodeIndex);
		if ( spliceNodeIndex == -1 ) {
			continue;
		}
		spliceEndIndex = find( remaining, ">", spliceNodeIndex); //IESCNQRCPQ-1255 (OK. 11-1-2023) Moved from above
		soFar = substring( remaining,0, spliceNodeIndex );
		remaining = substring( remaining, spliceEndIndex + 1 );
		result = result + soFar + openingTag + ">" + newValue + "</" + spliceNodeName + ">" + "</" + parentNode + ">";
	}
}
	
result = result + remaining;

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5144120</id><bm_lib_func_id>5144118</bm_lib_func_id><param_name><![CDATA[originalXMLString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1699521794000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValuesExtended.bm_lib_func_param_originalXMLString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5144121</id><bm_lib_func_id>5144118</bm_lib_func_id><param_name><![CDATA[spliceNodeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1699521794000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValuesExtended.bm_lib_func_param_spliceNodeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5144122</id><bm_lib_func_id>5144118</bm_lib_func_id><param_name><![CDATA[newNodeValues]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1699521794000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValuesExtended.bm_lib_func_param_newNodeValues_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5144123</id><bm_lib_func_id>5144118</bm_lib_func_id><param_name><![CDATA[parentNode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1699521794000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValuesExtended.bm_lib_func_param_parentNode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4917815</id><name><![CDATA[printInternalSection]]></name><variable_name><![CDATA[printInternalSection]]></variable_name><description><![CDATA[Prints a sub-subsection with tabbing.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4917814</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_printInternalSection]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4917814</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_printInternalSection_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435907000</date_modified><guid><![CDATA[LEGACY_4917814]]></guid><script_size>176</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> printInternalSection

description - String
tabs - Integer
*/
result = "";

tabList = range(tabs);

for t in tabList {
	result = result + "> > ";
}

result = result + description + "\n";

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4917817</id><bm_lib_func_id>4917815</bm_lib_func_id><param_name><![CDATA[description]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_printInternalSection.bm_lib_func_param_description_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4917818</id><bm_lib_func_id>4917815</bm_lib_func_id><param_name><![CDATA[tabs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_printInternalSection.bm_lib_func_param_tabs_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4896823</id><name><![CDATA[getPartFields]]></name><variable_name><![CDATA[getPartFields]]></variable_name><description><![CDATA[Populates the partFieldsDict dictionary with the values of all part custom fields. Key: <partNumber><partDelim><fieldName>. Value: <fieldValue>. Returns a dictionary with the number of parts processed, and any associated errors.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4896822</function_id><date_modified>1626948712000</date_modified><guid><![CDATA[bm_lib_func_util_getPartFields]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[partList = string[];
append(partList, "306400000000");
append(partList, "306400004000");
append(partList, "306400003100");
append(partList, "PlaceHolder4001P");

stringsDict = dict("string");

CUSTOM_FIELD_DICT = dict("string");
PO_ID = "poId";
PO_NAME = "poName";
PO_START_DATE = "poStartDate";
PO_END_DATE = "poEndDate";
PI_ITEM_TYPE = "piItemType";
USAGE_QUALIFCATION_GROUP = "usageQualificationGroup";
TERM_OF_COMMITMENT = "termOfCommitment";
EDITION = "edition";
PARAMETER_ID = "parameterId";
RAMP_FLAG = "rampFlag";
SPECIAL_WORKFLOW_FLAG = "specialWorkflowFlag";
UOM_TYPE = "uomType";
UOM_BLOCK = "uomBlock";
BUNDLE_FLAG = "bundleFlag";
PO_CATEGORY = "poCategory";
put(CUSTOM_FIELD_DICT, "custom_field1", PO_ID);
put(CUSTOM_FIELD_DICT, "custom_field2", PO_NAME);
put(CUSTOM_FIELD_DICT, "custom_field3", PO_START_DATE);
put(CUSTOM_FIELD_DICT, "custom_field4", PO_END_DATE);
put(CUSTOM_FIELD_DICT, "custom_field8", PI_ITEM_TYPE);
put(CUSTOM_FIELD_DICT, "custom_field9", USAGE_QUALIFCATION_GROUP);
put(CUSTOM_FIELD_DICT, "custom_field10", TERM_OF_COMMITMENT);
put(CUSTOM_FIELD_DICT, "custom_field11", EDITION);
put(CUSTOM_FIELD_DICT, "custom_field12", PARAMETER_ID);
put(CUSTOM_FIELD_DICT, "custom_field13", RAMP_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field14", SPECIAL_WORKFLOW_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field15", UOM_TYPE);
put(CUSTOM_FIELD_DICT, "custom_field18", UOM_BLOCK);
put(CUSTOM_FIELD_DICT, "custom_field19", BUNDLE_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field20", PO_CATEGORY);

DELIMITER = "[@.@]";

utilResultDict = util.getPartFields(partList, CUSTOM_FIELD_DICT, stringsDict, DELIMITER);

return utilResultDict;]]></main_script_text><_children><bm_function><id>4896822</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPartFields_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948712000</date_modified><guid><![CDATA[LEGACY_4896822]]></guid><script_size>687</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Function
	getPartFields
	--------------------
	Params:
		String[] partList
		StringDictionary customFieldDict
		StringDictionary partFieldsDict
		String partDelim
	Returns:
		StringDictionary resultDict
*/
debug = false;

PART_DESC = "description";

//Custom Field List: Edit this if you need to add any additional part custom fields to the query
CUSTOM_FIELD_LIST = string[] {"custom_field1", "custom_field2", "custom_field3", "custom_field4", "custom_field8", "custom_field9", "custom_field10", "custom_field11", "custom_field12", "custom_field13", "custom_field14", "custom_field15", "custom_field18", "custom_field19", "custom_field20", "custom_field21", "custom_field22", "custom_field26"};

resultDict = dict("string");
count = 0;
error = "";



//BMQL Query: Edit this if you need to add any additional part custom fields to this query
partRecords = bmql("select part_number, description, custom_field1, custom_field2, custom_field3, custom_field4, custom_field8, custom_field9, custom_field10, custom_field11, custom_field12, custom_field13, custom_field14, custom_field15, custom_field18, custom_field19, custom_field20, custom_field21, custom_field22, custom_field26 from _parts where part_number in $partList");

for partRecord in partRecords {
	partNum = get(partRecord, "part_number");
	

							   
  
	
	for field in CUSTOM_FIELD_LIST {
		customFieldKey = partNum + partDelim + get(customFieldDict, field);
		customFieldValue = get(partRecord, field);

   
		put(partFieldsDict, customFieldKey, customFieldValue);

	}
	descKey = partNum + partDelim + PART_DESC;
	descVal = get(partRecord, "description");
	put(partFieldsDict, descKey, descVal);
	

	
	count = count + 1;
}

put(resultDict, "count", string(count));
put(resultDict, "error", error);

return resultDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4896825</id><bm_lib_func_id>4896823</bm_lib_func_id><param_name><![CDATA[partList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948712000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getPartFields.bm_lib_func_param_partList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4896826</id><bm_lib_func_id>4896823</bm_lib_func_id><param_name><![CDATA[customFieldDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948712000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getPartFields.bm_lib_func_param_customFieldDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4896827</id><bm_lib_func_id>4896823</bm_lib_func_id><param_name><![CDATA[partFieldsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948712000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getPartFields.bm_lib_func_param_partFieldsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4896828</id><bm_lib_func_id>4896823</bm_lib_func_id><param_name><![CDATA[partDelim]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948712000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getPartFields.bm_lib_func_param_partDelim_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4952374</id><name><![CDATA[Get Hiding Status]]></name><variable_name><![CDATA[getHidingStatus]]></variable_name><description></description><return_type>4</return_type><func_type>1</func_type><function_id>4952373</function_id><date_modified>1626948714000</date_modified><guid><![CDATA[bm_lib_func_util_getHidingStatus]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4952373</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getHidingStatus_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948715000</date_modified><guid><![CDATA[LEGACY_4952373]]></guid><script_size>487</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util - Get Hiding Status

coreOffering - String
implementationMethod - String
serviceAttr - String
*/
availibilityArray = String[];
//BM_VT. Business unit is required as additional filter. Getting the business unit from the commerce process
ownerBusUnit = "%"+ ownerBusinessUnit +"%";
theater = "%"+ ownerTheater +"%";
market = "%"+ ownerMarket +"%";
type = "%"+ quoteType +"%";


// Add Business unit filter
recordSet = bmql("select availability from serviceCompatibility where coreOffering = $coreOffering and implementationMethod = $implementationMethod and serviceAttr = $serviceAttr and (businessUnit like $ownerBusUnit or businessUnit = '' or businessUnit is null) and (ownerTheater like $theater or ownerTheater = '' or ownerTheater is null) and (ownerMarket like $market or ownerMarket = '' or ownerMarket is null) AND (quoteType like $type or quoteType = '' or quoteType is null)");


for rec in recordSet
{
	append(availibilityArray, get(rec,"availability"));
}

if((findinarray(availibilityArray,"TRUE")>-1)) //or(isempty(availibilityArray)==True))
{
	return false;
}
else
{
	return true;
}]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4952376</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[coreOffering]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_coreOffering_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4952377</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[implementationMethod]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_implementationMethod_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4952378</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[serviceAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_serviceAttr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>50040027</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[ownerBusinessUnit]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_ownerBusinessUnit_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>50040028</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[ownerMarket]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_ownerMarket_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>50040029</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[ownerTheater]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_ownerTheater_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>50040030</id><bm_lib_func_id>4952374</bm_lib_func_id><param_name><![CDATA[quoteType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatus.bm_lib_func_param_quoteType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15731085</id><name><![CDATA[Get Line Items Info From Commerce to Config]]></name><variable_name><![CDATA[getLineItemsInfoFromCommerceToConfig]]></variable_name><description><![CDATA[Retrieves Reconfigured Line items Info from Commerce to Config.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>15731084</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getLineItemsInfoFromCommerceToConfig]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15731084</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getLineItemsInfoFromCommerceToConfig_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435936000</date_modified><guid><![CDATA[testconcur_11200829]]></guid><script_size>552</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
Get Line Items Info From Commerce to Config - UTIL LIBRARY FUNCTION 
Retreives Reconfigured line item information from commerce(with certain fields information)
Used in Configuration Rules.
*/

//Dictionary to pull commerce attribute values in config
lineItemsInfo = dict("string");

//Query To Retreive Desired Fields from Commerce
lineItems = BMQL("SELECT _document_number,coreOffering_line,_parent_doc_number,_part_number,implementationMethod_line from commerce.line_process");

//By Default ,result is set to failure.
put(lineItemsInfo ,"result","false");

//Loop through Each Line item to get reconfigured line items values
for eachLine in lineItems{
	if( selectedDocNum == get(eachLine,"_document_number")){
		put(lineItemsInfo ,"_document_number",get(eachLine,"_document_number"));	
		put(lineItemsInfo ,"coreOffering_line",get(eachLine,"coreOffering_line"));	
		put(lineItemsInfo ,"_parent_doc_number",get(eachLine,"_parent_doc_number"));		
		put(lineItemsInfo ,"_part_number",get(eachLine,"_part_number"));		
		put(lineItemsInfo ,"implementationMethod_line",get(eachLine,"implementationMethod_line"));
		put(lineItemsInfo ,"result","true");
		break;	
		}									
}
//return Line Items Information (Dictionary Type)

return lineItemsInfo;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15731086</id><bm_lib_func_id>15731085</bm_lib_func_id><param_name><![CDATA[selectedDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547406000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getLineItemsInfoFromCommerceToConfig.bm_lib_func_param_selectedDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4814646</id><name><![CDATA[getStrDict]]></name><variable_name><![CDATA[getStrDict]]></variable_name><description><![CDATA[NOT USED. Imported in Pricing script, but not used in the code.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4814644</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getStrDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4814644</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getStrDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435923000</date_modified><guid><![CDATA[LEGACY_4814644]]></guid><script_size>155</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
*/

result = defaultValue;

if ( containskey(dictionary, key) ) {
	result  = get(dictionary, key);
} 

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4814647</id><bm_lib_func_id>4814646</bm_lib_func_id><param_name><![CDATA[dictionary]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getStrDict.bm_lib_func_param_dictionary_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814648</id><bm_lib_func_id>4814646</bm_lib_func_id><param_name><![CDATA[key]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getStrDict.bm_lib_func_param_key_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4814649</id><bm_lib_func_id>4814646</bm_lib_func_id><param_name><![CDATA[defaultValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getStrDict.bm_lib_func_param_defaultValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4907725</id><name><![CDATA[calculateProductBasedPricing (NOT USED)]]></name><variable_name><![CDATA[calculateProductBasedPricing]]></variable_name><description></description><return_type>15</return_type><func_type>1</func_type><function_id>4907724</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[DELIM = "[@.@]";

//productBasedPricingData sample data
productBasedPricingData = dict("string[]");
productBasedPricingRow = string[];
append(productBasedPricingRow, "B"); //condPI1
append(productBasedPricingRow, "C"); //condPI2
append(productBasedPricingRow, "A"); //discountPI
append(productBasedPricingRow, "1000.00"); //discountVal
append(productBasedPricingRow, "FIXED_PRICE"); //discountType
append(productBasedPricingRow, "35000.00"); //listPricePI
put(productBasedPricingData, 0, productBasedPricingRow);

productBasedPricingRow = string[];
append(productBasedPricingRow, "E"); //condPI1
append(productBasedPricingRow, "F"); //condPI2
append(productBasedPricingRow, "D"); //discountPI
append(productBasedPricingRow, "12.34"); //discountVal
append(productBasedPricingRow, "PERCENT"); //discountType
append(productBasedPricingRow, "96388.00"); //listPricePI
put(productBasedPricingData, 1, productBasedPricingRow);

//modelToLineDocNumsDict sample data
modelToLineDocNumsDict = dict("string[]");
lineDocNumList = string[];
append(lineDocNumList, "3");
append(lineDocNumList, "4");
append(lineDocNumList, "5");
append(lineDocNumList, "6");
append(lineDocNumList, "7");
append(lineDocNumList, "8");
put(modelToLineDocNumsDict, "2", lineDocNumList);

//currentDocNum
currentDocNum = "3";

//stateDicts
stringsDict = dict("string");
integersDict = dict("integer");
floatsDict = dict("float");

put(stringsDict, "3[@.@]_parent_doc_number", "2");
put(stringsDict, "4[@.@]_parent_doc_number", "2");
put(stringsDict, "5[@.@]_parent_doc_number", "2");
put(stringsDict, "6[@.@]_parent_doc_number", "2");
put(stringsDict, "7[@.@]_parent_doc_number", "2");
put(stringsDict, "8[@.@]_parent_doc_number", "2");

put(stringsDict, "3[@.@]_part_number", "A");
put(stringsDict, "4[@.@]_part_number", "B");
put(stringsDict, "5[@.@]_part_number", "C");
put(stringsDict, "6[@.@]_part_number", "D");
put(stringsDict, "7[@.@]_part_number", "E");
put(stringsDict, "8[@.@]_part_number", "F");

put(floatsDict, "3[@.@]tierPrice_line", 35000.00);
put(floatsDict, "4[@.@]tierPrice_line", 2000.00);
put(floatsDict, "5[@.@]tierPrice_line", 3000.00);
put(floatsDict, "6[@.@]tierPrice_line", 96388.00);
put(floatsDict, "7[@.@]tierPrice_line", 5000.00);
put(floatsDict, "8[@.@]tierPrice_line", 6000.00);

//Call the util we are testing
utilResultDict = util.calculateProductBasedPricing(productBasedPricingData, modelToLineDocNumsDict, currentDocNum, stringsDict, integersDict, floatsDict, DELIM);

print(get(utilResultDict, "productBasedPricingUsed"));
if (containskey(utilResultDict, "error")) {
	print(get(utilResultDict, "error"));
}

return utilResultDict;]]></main_script_text><_children><bm_function><id>4907724</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_calculateProductBasedPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435918000</date_modified><guid><![CDATA[LEGACY_4907724]]></guid><script_size>9460</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	calculateProductBasedPricing
	----------------------------
	Params:
		String[]Dict piBasedProductPricingDict
		String[]Dict qtyBasedProductPricingDict
		String[]Dict modelToLineDocNumsDict
		String currentDocNum
		StringDict stringsDict
		IntegerDict integersDict
		FloatDict floatsDict
		String piDelimiter
	Returns:
		StringDict result
			productBasedDiscountUsed => true or false
			error => error message
			
	Description and Usage:
		This function is meant to be called once for each line item. For a
		given line item, it calculates the productBasedPrice_line.
*/
//Meta control variables
debug = false;
DEBUG_PREFIX = "> > > > ";

/* ======================================================================== */
/*								CONSTANTS									*/
/* ======================================================================== */
//Constants for piBasedProductPricingDict array indexes
COND_PI1 = 0;
COND_PI2 = 1;
DISC_PI = 2;
DISC_VAL = 3;
DISC_TYPE = 4;
LISTPRICE_PI = 5;

//Constants for qtyBasedProductPricingDict array indexes
Q_PI = 0;
Q_TRANS_BASED_PI = 1;
Q_QTY_BASED_PI = 2;
Q_LISTPRICE_PI = 3;
Q_PRICING_TYPE = 4;

//Constants for attribute names
PART_NUM = "_part_number";
PARENT_DOC_NUM = "_parent_doc_number";
TIER_PRICE = "tierPrice_line";
PRODUCT_BASED_PRICE = "productBasedPrice_line";
TRANSACTIONS_LABEL = "numCommittedTransaction_line";
QTY_LABEL = "_price_quantity";

//Constants for part custom field names
PI_ITEM_TYPE = "piItemType_line";
PO_ID = "poId";

//Constants for part custom field values
PRE_PRODUCTION = "Pre-Prod Fee";
BASE_FEE = "Base Fee";

//Constants for BMQL tables
FIXED_PRICE = "FIXED_PRICE";
PRE_PROD_PERCENT = "preProdPercent";
INCREMENTAL = "INCRE_FEE";
BASE = "BASE_FEE";
//Constants
HUNDRED_PERCENT = 100.0;
MAX_ARRAY_SIZE = 1000;
MAX_ARRAY_SIZE_FLOAT = 1000.00;
/* ======================================================================== */
/*								VARIABLES									*/
/* ======================================================================== */
//Result variables
result = dict("string");
error = false;
errorMsg = "";
productBasedPriceFound = false;
productBasedPrice = 0.0;

//Instance variables
isPreProductionItem = false;

if (debug) {
	print(DEBUG_PREFIX + "calculateProductBasedPricing called");
}

/* ======================================================================== */
/* 			First, get the Model associated with this line item 			*/
/* ======================================================================== */
parentDocNumKey = currentDocNum + piDelimiter + PARENT_DOC_NUM;
parentDocNum = "";
if (containskey(stringsDict, parentDocNumKey)) {
	parentDocNum = get(stringsDict, parentDocNumKey);
} else {
	//If no associated model is found for this line item, stop the script
	error = true;
	errorMsg = errorMsg + "calculateProductBasedPricing(1): could not find _parent_doc_number for docNum " + currentDocNum + "\n";
	put(result, "error", errorMsg);
	return result;
}
if (debug) {
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "FIRST: Model associated with this line item"); 
	print(DEBUG_PREFIX + "parentDocNumKey: " + parentDocNumKey);
	print(DEBUG_PREFIX + "parentDocNum: " + parentDocNum);
}

/* ======================================================================== */
/* 			Second, get the PI of this line item 							*/
/* ======================================================================== */
piKey = currentDocNum + piDelimiter + PART_NUM;
pi = "";
if (containskey(stringsDict, piKey)) {
	pi = get(stringsDict, piKey);
} else {
	//If no PI is found for the current line item, stop the script
	error = true;
	errorMsg = errorMsg + "calculateProductBasedPricing(2): could not find PI (_part_num) for docNum " + currentDocNum + " with piKey " + piKey + "\n";
	put(result, "error", errorMsg);
	return result;
}

if (debug) {
	print(DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "SECOND: Get PI of this line item");
	print(DEBUG_PREFIX + "piKey: " + piKey);
	print(DEBUG_PREFIX + "pi: " + pi);
}

/* ======================================================================== */
/*			Third, find out if it is a Pre-Production PI					*/
/* ======================================================================== */
piItemTypeKey = pi + piDelimiter + PI_ITEM_TYPE;
piItemType = "";
if (containskey(stringsDict, piItemTypeKey)) {
	piItemType = get(stringsDict, piItemTypeKey);
} else {
	error = true;
	errorMsg = errorMsg + "calculateProductBasedPricing(3): could not find PI Item Type (custom_field8) for docNum " + currentDocNum + "\n";
	put(result, "error", errorMsg);
	return result;
}

if (piItemType == PRE_PRODUCTION) {
	isPreProductionItem = true;
}

if (debug) {
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "THIRD: Get PI Item Type of this line item");
	print(DEBUG_PREFIX + "piItemTypeKey: " + piItemTypeKey);
	print(DEBUG_PREFIX + "piItemType: " + piItemType);
	print(DEBUG_PREFIX + "Control variable comparator used to determine Pre-Prod status: PRE_PRODUCTION: " + PRE_PRODUCTION);
	print(DEBUG_PREFIX + "The two values on the right must be equal if this item is a Pre-Prod Fee: " + "[" + piItemType + ", " + PRE_PRODUCTION + "]"); 
}
/* ======================================================================== */
/* 		Fourth, get dicts of:
			- line item PIs
			- line item Tier Prices under this Model
			- line item quantities
			- line item numTransactions

		If this line item is a Pre-Prod Fee, we also want to find the 
		Base Fee line item for each PO ID.
*/
/* ======================================================================== */
lineItemDocNums = string[];
if (containskey(modelToLineDocNumsDict, parentDocNum)) {
	lineItemDocNums = get(modelToLineDocNumsDict, parentDocNum);
} else {
	//If no child line item docNums are found for the current Model, stop the script
	error = true;
	errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find child docNums for parent docNum " + parentDocNum + " of docNum " + currentDocNum + "\n";
	put(result, "error", errorMsg);
	return result;
}

lineItemTierPriceDict = dict("float");
lineItemTransactionsDict = dict("integer");
lineItemQtyDict = dict("integer");
poIdToBaseFeeLineItemDocNumDict = dict("string");

for lineItemDocNum in lineItemDocNums {
	
	/* -------------------------------------------------------------------- */
	//Get the lineItemPi
	/* -------------------------------------------------------------------- */
	lineItemPiKey = lineItemDocNum + piDelimiter + PART_NUM;
	lineItemPi = "";
	if (containskey(stringsDict, lineItemPiKey)) {
		lineItemPi = get(stringsDict, lineItemPiKey);
	} else {
		//If no child line item PIs are found for the current Model, stop the script
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PI (_part_num) for childDocNum " + lineItemDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	
	/* -------------------------------------------------------------------- */
	//Get the lineItemTierPrice
	/* -------------------------------------------------------------------- */
	lineItemTierPriceKey = lineItemDocNum + piDelimiter + TIER_PRICE;
	lineItemTierPrice = 0.0;
	if (containskey(floatsDict, lineItemTierPriceKey)) {
		lineItemTierPrice = get(floatsDict, lineItemTierPriceKey);
	} else {
		//If no child line item PI tier prices are found for the current Model, stop the script
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find tierPrice_line for childDocNum " + lineItemDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	put(lineItemTierPriceDict, lineItemPi, lineItemTierPrice);
	
	/* -------------------------------------------------------------------- */
	//Get lineItemTransactions
	/* -------------------------------------------------------------------- */
	lineItemTransactionsKey = lineItemDocNum + piDelimiter + TRANSACTIONS_LABEL;
	lineItemTransactions = 0;
	if (containskey(integersDict, lineItemTransactionsKey)) {
		lineItemTransactions = get(integersDict, lineItemTransactionsKey);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find numCommittedTransactions_line for childDocNum " + lineItemDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	put(lineItemTransactionsDict, lineItemPi, lineItemTransactions);
	
	/* -------------------------------------------------------------------- */
	//Get the lineItemQty
	/* -------------------------------------------------------------------- */
	lineItemQtyKey = lineItemDocNum + piDelimiter + QTY_LABEL;
	lineItemQty = 0;
	if (containskey(integersDict, lineItemQtyKey)) {
		lineItemQty = get(integersDict, lineItemQtyKey);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find _price_quantity for childDocNum " + lineItemDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	put(lineItemQtyDict, lineItemPi, lineItemQty);
	
	/* -------------------------------------------------------------------- */
	//Get the Base Fee docNum associated with this PO ID
	/* -------------------------------------------------------------------- */
	if (isPreProductionItem) {
		//Get the PI Item Type of this line item 
		piItemTypeKey = lineItemPi + piDelimiter + PI_ITEM_TYPE;
		piItemType = "";
		if (containskey(stringsDict, piItemTypeKey)) {
			piItemType = get(stringsDict, piItemTypeKey);
			
			if (piItemType == BASE_FEE) {
				//Get the PO ID associated with this line item
				poIdKey = lineItemPi + piDelimiter + PO_ID;
				poId = "";
				if (containskey(stringsDict, poIdKey)) {
					poId = get(stringsDict, poIdKey);
					if (containskey(poIdToBaseFeeLineItemDocNumDict, poId)) {
						error = true;
						errorMsg = errorMsg + "calculateProductBasedPricing(4): duplicate PO ID detected for multiple Base Fee items! childDocNum " + lineItemDocNum + "\n";
						put(result, "error", errorMsg);
						return result;
					}
					put(poIdToBaseFeeLineItemDocNumDict, poId, lineItemDocNum);
				} else {
					error = true;
					errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PO ID for childDocNum " + lineItemDocNum + "\n";
					put(result, "error", errorMsg);
					return result;
				}
			}
		} else {
			error = true;
			errorMsg = errorMsg + "calculateProductBasedPricing(4): could not find PI Item Type for childDocNum " + lineItemDocNum + "\n";
			put(result, "error", errorMsg);
			return result;
		}
	}
}

if (debug) {
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "FOURTH:");
	print(DEBUG_PREFIX + "parentDocNum: " + parentDocNum);
	print(DEBUG_PREFIX + "List of line item docNums under this Model");
	print(DEBUG_PREFIX + "lineItemDocNums:");
	print(lineItemDocNums);
	print(DEBUG_PREFIX + "PIs of child docNums under this Model (lineItemTierPriceDict)");
	print(lineItemTierPriceDict);
	print(DEBUG_PREFIX + "lineItemTransactionsDict");
	print(lineItemTransactionsDict);
	print(DEBUG_PREFIX + "lineItemQtyDict");
	print(lineItemQtyDict);
	print(DEBUG_PREFIX + "poIdToBaseFeeLineItemDocNumDict");
	print(poIdToBaseFeeLineItemDocNumDict);
}

/* ======================================================================== */
/* 		FINALLY, calculate the product based price for this line item		*/
/* ======================================================================== */
/*
	There are four Product Based Pricing mechanisms:
	A. Pre-production Fee Calculation (miscCommerceData table):
	
		preProdFee = <preProdPercent> * <tierPrice of Core Service Base Fee>
	
	B. PI Based (productBasedDisc table):
	
		if (discountType == FIXED) {
			productBasedPrice = <discountVal>
		} else {
			productBasedPrice = <tierPrice of listPricePI> * (1 - <discountVal>/100.0)
		}
	
	C. Incremental Fee Calculation (productDepdendentPIs table):
	
		incrementalFee = <tierPrice of Core Service Usage Fee> / <numTransactions of Core Service Usage Fee>
	
	D. Qty/Trxn Based (productDependentPIs table):
	
		numQty = 1;
		if (qtyBasedPI <> "") {
			numQty = <qty of qtyBased PI>
		}
		productBasedPrice = <numTransactions of transactionBasedPI> * <numQty> * <tierPrice of listPricePI>
	
	
*/

if (debug) {
	print(DEBUG_PREFIX + "  /============================================\\");
	print(DEBUG_PREFIX + " /                                              \\");
	print(DEBUG_PREFIX + "/                                                \\");
	print(DEBUG_PREFIX + "Calculate product based price for this line item");
	print(DEBUG_PREFIX + "Loop over all conditions in the piBasedProductPricingDict dict");
}

if (isPreProductionItem) {
	if (debug) {
		print(DEBUG_PREFIX + "----------------------------");
		print(DEBUG_PREFIX + "Pre-production line item found");
	}
	/* ---------------------------------------------------------------- */
	/*	A. Pre-production Fee Calculation (miscCommerceData table)		*/
	/* ---------------------------------------------------------------- */
	
	//Obtain the PO ID of this line item
	poIdKey = pi + piDelimiter + PO_ID;
	poId = "";
	if (containskey(stringsDict, poIdKey)) {
		poId = get(stringsDict, poIdKey);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(5): could not find PO ID for docNum " + currentDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	
	//Obtain the associated Base Fee docNum
	baseFeeDocNum = "";
	if (containskey(poIdToBaseFeeLineItemDocNumDict, poId)) {
		baseFeeDocNum = get(poIdToBaseFeeLineItemDocNumDict, poId);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(5): could not find PO ID for docNum " + currentDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	
	//Obtain the associated Base Fee tierPrice
	baseFeeTierPriceKey = baseFeeDocNum + piDelimiter + TIER_PRICE;
	baseFeeTierPrice = 0.0;
	if (containskey(floatsDict, baseFeeTierPriceKey)) {
		baseFeeTierPrice = get(floatsDict, baseFeeTierPriceKey);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(5): could not find baseFeeTierPrice for baseFeeDocNum " + baseFeeDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	
	//Obtain the preProdPercent from the miscCommerceData table
	miscCommerceDataRecords = bmql("select miscDataVal from miscCommerceData where miscDataKey = $PRE_PROD_PERCENT");
	preProdPercentString = "";
	for record in miscCommerceDataRecords {
		preProdPercentString = get(record, "miscDataVal");
	}
	if (preProdPercentString == "") {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(5): preProdPercentString is empty or missing for docNum " + currentDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	preProdPercent = 0.0;
	if (isNumber(preProdPercentString)) {
		preProdPercent = atof(preProdPercentString);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(5): preProdPercentString is NOT a number! for docNum " + currentDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	
	//Calculate the productBasedPrice
	productBasedPrice = baseFeeTierPrice * (preProdPercent/HUNDRED_PERCENT);
	productBasedPriceFound = true;
	
	if (debug) {
		print(DEBUG_PREFIX + "A. Pre-production Fee Calculation");
		print(DEBUG_PREFIX + "PO ID: " + poId);
		print(DEBUG_PREFIX + "Base Fee DocNum: " + baseFeeDocNum);
		print(DEBUG_PREFIX + "baseFeeTierPrice: " + string(baseFeeTierPrice));
		print(DEBUG_PREFIX + "productBasedPriceFound: " + string(productBasedPriceFound));
		print(DEBUG_PREFIX + "productBasedPrice: " + string(productBasedPrice));
	}
	
} else {
	if (debug) {
		print(DEBUG_PREFIX + "----------------------------");
		print(DEBUG_PREFIX + "Non-Pre-production line item found");
	}
	/* --------------------------------------------------------------- */
	/*
		B. PI Based Pricing
		
		In this section, we calculate the Product Based Price of 
		non-Pre-Prod Fee type PI/line items. The Product Based Price is
		dependent on the Product Based Pricing condition found in the data
		table, if any. It is possible to NOT have a Product Based Price, in
		which case the subsequent section assigns a default (which is the
		same as the tierPrice).
	*/
	/* --------------------------------------------------------------- */
	
	/*	
		If the number of conditions we have to evaluate is larger
		than 1000, the maximum array size, we need to loop more than
		once. 
	*/
	
	piRowCount = piBasedRowCount;
	print(piRowCount/MAX_ARRAY_SIZE_FLOAT);
	numLoops = integer(ceil(piRowCount / MAX_ARRAY_SIZE_FLOAT));
	numLoopsArray = range(numLoops);
	
	index = 0;
	
	if (debug) {
		print(DEBUG_PREFIX + "piBasedRowCount:" + string(piBasedRowCount));
		print(DEBUG_PREFIX + "numLoops: " + string(numLoops));
		print(DEBUG_PREFIX + "numLoopsArray:");
		print(numLoopsArray);
	}
	
	for loop in numLoopsArray {
		if (piRowCount > MAX_ARRAY_SIZE) {
			piRowCount = piRowCount - MAX_ARRAY_SIZE;
			currentPiBasedRowCount = MAX_ARRAY_SIZE;
		} else {
			currentPiBasedRowCount = piRowCount;
		}
		
		numConditionsArray = range(currentPiBasedRowCount);
		if (debug) {
			print(DEBUG_PREFIX + "> > currentPiBasedRowCount: " + string(currentPiBasedRowCount));
			print(DEBUG_PREFIX + "> > numConditionsArray");
			print(numConditionsArray);
		}
		
		/* ----------------------------------------------------------------	*/
		/* Loop over each data table row from the productBasedDisc table.	*/
		/* ----------------------------------------------------------------	*/
		for condition in numConditionsArray {
			if (debug) {
				print("\n" + DEBUG_PREFIX + "------ Loop " + string(index) + " --------------------");
			}
			
			piBasedProductPricingCondition = get(piBasedProductPricingDict, index);
			print(DEBUG_PREFIX + DEBUG_PREFIX + "piBasedProductPricingCondition:");
			print(piBasedProductPricingCondition);
			
			discPi = piBasedProductPricingCondition[DISC_PI];
			if (debug) {
				print(DEBUG_PREFIX + "> > > > piBasedProductPricingCondition: ");
				print(DEBUG_PREFIX + "> > > > condPI1: " + piBasedProductPricingCondition[COND_PI1]);
				print(DEBUG_PREFIX + "> > > > condPI2: " + piBasedProductPricingCondition[COND_PI2]);
				print(DEBUG_PREFIX + "> > > > discountPI: " + piBasedProductPricingCondition[DISC_PI]);
				print(DEBUG_PREFIX + "> > > > discountVal: " + piBasedProductPricingCondition[DISC_VAL]);
				print(DEBUG_PREFIX + "> > > > discountType: " + piBasedProductPricingCondition[DISC_TYPE]);
				print(DEBUG_PREFIX + "> > > > listPricePI: " + piBasedProductPricingCondition[LISTPRICE_PI]);
				print(DEBUG_PREFIX + "> > > > ");
				print(DEBUG_PREFIX + "> > > > Current line item's PI: " + pi);
			}
				
			//If the PI of the current line item is the PI that is to be discounted, continue
			if (discPi == pi) {
				if (debug) {
					print(DEBUG_PREFIX + "> > > > CHECK PASSED: Current line item PI matches discountPI");
				}
				cond1 = piBasedProductPricingCondition[COND_PI1];
				cond2 = piBasedProductPricingCondition[COND_PI2];
				
				//If the current Model's child line items contain both PIs that are conditional for the product based discount
				if (containskey(lineItemTierPriceDict, cond1) and containskey(lineItemTierPriceDict, cond2)) {
					if (debug) {
						print(DEBUG_PREFIX + "> > > > CHECK PASSED: condPI1 and condPI2 are sibling line items");
					}
					discountType = piBasedProductPricingCondition[DISC_TYPE];
					
					//Then proceed to calculate the discount/productBasedPrice accordingly, based on the discountType in the data table
					if (isnumber(piBasedProductPricingCondition[DISC_VAL])) {
						discountVal = atof(piBasedProductPricingCondition[DISC_VAL]);
						productBasedPrice = 0.0;
						
						if (debug) {
							print(DEBUG_PREFIX + "> > > > discountType: " + discountType);
						}
						if (discountType == FIXED_PRICE) {
							productBasedPrice = discountVal;
							productBasedPriceFound = true;
						} else {
							listPricePi = piBasedProductPricingCondition[LISTPRICE_PI];
							if (listPricePi <> "" and containskey(lineItemTierPriceDict, listPricePi)) {
								listPricePiTierPrice = get(lineItemTierPriceDict, listPricePi);
								productBasedPrice = listPricePiTierPrice * (1 - discountVal / HUNDRED_PERCENT);
								productBasedPriceFound = true;
							} else {
								error = true;
								errorMsg = errorMsg + "calculateProductBasedPricing(5): listPricePI is empty or not present as a sibling for docNum " + currentDocNum + "\n";
								if (debug) {
									print(DEBUG_PREFIX + "> > > > listPricePI is empty or not present as a sibling for docNum " + currentDocNum);
									print(DEBUG_PREFIX + "> > > > listPricePI: " + listPricePi);
								}
							}
						}
						if (productBasedPriceFound) {
							//If a productBasedPrice is successfully found, break
							break;
						}
						if (debug) {
							print(DEBUG_PREFIX + "> > > > productBasedPriceFound: " + string(productBasedPriceFound));
							print(DEBUG_PREFIX + "> > > > productBasedPrice: " + string(productBasedPrice));
						}
					} else {
						error = true;
						errorMsg = errorMsg + "calculateProductBasedPricing(5): discountVal not a valid number for docNum " + currentDocNum + "\n";
						if (debug) {
							print(DEBUG_PREFIX + "> > > > discountVal not a valid number for docNum " + currentDocNum);
						}
					}
				}
			}
			index = index + 1;
		}
	}
	/* --------------------------------------------------------------- */
	/* 
		C. Incremental Fee Calculation and 
		D. Qty/Trxn Based pricing
	*/
	/* --------------------------------------------------------------- */
	qtyRowCount = qtyBasedRowCount;
	numLoops = integer(ceil(qtyRowCount / MAX_ARRAY_SIZE_FLOAT));
	numLoopsArray = range(numLoops);
	
	index = 0;
	
	for loop in numLoopsArray {
		if (qtyRowCount > MAX_ARRAY_SIZE) {
			qtyRowCount = qtyRowCount - MAX_ARRAY_SIZE;
			currentQtyBasedRowCount = MAX_ARRAY_SIZE;
		} else {
			currentQtyBasedRowCount = qtyRowCount;
		}
		
		numConditionsArray = range(currentQtyBasedRowCount);
		
		/* ----------------------------------------------------------------	*/
		/* Loop over each data table row from the productBasedDisc table.	*/
		/* ----------------------------------------------------------------	*/
		for condition in numConditionsArray {
			qtyBasedProductPricingCondition = get(qtyBasedProductPricingDict, index);
			
			discountPi = qtyBasedProductPricingCondition[Q_PI];
			transactionBasedPi = qtyBasedProductPricingCondition[Q_TRANS_BASED_PI];
			listPricePi = qtyBasedProductPricingCondition[Q_LISTPRICE_PI];
			//Check that the condition's discountPI is the current PI
			if (discountPi == pi) {
				qtyBasedPi = qtyBasedProductPricingCondition[Q_QTY_BASED_PI];
				listPricePi = qtyBasedProductPricingCondition[Q_LISTPRICE_PI];
				pricingType = qtyBasedProductPricingCondition[Q_PRICING_TYPE];
				
				//Check that transactionBasedPi and listPricePi are on the Model, and qtyBasedPi is on the model if qtyBasedPi is NOT blank
				if (containskey(lineItemTierPriceDict, discountPi) and ((qtyBasedPi <> "" and containskey(lineItemTierPriceDict, qtyBasedPi)) or qtyBasedPi == "") and (containskey(lineItemTierPriceDict, transactionBasedPi))) {
					numTransactions = get(lineItemTransactionsDict, transactionBasedPi);
					unmodifiedPrice = get(lineItemTierPriceDict, listPricePi);
					listTransactions = get( lineItemTransactionsDict, listPricePi );
					listPrice = unmodifiedPrice * listTransactions;
					if (pricingType == INCREMENTAL) {
						if ( numTransactions <> 0 ){
							productBasedPrice = listPrice / numTransactions;
							productBasedPriceFound = true;
						}
						break;
					} else {
						numQty = 0;
						if (qtyBasedPi <> "") {
							numQty = get(lineItemQtyDict, qtyBasedPi);
						} else {
							numQty = 1;
						}
						numTransactions = get(lineItemTransactionsDict, transactionBasedPi);
						implMethod = "";
						implKey = currentDocNum + piDelimiter + "implementationMethod_line";
						pricelistKey = "1" + piDelimiter + "priceList";
						priceList = get( stringsDict, pricelistkey );
						currencyCodeKey = "1" + piDelimiter + "currencyCode";
						currencyCode = get( stringsDict, currencyCodeKey );
						if ( containskey( stringsDict, implKey ) ){
							implMethod = get( stringsDict, implKey );
						}
					//	productBasedPrice = numTransactions * numQty * listPrice;
						tierPricingRecords = bmql("select pi, minTierQty, maxTierQty, price, implementationMethod from stdTierPricing where priceList = $priceList and currencyCode = $currencyCode and pi = $discountPi and implementationMethod = $implMethod");
						//numericalTransactions = atoi( numTransactions );
						for record in tierPricingRecords{
							min = get( record, "minTierQty" );
							max = get( record, "maxTierQty" );
							minimumVal = atoi( min );
							maximumVal = atoi(max );
							if ( numTransactions <= maximumVal AND numTransactions >= minimumVal ){
								productBasedPrice = atof(get( record, "price" ));
								break;
							}
							
						}
							
						
						//productBasedPrice = numQty * listPrice;
						productBasedPriceFound = true;
						break;
					}
				}
			}
			index = index + 1;
		}
	}
}
if (debug) {
	print(DEBUG_PREFIX + "\\                                                /");
	print(DEBUG_PREFIX + " \\                                              /");
	print(DEBUG_PREFIX + "  \\============================================/");
}

/* ======================================================================== */
/* 	Populate a default value for the productBasedPrice, if none was found	*/
/* ======================================================================== */
if (debug) {
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "productBasedPrice (BEFORE default calculation): " + string(productBasedPrice));
}
productBasedPriceKey = currentDocNum + piDelimiter + PRODUCT_BASED_PRICE;
if (productBasedPriceFound == false) {
	standardTierPriceKey = currentDocNum + piDelimiter + TIER_PRICE;
	tierPrice = 0.0;
	if (containskey(floatsDict, standardTierPriceKey)) {
		tierPrice = get(floatsDict, standardTierPriceKey);
	} else {
		error = true;
		errorMsg = errorMsg + "calculateProductBasedPricing(6): default productBasedPrice calculation - could not find tierPrice for docNum " + currentDocNum + "\n";
		put(result, "error", errorMsg);
		return result;
	}
	//If no productBasedPrice was found for this line item, give it the same value as the tierPrice
	productBasedPrice = tierPrice;
}

if (debug) {
	print(DEBUG_PREFIX + "productBasedPrice (AFTER default calculation section): " + string(productBasedPrice));
}

/* ======================================================================== */
/* 								Return variables				 			*/
/* ======================================================================== */
put(floatsDict, productBasedPriceKey, productBasedPrice);

put(result, "productBasedPricingUsed", string(productBasedPriceFound));
if (error) {
	put(result, "error", errorMsg);
}

if (debug) {
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "floatsDict ");
	print(floatsDict);
	print("\n" + DEBUG_PREFIX + "====================================");
	print(DEBUG_PREFIX + "result");
	print(result);
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4907727</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[piBasedProductPricingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_piBasedProductPricingDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907728</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[piBasedRowCount]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_piBasedRowCount_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907729</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[qtyBasedProductPricingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_qtyBasedProductPricingDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907730</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[qtyBasedRowCount]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_qtyBasedRowCount_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907731</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[modelToLineDocNumsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_modelToLineDocNumsDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907732</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[currentDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_currentDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4908107</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547402000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4963738</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1508547402000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4964861</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547402000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4964862</id><bm_lib_func_id>4907725</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_calculateProductBasedPricing.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>170672288</id><name><![CDATA[Build Selected Promotion Descriptions]]></name><variable_name><![CDATA[buildSelectedPromotionDescriptions]]></variable_name><description><![CDATA[For CSYS-47375. Used in Auto update script and default functioon for selectedPromos_quote HTML attribute.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>170672287</function_id><date_modified>1523577923000</date_modified><guid><![CDATA[bm_lib_func_util_buildSelectedPromotionDescriptions]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>170672287</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_buildSelectedPromotionDescriptions_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435939000</date_modified><guid><![CDATA[0ad68293-86e3-447a-bd91-f78174d9566b]]></guid><script_size>1166</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//For CSYS-47375 KA 8-11-2015. Short promo descriptions displayed next selected promotions.
//Takes Parameters: externalPromotion

promoStr = "";
if(externalPromotion <> ""){ //1 or more promos are selected
	QUOTE_DOC_NUM = "1";
	INTERNAL_NAME = "INTERNAL_NAME";
	promoArray = split(externalPromotion, "~"); //Array of all selected promos
	applicablePromoList = split(applicablePromotions, "#^#"); 
	
	promoDescArray = string[];
	rez = bmql("SELECT description, promotionCode FROM PromoMessage WHERE descriptionType = $INTERNAL_NAME AND promotionCode in $promoArray");
	for entry in rez{
		promoCode = get(entry, "promotionCode");
		shortDesc = get(entry, "description");
		if(findinarray(applicablePromoList, promoCode) <> -1){ //if the selected promo is found in the applicable promo list
			append(promoDescArray, "<b>" + promoCode + "</b>" + " - " + shortDesc); //add it to the list of selected promos with description
		}
		else{ //tell the user to deselect the promo or add back the product it applies to
			append(promoDescArray, "<font color='red'><b>" + promoCode + "</b>" + " - " + "Please deselect this promo and re-save the quote, or re-add the product it applies to." + "</font>"); 
		}
	}
	//CSYS-77513
	invalidPromoCombosArray = string[];
	rez2 = bmql("Select NotAllowedCombi, PromoName from RestrictedPromoCombi where PromoName IN $promoArray");
	validPromo = "";
	invalidPromo = "";
	for record in rez2{
		validPromo = get(record,"PromoName");
		invalidPromo = get(record,"NotAllowedCombi");
		if(invalidPromo <> "" AND validPromo <> ""){
			if(findinarray(promoArray, invalidPromo) > -1){
				
				if ((findinarray(invalidPromoCombosArray,validPromo + " & " + invalidPromo) == -1) AND (findinarray(invalidPromoCombosArray,invalidPromo + " & " + validPromo) == -1)){
					append(invalidPromoCombosArray, validPromo + " & " + invalidPromo);
				}
			}
		}
	}
	
	promoStr = "";
	for promo in promoDescArray{
		promoStr = promoStr + promo + "<br/>";
	}
	
	//CSYS-77513
	if (sizeofarray( invalidPromoCombosArray ) >= 1){
		promoStr = promoStr + "<font color='red'><b>" + "Invalid Promo Combinations: " + "</b>" + "</font>" + "<br/>";
		for invalidCombo in invalidPromoCombosArray{
			promoStr = promoStr + invalidCombo + "<br/>";
		}
	}
}



return promoStr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>170672289</id><bm_lib_func_id>170672288</bm_lib_func_id><param_name><![CDATA[externalPromotion]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1523577923000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_buildSelectedPromotionDescriptions.bm_lib_func_param_externalPromotion_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>184720082</id><bm_lib_func_id>170672288</bm_lib_func_id><param_name><![CDATA[applicablePromotions]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1523577923000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_buildSelectedPromotionDescriptions.bm_lib_func_param_applicablePromotions_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>562317834</id><name><![CDATA[isDigitalCommerceTransaction?]]></name><variable_name><![CDATA[isDigitalCommerceTransaction]]></variable_name><description></description><return_type>4</return_type><func_type>1</func_type><function_id>562317833</function_id><date_modified>1536204883000</date_modified><guid><![CDATA[bm_lib_func_util_isDigitalCommerceTransaction]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>562317833</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isDigitalCommerceTransaction_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435945000</date_modified><guid><![CDATA[e77fae58-0e8d-4547-b80b-7b07b6cdd9f3]]></guid><script_size>81</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//util.isDigitalCommerceTransaction(String)
if (userName == "hybris"){
	return true;
}
return false;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>562317836</id><bm_lib_func_id>562317834</bm_lib_func_id><param_name><![CDATA[userName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1536204883000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_isDigitalCommerceTransaction.bm_lib_func_param_userName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5030083</id><name><![CDATA[calculatePromotion]]></name><variable_name><![CDATA[calculatePromotion]]></variable_name><description></description><return_type>15</return_type><func_type>1</func_type><function_id>5030082</function_id><date_modified>1665049088000</date_modified><guid><![CDATA[bm_lib_func_util_calculatePromotion]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5030082</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_calculatePromotion_1]]></java_class_name><child_class_names></child_class_names><date_modified>1665049088000</date_modified><guid><![CDATA[LEGACY_5030082]]></guid><script_size>8983</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//calculatePromotion
// promotionsDataDict
// Key: promoCode + "@.@" + pi
// Value: requiredPO + "@.@" + businessUnit + "@.@" + market + "@.@" + accountSegment + "@.@" + revenueGroup + "@.@" + region + "@.@" + coreOffering + "@.@" + implementationMethod + "@.@" + customerType + "@.@" + quoteType + "@.@" + serviceModel + "@.@" + autoApply + "@.@" + startDate + "@.@" + endDate + "@.@" + promotionCategory + "@.@" + promoType + "@.@" + promoValue + "@.@" + addlDiscDisAllowed + "@.@" +  promoStartPeriod + "@.@" + promoEndPeriod + "@.@" + ownerTheater + "@.@" + ownerTeam + "@.@" + accountVertical

resultsDict = dict("string");
// Constants
CORE_OFFERING = "coreOffering_line"; //added by KA for CSYS-49056
PARENT_DOC_NUM = "_parent_doc_number"; //added by KA for CSYS-77853
QUOTE_DOC_NUM = "1";
PART_NUM = "_part_number";
DELIMITER = "@.@"; // same delimiter as used in pricing
ACCOUNT_REGION = "ownerRegion_quote";
BUSINESS_UNIT = "ownerBU_quote";
ACCOUNT_SEGMENT = "segment_quote";
MARKET_HEADER = "ownerMarket_quote";
QUOTE_TYPE = "quoteType_quote";
REVENUE_GROUP = "ownerRevenueGroup_quote";
CUSTOMER_TYPE = "customerType_quote";
CONVERSION_RATE = "conversionRate_quote";
IMPLEMENTATION_METHOD = "implementationMethod_line";
LIST_PRICE = "listPrice_line";
EXT_LIST_PRICE = "extendedList_line";
NET_PRICE = "netPriceEach_line";
EXT_NET_PRICE = "extendedNetPrice_line";
PROMO_CODE = "promotionCode_line";
PROMO_DISC_PERCENT = "promoDiscPercent_line";
PROMO_PRICE = "promoPrice_line";
PROMO_DETAILS = "promotionDetails_line";
PROMO_DETAILS_STR = "promotionDetailsStr_line";
ADDL_DISC_DISALLOWED = "addlDiscDisallowed_line";
NET_PRICE_NON_UNIFIED = "netPriceNonUnified_line";
EXT_NET_PRICE_NON_UNIFIED = "extNetPriceNonUnified_line";
//THEATER = "ownerTheater_quote";
//OWNER_TEAM = "ownerTeam_quote";
//ACCOUNT_VERTICAL = "accountVertical_quote";
LIST_PRICE_NON_UNIFIED = "listPriceNonUnified_line";
EXT_LIST_PRICE_NON_UNIFIED = "extListPriceNonUnified_line";

HUNDRED_PERCENT = 100.0;

// Variables
parentDocNum = "";
pi = "";
region = "";
businessUnit = "";
segment = "";
market = "";
revenueGroup = "";
customerType = "";
quoteType = "";
implementationMethod = "";
conversionRate = 1.0;
listPrice = 0.0;
netPriceEach = 0.0;
extListPrice = 0.0;
extNetPrice = 0.0;
timeBasedPromoXml = "";
timeBasedPromoString = "";
extNetPriceNonUnified = 0.0;
skipCoreLine = "FALSE";
skipExtSvcLine = "FALSE";
itemType = "";  //CSYS-107087 (OK. 20-09-2022)
quoteCurrency = "";  //CSYS-107087 (OK. 20-09-2022)

// Get the parentDocNum
parentDocNumKey = lineDocNum + DELIMITER + PARENT_DOC_NUM;
if(containskey(stringsDict, parentDocNumKey)) {
	parentDocNum = get(stringsDict, parentDocNumKey);
}

// Get the region
regionKey = QUOTE_DOC_NUM + DELIMITER + ACCOUNT_REGION;
if(containskey(stringsDict, regionKey)) {
	region = get(stringsDict, regionKey);
}
// Get the business unit
businessUnitKey = QUOTE_DOC_NUM + DELIMITER + BUSINESS_UNIT;
if(containskey(stringsDict, businessUnitKey)) {
	businessUnit = get(stringsDict, businessUnitKey);
}
// Get the account segment
segmentKey = QUOTE_DOC_NUM + DELIMITER + ACCOUNT_SEGMENT;
if(containskey(stringsDict, segmentKey)) {
	segment = get(stringsDict, segmentKey);
}
// Get the market
marketKey = QUOTE_DOC_NUM + DELIMITER + MARKET_HEADER;
if(containskey(stringsDict, marketKey)) {
	market = get(stringsDict, marketKey);
}
// Get the revenue group
revenueGroupKey = QUOTE_DOC_NUM + DELIMITER + REVENUE_GROUP;
if(containskey(stringsDict, revenueGroupKey)) {
	revenueGroup = get(stringsDict, revenueGroupKey);
}
// Get the customer type
customerTypeKey = QUOTE_DOC_NUM + DELIMITER + CUSTOMER_TYPE;
if(containskey(stringsDict, customerTypeKey)) {
	customerType = get(stringsDict, customerTypeKey);
}
// Get the quote type
quoteTypeKey = QUOTE_DOC_NUM + DELIMITER + QUOTE_TYPE;
if(containskey(stringsDict, quoteTypeKey)) {
	quoteType = get(stringsDict, quoteTypeKey);
}

// Get the pi correspoding to the given document number
piKey = lineDocNum + DELIMITER + PART_NUM;
if(containskey(stringsDict, piKey)) {
	pi = get(stringsDict, piKey);
}
// Get the implementationMethod correspoding to the given document number
implMethodKey = lineDocNum + DELIMITER + IMPLEMENTATION_METHOD;
if(containskey(stringsDict, implMethodKey)) {
	implementationMethod = get(stringsDict, implMethodKey);
}
// Get the listPrice correspoding to the given document number
listPriceKey = lineDocNum + DELIMITER + LIST_PRICE_NON_UNIFIED;
if(containskey(floatsDict, listPriceKey)) {
	listPrice = get(floatsDict, listPriceKey);
}
// Get the extended listPrice correspoding to the given document number
extListPriceKey = lineDocNum + DELIMITER + EXT_LIST_PRICE_NON_UNIFIED;
if(containskey(floatsDict, extListPriceKey)) {
	extListPrice = get(floatsDict, extListPriceKey);
}
// Get the netPriceEach correspoding to the given document number
netPriceKey = lineDocNum + DELIMITER + NET_PRICE;
if(containskey(floatsDict, netPriceKey)) {
	netPriceEach = get(floatsDict, netPriceKey);
}
// Get the listPrice correspoding to the given document number
extNetPriceKey = lineDocNum + DELIMITER + EXT_NET_PRICE;
if(containskey(floatsDict, extNetPriceKey)) {
	extNetPrice = get(floatsDict, extNetPriceKey);
}
// Get the conversion rate
conversionRateKey = QUOTE_DOC_NUM + DELIMITER + EXT_NET_PRICE;
if(containskey(floatsDict, conversionRateKey)) {
	conversionRate = get(floatsDict, conversionRateKey);
}
// Get the netPriceEach correspoding to the given document number
netPriceNonUnifiedKey = lineDocNum + DELIMITER + NET_PRICE_NON_UNIFIED;
netPriceEaNonUnified = 0.0;
if(containskey(floatsDict, netPriceNonUnifiedKey)) {
	netPriceEaNonUnified = get(floatsDict, netPriceNonUnifiedKey);
}
// Get the listPrice correspoding to the given document number
extNetPriceNonUnifiedKey = lineDocNum + DELIMITER + EXT_NET_PRICE_NON_UNIFIED;
if(containskey(floatsDict, extNetPriceNonUnifiedKey)) {
	extNetPriceNonUnified = get(floatsDict, extNetPriceNonUnifiedKey);
}
//CSYS-88388 - Start
skipCoreKey = lineDocNum + DELIMITER + "skipCoreService";
if(containskey(stringsDict, skipCoreKey)) {
	skipCoreLine = get(stringsDict, skipCoreKey);
}

skipExtSvcKey = lineDocNum + DELIMITER + "skipExtendedService";
if(containskey(stringsDict, skipExtSvcKey)) {
	skipExtSvcLine = get(stringsDict, skipExtSvcKey);
}
//CSYS-88388 - End

//CSYS-95048
isExtServiceBundled = "false";
if(containskey(stringsDict, lineDocNum + DELIMITER + "isExtServiceBundled")) {
	isExtServiceBundled = get(stringsDict, lineDocNum + DELIMITER + "isExtServiceBundled");
}

//CSYS-107087 (OK. 20-09-2022) Start - Pulling data from pricing
if(containskey(stringsDict, lineDocNum + DELIMITER + "piItemType_line")) {
	itemType = get(stringsDict, lineDocNum + DELIMITER + "piItemType_line");
}

if(containskey(stringsDict, lineDocNum + DELIMITER + "quoteCurrency_quote")) {
	quoteCurrency = get(stringsDict, lineDocNum + DELIMITER + "quoteCurrency_quote");
}
//CSYS-107087 - End

//CSYS-99331, Phil S, 05/21/2020, consolidate BMI logic for promotion with extended service is bundled
//for future promotion codes that compatible with extended service, please add promo codes to "PromoBundleComp" data table.
promoBundleExtServComp ="";
if(containskey(stringsDict, "promoBundleExtServComp_quote")) {
	
	promoBundleExtServComp = get(stringsDict, "promoBundleExtServComp_quote");
}
promoBundleExtServComp = get(stringsDict, "promoBundleExtServComp_quote");
validBundlePromos = split(promoBundleExtServComp,",");



appliedPromoTypeArr = String[];
totalDiscountedList = listPrice;
totalDiscountedNonUnified = netPriceEaNonUnified;

for promoCodeApplied in promoCodeAppliedList {
	
	// Form the promotionsDataDict key
	promoDataKey = promoCodeApplied + DELIMITER + pi;
	promoValueArr = string[];
	count = 1;
	internalDesc = "";
	if(containskey(tempPromoCodeAppliedDict, promoCodeApplied)){
		internalDesc = get(tempPromoCodeAppliedDict, promoCodeApplied);
	}
	
	if(containskey(promotionsDataDict, promoDataKey)) {
		promoValueArr = get(promotionsDataDict, promoDataKey);
		for promoValue in promoValueArr {
			
			promoValueData = split(promoValue, DELIMITER);
			
			//product must reside in a core that the promo is applicable to. Added next if statement for CSYS-49056. KA. 7-30-2015.
			//core action code must be assessed if applicable. Added on to the next if statement for CSYS- 77853. KA. 3.6.2017.
			if( (promoValueData[6] == "" OR get(stringsDict, lineDocNum + DELIMITER + CORE_OFFERING) == promoValueData[6]) AND
				(promoValueData[23] == "" OR get(stringsDict, parentDocNum + DELIMITER + "coreActionCode") == promoValueData[23]) ){ 
				promoType = promoValueData[15];
				promoVal = promoValueData[16];

				
				addlDiscDisallowed = promoValueData[17];
				
				if ( findinarray(appliedPromoTypeArr, promoValueData[14]) <> -1 ){
					
					continue;
				}
				//CSYS-88388 - Start
				if ((skipExtSvcLine == promoValueData[24]) OR (skipCoreLine == promoValueData[25])){
					
					continue;
				}
				//CSYS-88388 - End
				//CSYS-95048
				if ( promoCodeApplied <> "" AND NOT isnull(promoCodeApplied) AND findinarray(validBundlePromos, promoCodeApplied) == -1 AND isExtServiceBundled == "true"){
					if (NOT containskey(stringsDict, QUOTE_DOC_NUM + DELIMITER + "displayExtServiceBundledMsg")){
						utilResultFlag = util.putStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, "displayExtServiceBundledMsg", "true" );
					}
					continue;
				}
				
				
				
				// Standard Promotions -> Promo Start Period will be 0 and End Period will be 0 
				if(promoValueData[18] == "0" AND /*promoValueData[19] == "0"*/ promoValueData[19] == "and beyond" ) { //this line modified for CSYS-69600. KA. 12-7-2016.
					
					if((len(promoValueData[1]) == 0 OR promoValueData[1] == businessUnit) AND (len(promoValueData[2]) == 0 OR promoValueData[2] == market) AND (len(promoValueData[3]) == 0 OR promoValueData[3] == segment) AND (len(promoValueData[4]) == 0 OR promoValueData[4] == revenueGroup) AND (len(promoValueData[5]) == 0 OR promoValueData[5] == region) AND (len(promoValueData[7]) == 0 OR promoValueData[7] == implementationMethod) AND (len(promoValueData[8]) == 0 OR promoValueData[8] == customerType) AND (len(promoValueData[9]) == 0 OR promoValueData[9] == quoteType)) {
						
						if(promoType == "%") {
							promoDiscPerc = atof(promoVal);
							//promoPrice = round(listPrice * promoDiscPerc/HUNDRED_PERCENT, 2);
							promoPrice = totalDiscountedList * promoDiscPerc/HUNDRED_PERCENT;
							totalDiscountedList = totalDiscountedList - promoPrice;
							//promoPriceNonUnified = round(netPriceEaNonUnified * promoDiscPerc/HUNDRED_PERCENT, 2);
							promoPriceNonUnified = totalDiscountedNonUnified * promoDiscPerc/HUNDRED_PERCENT;
							totalDiscountedNonUnified = totalDiscountedNonUnified - promoPriceNonUnified;
						} elif(promoType == "$") {
							promoPrice = atof(promoVal);
							promoPriceNonUnified = atof(promoVal);
							if ( totalDiscountedList <> 0 ){
								promoDiscPerc = round((totalDiscountedList - promoPrice)/totalDiscountedList * HUNDRED_PERCENT, 2);
							}
							else{
								promoDiscPerc = 0.0;
							}
							totalDiscountedList = totalDiscountedList - promoPrice;
							totalDiscountedNonUnified = totalDiscountedNonUnified - promoPriceNonUnified;
						}
						
						promoPrice = listPrice - totalDiscountedList;
						promoPriceNonUnified = netPriceEaNonUnified - totalDiscountedNonUnified;
						//promoDiscPerc = (listPrice - promoPrice)/listPrice * HUNDRED_PERCENT;
						if ( listPrice <> 0 ){
							promoDiscPerc = promoPrice/listPrice * HUNDRED_PERCENT;
						}
						elif (itemType ==  "Setup" AND quoteCurrency <> "USD" AND listPrice == 0) { //CSYS-107087 (OK. 20-09-2022) Added elif condition to fix the issue with Non-USD CIP quote
							promoDiscPerc = promoDiscPerc;
						}
						else{
							promoDiscPerc = 0.0;
						}
						// If additional Discount Disallowed = "LINE"  OR "QUOTE" in the data table, just apply the promoPrice as netPriceEach
						if(promoValueData[17] == "LINE" OR promoValueData[17] == "QUOTE") {
							extNetPrice = extListPrice - (extListPrice * promoDiscPerc/HUNDRED_PERCENT);
							extNetPriceNonUnified = extNetPriceNonUnified - (extNetPriceNonUnified * promoDiscPerc/HUNDRED_PERCENT);
							netPriceEach = listPrice - promoPrice;
							netPriceEaNonUnified = netPriceEaNonUnified - promoPriceNonUnified;
							put(floatsDict, netPriceKey, netPriceEach);
							put(floatsDict, extNetPriceKey, extNetPrice);
							put(floatsDict, netPriceNonUnifiedKey, netPriceEaNonUnified);
							put(floatsDict, extNetPriceNonUnifiedKey, extNetPriceNonUnified);
						} else { // Otherwise, get the netPriceEach and apply the promoDiscount on top of it
							netPriceEach = netPriceEach - (netPriceEach * promoDiscPerc/HUNDRED_PERCENT);
							extNetPrice = extNetPrice - (extNetPrice * promoDiscPerc/HUNDRED_PERCENT);
							netPriceEaNonUnified = netPriceEaNonUnified - (netPriceEaNonUnified * promoDiscPerc/HUNDRED_PERCENT);
							extNetPriceNonUnified = extNetPriceNonUnified - (extNetPriceNonUnified * promoDiscPerc/HUNDRED_PERCENT);
							put(floatsDict, netPriceKey, netPriceEach);
							put(floatsDict, extNetPriceKey, extNetPrice);
							put(floatsDict, netPriceNonUnifiedKey, netPriceEaNonUnified);
							put(floatsDict, extNetPriceNonUnifiedKey, extNetPriceNonUnified);
						}
						put(floatsDict, lineDocNum + DELIMITER + PROMO_DISC_PERCENT, promoDiscPerc);
						put(floatsDict, lineDocNum + DELIMITER + PROMO_PRICE, netPriceEach);
						// Modified by lawrence fodge for use in calculateUnifiedPricing
						
						put( floatsDict, lineDocNum + DELIMITER + "promotionPriceAppliedToList", promoPrice );
						put( floatsDict, lineDocNum + DELIMITER + "extPromotionPriceAppliedToList", (extListPrice * promoDiscPerc/HUNDRED_PERCENT));
						append( appliedPromoTypeArr, promoValueData[14] );
				
						if ( containskey( stringsDict, lineDocNum + DELIMITER + PROMO_CODE ) AND get( stringsDict, lineDocNum + DELIMITER + PROMO_CODE ) <> "" ){
							dictPromoCode = get( stringsDict, lineDocNum + DELIMITER + PROMO_CODE );
							dictPromoCode = dictPromoCode + "," + promoCodeApplied;
							put(stringsDict, lineDocNum + DELIMITER + PROMO_CODE, dictPromoCode);
						}
						else{
							put(stringsDict, lineDocNum + DELIMITER + PROMO_CODE, promoCodeApplied);
						}
					}
				} else { // Time-based promotions
					if((len(promoValueData[1]) == 0 OR promoValueData[1] == businessUnit) AND (len(promoValueData[2]) == 0 OR promoValueData[2] == market) AND (len(promoValueData[3]) == 0 OR promoValueData[3] == segment) AND (len(promoValueData[4]) == 0 OR promoValueData[4] == revenueGroup) AND (len(promoValueData[5]) == 0 OR promoValueData[5] == region) AND (len(promoValueData[7]) == 0 OR promoValueData[7] == implementationMethod) AND (len(promoValueData[8]) == 0 OR promoValueData[8] == customerType) AND (len(promoValueData[9]) == 0 OR promoValueData[9] == quoteType)) {
						tempTotalDiscountedList = 0.0;
						if(promoType == "%") {					
							promoDiscPerc = atof(promoVal);
							//promoPrice = round(listPrice * promoDiscPerc/HUNDRED_PERCENT, 2);
							promoPrice = totalDiscountedList * promoDiscPerc/HUNDRED_PERCENT;
							
							tempTotalDiscountedList = totalDiscountedList - promoPrice;
							//promoPriceNonUnified = round(netPriceEaNonUnified * promoDiscPerc/HUNDRED_PERCENT, 2);
							promoPriceNonUnified = totalDiscountedNonUnified * promoDiscPerc/HUNDRED_PERCENT;
							totalDiscountedNonUnified = totalDiscountedNonUnified - promoPriceNonUnified;
							
						} elif(promoType == "$") {
							promoPrice = atof(promoVal);
							promoPriceNonUnified = atof(promoVal);
							if ( totalDiscountedList <> 0 ){
								promoDiscPerc = round((totalDiscountedList - promoPrice)/totalDiscountedList * HUNDRED_PERCENT, 2);
							}
							else{
								promoDiscPerc = 0.0;
							}
							tempTotalDiscountedList = totalDiscountedList - promoPrice;
							totalDiscountedNonUnified = totalDiscountedNonUnified - promoPriceNonUnified;
						}
						
						promoPrice = listPrice - tempTotalDiscountedList;
						promoPriceNonUnified = netPriceEaNonUnified - totalDiscountedNonUnified;
						//rbr case 87124
						/*if ( listPrice <> 0 ){
							promoDiscPerc = promoPrice/listPrice * HUNDRED_PERCENT;
						}
						else{
							promoDiscPerc = 0.0;
						// }*/
						// Form the time-based promotion details in xml format
						// start promotion period#^#end promotion period#^#promo discount %#^#promo price$^$...
						if(count == 1) {
							timeBasedPromoXml = timeBasedPromoXml  + "<promoDetails>";
						}
						timeBasedPromoXml = timeBasedPromoXml + "<promo promoID='" + string(count) + "'>" + 
												"<code>" +  promoCodeApplied + "</code>" + 
												"<beginPeriod>" + promoValueData[18] + "</beginPeriod>" + 
												"<endPeriod>" + promoValueData[19] + "</endPeriod>" + 
												"<discPercent>" + string(promoDiscPerc) + "</discPercent>" + 
												"<price>" + string(listPrice - promoPrice) + "</price>" +
												"<INTERNAL_NAME>" + internalDesc + "</INTERNAL_NAME>" +
												"</promo>";
						
						// Form the time-based promotion details string
						// start promotion period#^#end promotion period#^#promo discount %#^#promo price$^$...
						// added promoValueData[14] for CSYS-71065. KA. 11-1-2016.
						timeBasedPromoString = timeBasedPromoString + promoValueData[14] + "#^#" + promoValueData[18] + "#^#" + promoValueData[19] + "#^#" + string(promoDiscPerc) + "#^#" + formatascurrency(((listPrice - promoPrice) * conversionRate)) + "$^$";
						
						
						if(promoValueData[19] == "and beyond") { // last partition of time-based promotion has "and beyond" in the data table
							// If additional Discount Disallowed = "LINE"  OR "QUOTE" in the data table, just apply the promoPrice as netPriceEach
							
							totalDiscountedList = tempTotalDiscountedList;
							if(promoValueData[17] == "LINE" OR promoValueData[17] == "QUOTE") {
								extNetPrice = extListPrice - (extListPrice * promoDiscPerc/HUNDRED_PERCENT);
								extNetPriceNonUnified = extNetPriceNonUnified - (extNetPriceNonUnified * promoDiscPerc/HUNDRED_PERCENT);
								netPriceEach = listPrice - promoPrice;
								netPriceEaNonUnified = netPriceEaNonUnified - promoPriceNonUnified;
								put(floatsDict, netPriceKey, netPriceEach);
								put(floatsDict, extNetPriceKey, extNetPrice);
								put(floatsDict, netPriceNonUnifiedKey, netPriceEaNonUnified);
								put(floatsDict, extNetPriceNonUnifiedKey, extNetPriceNonUnified);
							} else { // Otherwise, get the netPriceEach and apply the promoDiscount on top of it
								netPriceEach = netPriceEach - (netPriceEach * promoDiscPerc/HUNDRED_PERCENT);
								extNetPrice = extNetPrice - (extNetPrice * promoDiscPerc/HUNDRED_PERCENT);
								netPriceEaNonUnified = netPriceEaNonUnified - (netPriceEaNonUnified * promoDiscPerc/HUNDRED_PERCENT);
								extNetPriceNonUnified = extNetPriceNonUnified - (extNetPriceNonUnified * promoDiscPerc/HUNDRED_PERCENT);
								
								put(floatsDict, netPriceKey, netPriceEach);
								put(floatsDict, extNetPriceKey, extNetPrice);
								put(floatsDict, netPriceNonUnifiedKey, netPriceEaNonUnified);
								put(floatsDict, extNetPriceNonUnifiedKey, extNetPriceNonUnified);
							}
								// Modified by lawrence fodge for use in calculateUnifiedPricing
								// Modified by lawrence fodge for use in calculateUnifiedPricing
							
							put( floatsDict, lineDocNum + DELIMITER + "promotionPriceAppliedToList", promoPrice );
							put( floatsDict, lineDocNum + DELIMITER + "extPromotionPriceAppliedToList", (extListPrice * promoDiscPerc/HUNDRED_PERCENT));
							timeBasedPromoXml = timeBasedPromoXml  + "</promoDetails>";
							//Commenting the next line out for CSYS-69600. KA. 12-7-2016.
							//put(floatsDict, lineDocNum + DELIMITER + PROMO_DISC_PERCENT, promoDiscPerc); 
							//^^^Time based promos should never update promoDiscPercent_line.
							
							put(floatsDict, lineDocNum + DELIMITER + PROMO_PRICE, netPriceEach);
							put(floatsDict, lineDocNum + DELIMITER + NET_PRICE_NON_UNIFIED, promoPrice);
							if ( containskey( stringsDict, lineDocNum + DELIMITER + PROMO_CODE ) AND get( stringsDict, lineDocNum + DELIMITER + PROMO_CODE ) <> "" ){
								dictPromoCode = get( stringsDict, lineDocNum + DELIMITER + PROMO_CODE );
								dictPromoCode = dictPromoCode + "," + promoCodeApplied;
								put(stringsDict, lineDocNum + DELIMITER + PROMO_CODE, dictPromoCode);
							}
							else{
								put(stringsDict, lineDocNum + DELIMITER + PROMO_CODE, promoCodeApplied);
							}
							put(stringsDict, lineDocNum + DELIMITER + PROMO_DETAILS_STR, timeBasedPromoString);
							put(stringsDict, lineDocNum + DELIMITER + PROMO_DETAILS, timeBasedPromoXml);
							append( appliedPromoTypeArr, promoValueData[14] );
						}
						count = count + 1;
					}
					
				}
				if(addlDiscDisallowed == "QUOTE" OR addlDiscDisallowed == "LINE") {
					put(stringsDict, lineDocNum + DELIMITER + ADDL_DISC_DISALLOWED, "true");
				} else {
					put(stringsDict, lineDocNum + DELIMITER + ADDL_DISC_DISALLOWED, "false");
				}
			}
		}
	}
  
}
return resultsDict;]]></script_text><_children><bm_lib_func_assoc><id>653319959</id><caller_func_id>5030082</caller_func_id><called_lib_func_id>4906081</called_lib_func_id><rule_area><![CDATA[calculatePromotion]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1665049088000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[525decb9-3d16-4129-9b35-33dcd6035886]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>5030085</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[promotionsDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1665049088000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_promotionsDataDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030086</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[promoCodeAppliedList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1665049088000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_promoCodeAppliedList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030087</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[lineDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1665049088000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_lineDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030088</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1665049088000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030089</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1665049088000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030090</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1665049088000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722957</id><bm_lib_func_id>5030083</bm_lib_func_id><param_name><![CDATA[tempPromoCodeAppliedDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1665049088000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_calculatePromotion.bm_lib_func_param_tempPromoCodeAppliedDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5021150</id><name><![CDATA[processTierPricingWorksheet]]></name><variable_name><![CDATA[processTierPricingWorksheet]]></variable_name><description><![CDATA[NOT USED. *** Remove after tier pricing stabalized ***]]></description><return_type>1</return_type><func_type>1</func_type><function_id>5021149</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_processTierPricingWorksheet]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[return util.processTierPricingWorksheet("");]]></main_script_text><_children><bm_function><id>5021149</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_processTierPricingWorksheet_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435909000</date_modified><guid><![CDATA[LEGACY_5021149]]></guid><script_size>3806</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Split String */
PI_INDEX = 2;
ZEROTIER_INDEX = 7;
str1 = "PO ID-NA,PO Name,PI ID,PI Name,Item Type,Edition,Impl Method,Per Quantity,Per Hour,One Time Setup,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000###36411700,12 Week Test Entity ,364117003100,12 Week Test Entity ,Setup Fee,,,,,4500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411500,Add Cash Advance ,364115003100,Add Cash Advance ,Setup Fee,,,,,1500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU2,Add Expense Pay  NA Post Initial Implementation ,NEWSKU23100,Add Expense Pay  NA Post Initial Implementation ,Setup Fee,,,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Add Invoice ACH Payments Post Initial Implementation Setup,364220003100,Add Invoice ACH Payments Post Initial Implementation Setup,Setup Fee,,,,,2000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36424000,Add New PNR Mapping Template,364240003100,Add New PNR Mapping Template,Setup Fee,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36425000,Add New Profile Template,364250003100,Add New Profile Template,Setup Fee,,,3600.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411200,Add Travel Allowance Configuration - Custom Import,364112003100,Add Travel Allowance Configuration - Custom Import,Setup Fee,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411300,Add Travel Allowance Configuration - US GSA Import,364113003100,Add Travel Allowance Configuration - US GSA Import,Setup Fee,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411600,Add Travel Request ,364116003100,Add Travel Request ,Setup Fee,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422600,Additional Country/Configuration Setup,364226003100,Additional Country/Configuration Setup,Setup Fee,,,3000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51422000,Additional Multi Country Expense Configuration ,514220003100,Additional Multi Country Expense Configuration ,Setup Fee,,,30000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36419000,Additional Policy Creation,364190003100,Additional Policy Creation,Setup Fee,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51421000,Additional Single Country Expense Configuration ,514210003100,Additional Single Country Expense Configuration ,Setup Fee,,,18000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36418000,Additional Supported Corporate Card Feed,364180003100,Additional Supported Corporate Card Feed,Setup Fee,,,,,3000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###31700000,Additional VAT Configuration,317000003100,Additional VAT Configuration,Setup Fee,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###32810000,Additional Workflow Creation,328100003100,Additional Workflow Creation,Setup Fee,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Automated ERP Import Interface ,364220003100,Automated ERP Import Interface ,Setup Fee,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37087000,Business Author Roles,370870004000,Business Author Roles,Base Fee,,,,,,30.00,,,,,,,,,,,,,,,,,,,,,,,,,30.00,,,,,,,,,,,,,,,,,,,,,,,,###36417000,Certify New Coporate Card for Expense Pay,364170003100,Certify New Coporate Card for Expense Pay,Setup Fee,,,4000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36416000,Certify Non-Supported Corporate Card Feeds for Expense,364160003100,Certify Non-Supported Corporate Card Feeds for Expense,Setup Fee,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000000000,Expense,Usage Fee,,,,,,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88###36391120,Travel & Expense,364000004000,Expense,Base Fee,,,,,,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00###36391120,Travel & Expense,365000000000,Travel,Usage Fee,,,,,,2.07,2.07,1.94,1.79,1.71,1.66,1.65,1.64,1.64,1.63,1.63,1.62,1.61,1.61,1.60,1.59,1.55,1.49,1.43,1.30,1.04,0.84,0.65,0.52,0.47,2.07,2.07,1.94,1.79,1.71,1.66,1.65,1.64,1.64,1.63,1.63,1.62,1.61,1.61,1.60,1.59,1.55,1.49,1.43,1.30,1.04,0.84,0.65,0.52,0.47###36391120,Travel & Expense,365000004000,Travel,Base Fee,,,,,,0.00,20.70,97.00,179.00,256.50,332.00,412.50,492.00,656.00,815.00,978.00,1134.00,1288.00,1449.00,1600.00,1987.50,2325.00,2607.50,2860.00,3250.00,5200.00,6300.00,6500.00,7800.00,9400.00,0.00,20.70,97.00,179.00,256.50,332.00,412.50,492.00,656.00,815.00,978.00,1134.00,1288.00,1449.00,1600.00,1987.50,2325.00,2607.50,2860.00,3250.00,5200.00,6300.00,6500.00,7800.00,9400.00###36391120,Travel & Expense,364000003100,Expense,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,9000.00,9000.00,9000.00,9000.00,9000.00,11250.00,11250.00,12150.00,13500.00,18000.00,20250.00,22500.00,24750.00,27000.00,31500.00,33750.00,33750.00,36000.00,36000.00,40050.00,47700.00,49500.00,54000.00,54000.00,58500.00###36391120,Travel & Expense,365000003100,Travel,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,1000.00,1000.00,1000.00,1800.00,1800.00,1750.00,1750.00,2700.00,2700.00,2700.00,3600.00,3600.00,3600.00,3600.00,3600.00,5400.00,7200.00,7200.00,7200.00,8640.00,9000.00,9000.00,9000.00,9000.00,9000.00###50040000,Configuration Audit & Analysis,500400003100,Configuration Audit & Analysis,Setup Fee,,,21000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37088000,Consumer Roles,370880004000,Consumer Roles,Base Fee,,,,,,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00,75.00###36422300,Corporate Card Profile Data Interface ,364223003100,Corporate Card Profile Data Interface ,Setup Fee,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422700,Corporate Travel Department ,364227003100,Corporate Travel Department ,Setup Fee,,,5400.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51420000,Custom Connector,514200003100,Custom Connector,Setup Fee,,,,200.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50011000,Custom Consulting Services,500110003100,Custom Consulting Services,Setup Fee,,,,250.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50121000,Custom Extract File,501210003100,Custom Extract File,Setup Fee,,,,150.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51480000,Custom Onsite Training,514800003100,Custom Onsite Training,Setup Fee,,,,,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51440000,Custom QuickStart Guide,514400003100,Custom QuickStart Guide,Setup Fee,,,,,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50030000,Custom Reports,500300003100,Custom Reports,Setup Fee,,,,250.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51450000,Custom Training Materials,514500003100,Custom Training Materials,Setup Fee,,,,,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51470000,Custom Virtual Training,514700003100,Custom Virtual Training,Setup Fee,,,,,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51410000,Defined Extract File,514100003100,Defined Extract File,Setup Fee,,,1500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30842000,E-Invoice Import Set Up,308420003100,E-Invoice Import Set Up,Setup Fee,,,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51414000,Expense Advanced Configuration Training ,514140003100,Expense Advanced Configuration Training ,Setup Fee,,,,,8500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51417000,Expense Boot Camp ,514170003100,Expense Boot Camp ,Setup Fee,,,,,8500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000000000,Expense,Usage Fee,,,,,,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88###NEWSKU,Expense integrated with Third-Party Travel,364000004000,Expense,Base Fee,,,,,,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00###NEWSKU,Expense integrated with Third-Party Travel,364000003100,Expense,Setup Fee,,,,,,9000.00,9000.00,9000.00,9000.00,9000.00,11250.00,11250.00,12150.00,13500.00,18000.00,20250.00,22500.00,24750.00,27000.00,31500.00,33750.00,33750.00,36000.00,36000.00,40050.00,47700.00,49500.00,54000.00,54000.00,58500.00,9000.00,9000.00,9000.00,9000.00,9000.00,11250.00,11250.00,12150.00,13500.00,18000.00,20250.00,22500.00,24750.00,27000.00,31500.00,33750.00,33750.00,36000.00,36000.00,40050.00,47700.00,49500.00,54000.00,54000.00,58500.00###37080000,Expense Pay EMEA,370800000000,Expense Pay EMEA,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,1.90,1.90,1.90,1.90,1.90,1.80,1.80,1.80,1.80,1.74,1.62,1.58,1.31,1.13,1.06###37080000,Expense Pay EMEA,370800004000,Expense Pay EMEA,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,20.00,100.00,200.00,300.00,400.00,500.00,600.00,800.00,1000.00,1140.00,1330.00,1520.00,1710.00,1900.00,2250.00,2700.00,3150.00,3600.00,4350.00,8100.00,11850.00,13100.00,16950.00,21200.00###37080000,Expense Pay EMEA,370800003100,Expense Pay EMEA,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2000.00,2000.00,2000.00,2000.00,2000.00,2000.00,2000.00,2000.00,2000.00,2000.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2500.00,2500.00,2500.00,2500.00,2750.00###37070000,Expense Pay North America,370700000000,Expense Pay North America,Usage Fee,,,,,,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.49,1.40,1.40,1.40,1.40,1.40,1.33,1.30,1.30,1.30,1.24,1.12,1.08,0.81,0.63,0.56,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.50,1.49,1.40,1.40,1.40,1.40,1.40,1.33,1.30,1.30,1.30,1.24,1.12,1.08,0.81,0.63,0.56###37070000,Expense Pay North America,370700004000,Expense Pay North America,Base Fee,,,,,,0.00,15.00,75.00,150.00,225.00,300.00,375.00,450.00,600.00,745.00,840.00,980.00,1120.00,1260.00,1400.00,1662.50,1950.00,2275.00,2600.00,3100.00,5600.00,8100.00,8100.00,9450.00,11200.00,0.00,15.00,75.00,150.00,225.00,300.00,375.00,450.00,600.00,745.00,840.00,980.00,1120.00,1260.00,1400.00,1662.50,1950.00,2275.00,2600.00,3100.00,5600.00,8100.00,8100.00,9450.00,11200.00###37070000,Expense Pay North America,370700003100,Expense Pay North America,Setup Fee,,,,,,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00###36400000,Expense,364000000000,Expense,Usage Fee,,,,,,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88,8.29,8.29,7.78,7.17,6.84,6.64,6.60,6.58,6.55,6.53,6.50,6.48,6.46,6.43,6.41,6.34,6.19,5.95,5.74,5.20,4.18,3.38,2.61,2.07,1.88###36400000,Expense,364000004000,Expense,Base Fee,,,,,,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00,0.00,82.88,388.80,716.80,1026.00,1328.00,1650.00,1972.80,2620.80,3264.00,3902.40,4536.00,5164.80,5788.80,6408.00,7930.00,9288.00,10416.00,11472.00,13000.00,20880.00,25320.00,26080.00,31080.00,37600.00###36400000,Expense,364000003100,Expense,Setup Fee,,,,,,9000.00,9000.00,9000.00,9000.00,9000.00,11250.00,11250.00,12150.00,13500.00,18000.00,20250.00,22500.00,24750.00,27000.00,31500.00,33750.00,33750.00,36000.00,36000.00,40050.00,47700.00,49500.00,54000.00,54000.00,58500.00,9000.00,9000.00,9000.00,9000.00,9000.00,11250.00,11250.00,12150.00,13500.00,18000.00,20250.00,22500.00,24750.00,27000.00,31500.00,33750.00,33750.00,36000.00,36000.00,40050.00,47700.00,49500.00,54000.00,54000.00,58500.00###50122000,Extract Split,501220003100,Extract Split,Setup Fee,,,1500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30844000,FTP/PGP Set Up Fee,308440003100,FTP/PGP Set Up Fee,Setup Fee,,,500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36428000,GDS Conversion,364280003100,GDS Conversion,Setup Fee,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51490000,Hands-On Report Authoring Class,514900003100,Hands-On Report Authoring Class,Setup Fee,,,,,7800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000000000,Intelligence for Expense,Usage Fee,,,,,,,1.24,1.24,1.17,1.08,1.03,1.00,0.99,0.99,0.98,0.98,0.98,0.97,0.97,0.96,0.96,0.95,0.93,0.89,0.86,0.78,0.63,0.51,0.39,0.31,0.28,1.24,1.17,1.08,1.03,1.00,0.99,0.99,0.98,0.98,0.98,0.97,0.97,0.96,0.96,0.95,0.93,0.89,0.86,0.78,0.63,0.51,0.39,0.31,0.28###36600000,Intelligence for Expense,366000004000,Intelligence for Expense,Base Fee,,,,,,,12.43,62.16,116.64,161.28,205.20,249.00,297.00,394.56,491.40,587.52,682.92,777.60,871.56,964.80,1201.50,1427.40,1625.40,1785.60,2151.00,3900.00,4698.00,5064.00,5868.00,6216.00,0.00,12.43,58.32,107.52,153.90,199.20,247.50,295.92,393.12,489.60,585.36,680.40,774.72,868.32,961.20,1189.50,1393.20,1562.40,1720.80,1950.00,3132.00,3798.00,3912.00,4662.00,5640.00###36600000,Intelligence for Expense,366000003100,Intelligence for Expense,Setup Fee,,,,,,,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,3750.00,3750.00,3750.00,3750.00,3750.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,3750.00,3750.00,3750.00,3750.00,3750.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00###37085000,Intelligence for Invoice Processing,370850000000,Intelligence for Invoice Processing,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.90,0.90,0.73,0.61,0.53,0.46,0.46,0.46,0.43,0.43,0.41,0.40,0.39,0.39,0.38,0.38,0.38,0.38,0.37,0.34,0.30,0.29,0.27,0.25,0.24###37085000,Intelligence for Invoice Processing,370850004000,Intelligence for Invoice Processing,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,9.00,36.60,60.60,78.98,91.80,114.75,137.70,171.60,213.75,243.00,281.40,312.00,348.30,376.50,470.63,564.75,658.88,732.00,840.00,1522.50,2160.00,2745.00,3757.50,4740.00###37085000,Intelligence for Invoice Processing,370850003100,Intelligence for Invoice Processing,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,3750.00,3750.00,3750.00,3750.00,3750.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00###36700000,Intelligence for Travel & Expense,367000000000,Intelligence for Travel & Expense,Usage Fee,,,,,,2.18,2.18,2.04,1.88,1.80,1.74,1.73,1.73,1.72,1.71,1.71,1.70,1.69,1.69,1.68,1.67,1.63,1.56,1.50,1.37,1.10,0.89,0.68,0.54,0.49,2.18,2.18,2.04,1.88,1.80,1.74,1.73,1.73,1.72,1.71,1.71,1.70,1.69,1.69,1.68,1.67,1.63,1.56,1.50,1.37,1.10,0.89,0.68,0.54,0.49###36700000,Intelligence for Travel & Expense,367000004000,Intelligence for Travel & Expense,Base Fee,,,,,,0.00,21.75,102.02,188.12,269.33,348.60,433.13,517.61,688.13,856.59,1024.88,1190.70,1355.09,1519.94,1681.68,2082.68,2438.73,2734.94,3009.72,3412.50,5476.80,6640.20,6841.80,8164.80,9870.00,0.00,21.75,102.02,188.12,269.33,348.60,433.13,517.61,688.13,856.59,1024.88,1190.70,1355.09,1519.94,1681.68,2082.68,2438.73,2734.94,3009.72,3412.50,5476.80,6640.20,6841.80,8164.80,9870.00###36700000,Intelligence for Travel & Expense,367000003100,Intelligence for Travel & Expense,Setup Fee,,,,,,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,3750.00,3750.00,3750.00,3750.00,3750.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,3750.00,3750.00,3750.00,3750.00,3750.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00,5000.00###51412000,Introduction to Analysis,514120003100,Introduction to Analysis,Setup Fee,,,500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51411000,Introduction to Intelligence,514110003100,Introduction to Intelligence,Setup Fee,,,1000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830000000,Invoice Capture,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.17,1.15,1.15,1.15,1.15,1.10,1.10,1.10,1.10,1.10,1.05,1.00,0.95,0.90,0.85,0.80###37083000,Invoice Capture,370830004000,Invoice Capture,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,12.50,62.50,125.00,187.50,250.00,312.50,375.00,500.00,585.00,690.00,805.00,920.00,1035.00,1100.00,1375.00,1650.00,1925.00,2200.00,2625.00,5000.00,7125.00,9000.00,12750.00,16000.00###37083000,Invoice Capture,370830003100,Invoice Capture,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,1750.00,2000.00,2000.00,2000.00,2000.00,2500.00,2500.00,3000.00,3500.00,4000.00,5000.00,6000.00###37084000,Invoice Check Payments,370840000000,Invoice Check Payments,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00###37082000,Invoice Processing,370820000000,Invoice Processing,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,6.00,6.00,4.88,4.04,3.51,3.06,3.06,3.06,2.86,2.85,2.70,2.68,2.60,2.58,2.51,2.51,2.51,2.51,2.44,2.24,2.03,1.92,1.83,1.67,1.58###37082000,Invoice Processing,370820004000,Invoice Processing,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,60.00,244.00,404.00,526.50,612.00,765.00,918.00,1144.00,1425.00,1620.00,1876.00,2080.00,2322.00,2510.00,3137.50,3765.00,4392.50,4880.00,5600.00,10150.00,14400.00,18300.00,25050.00,31600.00###37082000,Invoice Processing,370820003100,Invoice Processing,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3060.00,3060.00,3060.00,3060.00,3719.00,4410.00,4463.00,4475.00,5650.00,6375.00,7256.00,7969.00,8415.00,9690.00,10889.00,11794.00,12750.00,13600.00,13600.00,15130.00,20060.00,21038.00,25500.00,25500.00,31560.00###51424000,Managed Reporting (12 Transactions),514240000000,Managed Reporting (12 Transactions),Usage Fee,,,,,,14.58,14.58,4.52,2.91,2.24,2.12,1.85,1.50,1.14,0.94,0.79,0.68,0.61,0.56,0.50,0.40,0.34,0.30,0.26,0.25,0.19,0.14,0.10,0.08,0.07,14.58,14.58,4.52,2.91,2.24,2.12,1.85,1.50,1.14,0.94,0.79,0.68,0.61,0.56,0.50,0.40,0.34,0.30,0.26,0.25,0.19,0.14,0.10,0.08,0.07###51424000,Managed Reporting (12 Transactions),514240004000,Managed Reporting (12 Transactions),Base Fee,,,,,,0.00,145.80,226.00,291.00,336.00,424.00,462.50,450.00,456.00,470.00,474.00,476.00,488.00,504.00,500.00,500.00,510.00,525.00,520.00,625.00,950.00,1050.00,1000.00,1200.00,1400.00,0.00,145.80,226.00,291.00,336.00,424.00,462.50,450.00,456.00,470.00,474.00,476.00,488.00,504.00,500.00,500.00,510.00,525.00,520.00,625.00,950.00,1050.00,1000.00,1200.00,1400.00###51424000,Managed Reporting (12 Transactions),514240003100,Managed Reporting (12 Transactions),Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###51425000,Managed Reporting (24 Transactions),514250000000,Managed Reporting (24 Transactions),Usage Fee,,,,,,29.16,29.16,9.04,5.82,4.26,4.03,3.52,2.85,2.17,1.79,1.50,1.29,1.16,1.06,0.95,0.76,0.65,0.57,0.49,0.48,0.36,0.27,0.19,0.15,0.13,27.70,27.70,8.59,5.53,4.26,4.03,3.52,2.85,2.17,1.79,1.50,1.29,1.16,1.06,0.95,0.76,0.65,0.57,0.49,0.48,0.36,0.27,0.19,0.15,0.13###51425000,Managed Reporting (24 Transactions),514250004000,Managed Reporting (24 Transactions),Base Fee,,,,,,0.00,291.60,452.00,582.00,638.40,805.60,878.75,855.00,866.40,893.00,900.60,904.40,927.20,957.60,950.00,950.00,969.00,997.50,988.00,1187.50,1805.00,1995.00,1900.00,2280.00,2660.00,0.00,277.02,429.40,552.90,638.40,805.60,878.75,855.00,866.40,893.00,900.60,904.40,927.20,957.60,950.00,950.00,969.00,997.50,988.00,1187.50,1805.00,1995.00,1900.00,2280.00,2660.00###51425000,Managed Reporting (24 Transactions),514250003100,Managed Reporting (24 Transactions),Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###51426000,Managed Reporting (36 Transactions),514260000000,Managed Reporting (36 Transactions),Usage Fee,,,,,,43.74,43.74,13.56,8.73,6.05,5.72,5.00,4.05,3.08,2.54,2.13,1.84,1.65,1.51,1.35,1.08,0.92,0.81,0.70,0.68,0.51,0.38,0.27,0.22,0.19,39.37,39.37,12.20,7.86,6.05,5.72,5.00,4.05,3.08,2.54,2.13,1.84,1.65,1.51,1.35,1.08,0.92,0.81,0.70,0.68,0.51,0.38,0.27,0.22,0.19###51426000,Managed Reporting (36 Transactions),514260004000,Managed Reporting (36 Transactions),Base Fee,,,,,,0.00,437.40,678.00,873.00,907.20,1144.80,1248.75,1215.00,1231.20,1269.00,1279.80,1285.20,1317.60,1360.80,1350.00,1350.00,1377.00,1417.50,1404.00,1687.50,2565.00,2835.00,2700.00,3240.00,3780.00,0.00,393.66,610.20,785.70,907.20,1144.80,1248.75,1215.00,1231.20,1269.00,1279.80,1285.20,1317.60,1360.80,1350.00,1350.00,1377.00,1417.50,1404.00,1687.50,2565.00,2835.00,2700.00,3240.00,3780.00###51426000,Managed Reporting (36 Transactions),514260003100,Managed Reporting (36 Transactions),Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###NEWSKU4,Meeting Management ,NEWSKU43100,Meeting Management Application,Setup Fee,,,,,,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00,1800.00###NEWSKU4,Meeting Management ,NEWSKU40000,Meeting Management Application,Usage Fee,,,,,,3.00,3.00,3.00,3.00,3.00,3.00,3.00,3.00,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.25,2.25,2.25,2.00,2.00,2.00,3.00,3.00,3.00,3.00,3.00,3.00,3.00,3.00,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.50,2.25,2.25,2.25,2.00,2.00,2.00###NEWSKU4,Meeting Management ,NEWSKU44000,Meeting Management Application,Base Fee,,,,,,0.00,30.00,150.00,300.00,450.00,600.00,750.00,900.00,1000.00,1250.00,1500.00,1750.00,2000.00,2250.00,2500.00,3125.00,3750.00,4375.00,5000.00,5625.00,11250.00,16875.00,20000.00,30000.00,40000.00,0.00,30.00,150.00,300.00,450.00,600.00,750.00,900.00,1000.00,1250.00,1500.00,1750.00,2000.00,2250.00,2500.00,3125.00,3750.00,4375.00,5000.00,5625.00,11250.00,16875.00,20000.00,30000.00,40000.00###36426000,Meeting Management Custom Profile Setup,364260003100,Meeting Management Custom Profile Setup,Setup Fee,,,1500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422800,Meeting Management Custom Site/Configuration,364228003100,Meeting Management Custom Site/Configuration,Setup Fee,,,450.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890000000,Paper Receipt Handling,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00,6.00###37089000,Paper Receipt Handling,370890004000,Paper Receipt Handling,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,60.00,300.00,600.00,900.00,1200.00,1500.00,1800.00,2400.00,3000.00,3600.00,4200.00,4800.00,5400.00,6000.00,7500.00,9000.00,10500.00,12000.00,15000.00,30000.00,45000.00,60000.00,90000.00,120000.00###37089000,Paper Receipt Handling,370890003100,Paper Receipt Handling,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,300.00,300.00,300.00,600.00,600.00,600.00,600.00,600.00,600.00,900.00,900.00,1200.00,1200.00,1200.00,1200.00,1200.00,1725.00,1725.00,1725.00,1725.00,2300.00,2300.00,2300.00,2300.00,2300.00###37030000,Policy Audit,370300000000,Policy Audit,Usage Fee,,,,,,6.39,6.39,6.39,6.39,6.39,6.13,6.13,6.13,6.13,5.94,5.71,5.48,5.27,5.06,4.86,4.76,4.67,4.57,4.35,4.09,3.70,3.41,3.34,3.34,3.34,6.39,6.39,6.39,6.39,6.39,6.13,6.13,6.13,6.13,5.94,5.71,5.48,5.27,5.06,4.86,4.76,4.67,4.57,4.35,4.09,3.70,3.41,3.34,3.34,3.34###37030000,Policy Audit,370300004000,Policy Audit,Base Fee,,,,,,0.00,63.90,319.50,639.00,958.50,1226.00,1532.50,1839.00,2452.00,2970.00,3426.00,3836.00,4216.00,4554.00,4860.00,5950.00,7005.00,7997.50,8700.00,10225.00,18500.00,25575.00,33400.00,50100.00,66800.00,0.00,63.90,319.50,639.00,958.50,1226.00,1532.50,1839.00,2452.00,2970.00,3426.00,3836.00,4216.00,4554.00,4860.00,5950.00,7005.00,7997.50,8700.00,10225.00,18500.00,25575.00,33400.00,50100.00,66800.00###37030000,Policy Audit,370300003100,Policy Audit,Setup Fee,,,,,,2000.00,2000.00,2000.00,2000.00,2000.00,2500.00,2639.00,3413.00,4635.00,5610.00,7072.00,7560.00,7800.00,8294.00,8775.00,8775.00,8775.00,9263.00,10400.00,11213.00,11505.00,12675.00,13325.00,13650.00,13650.00,2000.00,2000.00,2000.00,2000.00,2000.00,2500.00,2639.00,3413.00,4635.00,5610.00,7072.00,7560.00,7800.00,8294.00,8775.00,8775.00,8775.00,9263.00,10400.00,11213.00,11505.00,12675.00,13325.00,13650.00,13650.00###37086000,Professional Author Roles,370860004000,Professional Author Roles,Base Fee,,,,,,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00,40.00###51416000,Project Team Jump Start Training for Expense ,514160003100,Project Team Jump Start Training for Expense ,Setup Fee,,,,,8500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51415000,Project Team Jump Start Training for Travel & Expense ,514150003100,Project Team Jump Start Training for Travel & Expense ,Setup Fee,,,,,11000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200000000,Receipt Audit,Usage Fee,,,,,,4.95,4.95,4.95,4.95,4.95,4.75,4.75,4.75,4.75,4.61,4.43,4.25,4.08,3.92,3.77,3.69,3.62,3.54,3.37,3.14,2.93,2.81,2.64,2.59,2.59,4.95,4.95,4.95,4.95,4.95,4.75,4.75,4.75,4.75,4.61,4.43,4.25,4.08,3.92,3.77,3.69,3.62,3.54,3.37,3.14,2.93,2.81,2.64,2.59,2.59###37020000,Receipt Audit,370200004000,Receipt Audit,Base Fee,,,,,,0.00,49.50,247.50,495.00,742.50,950.00,1187.50,1425.00,1900.00,2305.00,2658.00,2975.00,3264.00,3528.00,3770.00,4612.50,5430.00,6195.00,6740.00,7850.00,14650.00,21075.00,26400.00,38850.00,51800.00,0.00,49.50,247.50,495.00,742.50,950.00,1187.50,1425.00,1900.00,2305.00,2658.00,2975.00,3264.00,3528.00,3770.00,4612.50,5430.00,6195.00,6740.00,7850.00,14650.00,21075.00,26400.00,38850.00,51800.00###37020000,Receipt Audit,370200003100,Receipt Audit,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###51428000,Service Administration - Expense,514280000000,Service Administration - Expense,Usage Fee,,,,,,11.17,11.17,4.56,2.60,1.62,1.29,1.11,1.02,0.91,0.86,0.85,0.83,0.81,0.77,0.73,0.66,0.59,0.54,0.48,0.40,0.35,0.30,0.22,0.17,0.17,11.17,11.17,4.56,2.60,1.62,1.29,1.11,1.02,0.91,0.86,0.85,0.83,0.81,0.77,0.73,0.66,0.59,0.54,0.48,0.40,0.35,0.30,0.22,0.17,0.17###51428000,Service Administration - Expense,514280004000,Service Administration - Expense,Base Fee,,,,,,0.00,111.70,228.00,260.00,243.00,258.00,277.50,306.00,364.00,430.00,510.00,581.00,648.00,693.00,730.00,825.00,885.00,945.00,960.00,1000.00,1750.00,2250.00,2200.00,2550.00,3400.00,0.00,111.70,228.00,260.00,243.00,258.00,277.50,306.00,364.00,430.00,510.00,581.00,648.00,693.00,730.00,825.00,885.00,945.00,960.00,1000.00,1750.00,2250.00,2200.00,2550.00,3400.00###51428000,Service Administration - Expense,514280003100,Service Administration - Expense,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###51429000,Service Administration - Travel & Expense,514290000000,Service Administration - Travel & Expense,Usage Fee,,,,,,13.40,13.40,5.47,3.12,1.94,1.55,1.33,1.22,1.09,1.03,1.02,1.00,0.97,0.92,0.88,0.79,0.71,0.65,0.58,0.48,0.42,0.36,0.26,0.20,0.20,13.40,13.40,5.47,3.12,1.94,1.55,1.33,1.22,1.09,1.03,1.02,1.00,0.97,0.92,0.88,0.79,0.71,0.65,0.58,0.48,0.42,0.36,0.26,0.20,0.20###51429000,Service Administration - Travel & Expense,514290004000,Service Administration - Travel & Expense,Base Fee,,,,,,0.00,134.04,273.60,312.00,291.60,309.60,333.00,367.20,436.80,516.00,612.00,697.20,777.60,831.60,876.00,990.00,1062.00,1134.00,1152.00,1200.00,2100.00,2700.00,2640.00,3060.00,4080.00,0.00,134.04,273.60,312.00,291.60,309.60,333.00,367.20,436.80,516.00,612.00,697.20,777.60,831.60,876.00,990.00,1062.00,1134.00,1152.00,1200.00,2100.00,2700.00,2640.00,3060.00,4080.00###51429000,Service Administration - Travel & Expense,514290003100,Service Administration - Travel & Expense,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###36411800,Service Termination Extension ,364118003100,Service Termination Extension ,Setup Fee,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34000000,Single Sign-On,343000003100,Single Sign-On,Setup Fee,,,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###60510000,Third Party Meeting Registration - Modified Configuration,605100003100,Third Party Meeting Registration - Modified Configuration,Setup Fee,,,3000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36429000,Third-Party Meeting Registration - New Configuration,364290003100,Third-Party Meeting Registration - New Configuration,Setup Fee,,,7500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422500,Third-Party Travel Integration ,364225003100,Third-Party Travel Integration ,Setup Fee,,,3200.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51413000,Travel & Expense Advanced Configuration Training ,514130003100,Travel & Expense Advanced Configuration Training ,Setup Fee,,,,,11000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50390000,Travel & Expense Boot Camp,503900003100,Travel & Expense Boot Camp,Setup Fee,,,,,11000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34830000,Travel Agency Conversion,348300003100,Travel Agency Conversion,Setup Fee,,,1500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000000000,Travel - Premier,Usage Fee,,,,,,2.07,2.07,1.94,1.79,1.71,1.66,1.65,1.64,1.64,1.63,1.63,1.62,1.61,1.61,1.60,1.59,1.55,1.49,1.43,1.30,1.04,0.84,0.65,0.52,0.47,2.07,2.07,1.94,1.79,1.71,1.66,1.65,1.64,1.64,1.63,1.63,1.62,1.61,1.61,1.60,1.59,1.55,1.49,1.43,1.30,1.04,0.84,0.65,0.52,0.47###36500000,Travel Premier,365000004000,Travel - Premier,Base Fee,,,,,,0.00,20.70,97.00,179.00,256.50,332.00,412.50,492.00,656.00,815.00,978.00,1134.00,1288.00,1449.00,1600.00,1987.50,2325.00,2607.50,2860.00,3250.00,5200.00,6300.00,6500.00,7800.00,9400.00,0.00,20.70,97.00,179.00,256.50,332.00,412.50,492.00,656.00,815.00,978.00,1134.00,1288.00,1449.00,1600.00,1987.50,2325.00,2607.50,2860.00,3250.00,5200.00,6300.00,6500.00,7800.00,9400.00###36500000,Travel Premier,365000003100,Travel - Premier,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,1000.00,1000.00,1000.00,1800.00,1800.00,1750.00,1750.00,2700.00,2700.00,2700.00,3600.00,3600.00,3600.00,3600.00,3600.00,5400.00,7200.00,7200.00,7200.00,8640.00,9000.00,9000.00,9000.00,9000.00,9000.00###31640000,Travel Set Up Post Initial Implementation ,316400003100,Travel Set Up Post Initial Implementation ,Setup Fee,,,,,3500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000004000,TripIt Pro,Base Fee,,,,,,0.84,0.84,0.84,0.83,0.83,0.83,0.83,0.83,0.82,0.82,0.82,0.82,0.80,0.80,0.78,0.77,0.75,0.72,0.69,0.66,0.52,0.42,0.33,0.26,0.24,1.24,1.24,1.17,1.08,1.03,1.00,0.99,0.99,0.98,0.98,0.98,0.97,0.97,0.96,0.96,0.95,0.93,0.89,0.86,0.78,0.63,0.51,0.39,0.31,0.28###91600000,TripIt Pro,916000003100,TripIt Pro,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###51427000,User Support Desk,514270000000,User Support Desk,Usage Fee,,,,,,1.45,1.45,1.38,1.24,1.18,1.13,1.13,1.07,1.01,0.95,0.94,0.94,0.94,0.94,0.94,0.94,0.91,0.90,0.87,0.75,0.60,0.50,0.40,0.34,0.31,1.45,1.45,1.38,1.24,1.18,1.13,1.13,1.07,1.01,0.95,0.94,0.94,0.94,0.94,0.94,0.94,0.91,0.90,0.87,0.75,0.60,0.50,0.40,0.34,0.31###51427000,User Support Desk,514270004000,User Support Desk,Base Fee,,,,,,0.00,14.50,69.00,124.00,177.00,226.00,282.50,321.00,404.00,475.00,564.00,658.00,752.00,846.00,940.00,1175.00,1365.00,1575.00,1740.00,1875.00,3000.00,3750.00,4000.00,5100.00,6200.00,0.00,14.50,69.00,124.00,177.00,226.00,282.50,321.00,404.00,475.00,564.00,658.00,752.00,846.00,940.00,1175.00,1365.00,1575.00,1740.00,1875.00,3000.00,3750.00,4000.00,5100.00,6200.00###51427000,User Support Desk,514270003100,User Support Desk,Setup Fee,,,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00###36411400,USGSA Travel Allowance Rate Service ,364114003100,USGSA Travel Allowance Rate Service ,Setup Fee,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340000000,Web Services,Usage Fee,,,,,,8.90,8.90,3.52,2.18,1.56,1.23,1.02,0.86,0.70,0.59,0.51,0.45,0.40,0.36,0.32,0.32,0.31,0.30,0.29,0.26,0.21,0.17,0.13,0.10,0.09,8.90,8.90,3.52,2.18,1.56,1.23,1.02,0.86,0.70,0.59,0.51,0.45,0.40,0.36,0.32,0.32,0.31,0.30,0.29,0.26,0.21,0.17,0.13,0.10,0.09###51434000,Web Services,514340004000,Web Services,Base Fee,,,,,,0.00,89.00,176.00,218.00,234.00,246.00,255.00,258.00,280.00,295.00,306.00,315.00,320.00,324.00,320.00,400.00,465.00,525.00,580.00,650.00,1050.00,1275.00,1300.00,1500.00,1800.00,0.00,89.00,176.00,218.00,234.00,246.00,255.00,258.00,280.00,295.00,306.00,315.00,320.00,324.00,320.00,400.00,465.00,525.00,580.00,650.00,1050.00,1275.00,1300.00,1500.00,1800.00###51434000,Web Services,514340003100,Web Services,Setup Fee,,,,,,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,5000.00,5000.00,5000.00,7500.00,7500.00,7500.00,7500.00,10000.00,10000.00,10000.00,1000.00,1000.00,1000.00,1000.00,1000.00,1000.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,2500.00,5000.00,5000.00,5000.00,7500.00,7500.00,7500.00,7500.00,10000.00,10000.00,10000.00###36422400,XML Profile Interface ,364224003100,XML Profile Interface ,Setup Fee,,,1800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, ";
str2 = "PO ID-EMEA,PO Name,PI ID,PI Name,Item Type,Edition,Impl Method,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000,,,###36411700,12 Week Test Entity ,364117003100,12 Week Test Entity ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,2813.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411500,Add Cash Advance ,364115003100,Add Cash Advance ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,938.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU2,Add Expense Pay  NA Post Initial Implementation ,NEWSKU23100,Add Expense Pay  NA Post Initial Implementation ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Add Invoice ACH Payments Post Initial Implementation Setup,364220003100,Add Invoice ACH Payments Post Initial Implementation Setup,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1250.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36424000,Add New PNR Mapping Template,364240003100,Add New PNR Mapping Template,Setup Fee,,All,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,,,###36425000,Add New Profile Template,364250003100,Add New Profile Template,Setup Fee,,All,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,2250.00,,,###36411200,Add Travel Allowance Configuration - Custom Import,364112003100,Add Travel Allowance Configuration - Custom Import,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,4688.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411300,Add Travel Allowance Configuration - US GSA Import,364113003100,Add Travel Allowance Configuration - US GSA Import,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411600,Add Travel Request ,364116003100,Add Travel Request ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422600,Additional Country/Configuration Setup,364226003100,Additional Country/Configuration Setup,Setup Fee,,All,1875.00,,,,,,,,,,,,,,,,,,,,,,,,,1875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51422000,Additional Multi Country Expense Configuration ,514220003100,Additional Multi Country Expense Configuration ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,18750.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36419000,Additional Policy Creation,364190003100,Additional Policy Creation,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51421000,Additional Single Country Expense Configuration ,514210003100,Additional Single Country Expense Configuration ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,156.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36418000,Additional Supported Corporate Card Feed,364180003100,Additional Supported Corporate Card Feed,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1250.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###31700000,Additional VAT Configuration,317000003100,Additional VAT Configuration,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###32810000,Additional Workflow Creation,328100003100,Additional Workflow Creation,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Automated ERP Import Interface ,364220003100,Automated ERP Import Interface ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37087000,Business Author Roles,370870004000,Business Author Roles,Base Fee,,All,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,18.75,,,###36417000,Certify New Coporate Card for Expense Pay,364170003100,Certify New Coporate Card for Expense Pay,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36416000,Certify Non-Supported Corporate Card Feeds for Expense,364160003100,Certify Non-Supported Corporate Card Feeds for Expense,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000000000,Expense,Usage Fee,,All,7.31,7.31,6.75,6.01,5.66,5.40,5.20,5.08,4.75,4.63,4.55,4.45,4.38,4.30,4.23,4.15,4.08,3.88,3.63,3.25,2.61,2.11,1.63,1.30,1.18,7.31,7.31,6.75,6.01,5.66,5.40,5.20,5.08,4.75,4.63,4.55,4.45,4.38,4.30,4.23,4.15,4.08,3.88,3.63,3.25,2.61,2.11,1.63,1.30,1.18,,,###36391120,Travel & Expense,364000004000,Expense,Base Fee,,All,0.00,73.06,337.50,601.25,849.38,1080.00,1300.00,1524.38,1900.00,2312.50,2730.00,3115.00,3500.00,3870.00,4225.00,5187.50,6112.50,6781.25,7250.00,8125.00,13031.25,15843.75,16312.50,19425.00,23500.00,0.00,73.06,337.50,601.25,849.38,1080.00,1300.00,1524.38,1900.00,2312.50,2730.00,3115.00,3500.00,3870.00,4225.00,5187.50,6112.50,6781.25,7250.00,8125.00,13031.25,15843.75,16312.50,19425.00,23500.00,,,###36391120,Travel & Expense,365000000000,Travel,Usage Fee,,All,1.83,1.83,1.69,1.50,1.41,1.35,1.30,1.27,1.19,1.16,1.14,1.11,1.09,1.08,1.06,1.04,1.02,0.97,0.91,0.81,0.65,0.53,0.41,0.33,0.29,1.83,1.83,1.69,1.50,1.41,1.35,1.30,1.27,1.19,1.16,1.14,1.11,1.09,1.08,1.06,1.04,1.02,0.97,0.91,0.81,0.65,0.53,0.41,0.33,0.29,,,###36391120,Travel & Expense,365000004000,Travel,Base Fee,,All,0.00,18.25,84.38,150.00,211.88,270.00,325.00,380.63,475.00,578.13,682.50,778.75,875.00,967.50,1056.25,1296.88,1528.13,1695.31,1812.50,2031.25,3250.00,3937.50,4062.50,4875.00,5875.00,0.00,18.25,84.38,150.00,211.88,270.00,325.00,380.63,475.00,578.13,682.50,778.75,875.00,967.50,1056.25,1296.88,1528.13,1695.31,1812.50,2031.25,3250.00,3937.50,4062.50,4875.00,5875.00,,,###36391120,Travel & Expense,364000003100,Expense,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,625.00,625.00,937.50,1250.00,1656.25,2125.00,2500.00,2812.50,3125.00,3593.75,4062.50,4687.50,5000.00,5312.50,5625.00,6250.00,6875.00,7500.00,8125.00,10000.00,12500.00,15625.00,18750.00,21875.00,25000.00,,,###36391120,Travel & Expense,365000003100,Travel,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,468.75,468.75,625.00,625.00,1000.00,1000.00,1093.75,1093.75,1093.75,1093.75,1406.25,1562.50,1562.50,1562.50,1875.00,1875.00,2500.00,2500.00,2812.50,4062.50,4687.50,4687.50,4687.50,4687.50,4687.50,,,###50040000,Configuration Audit & Analysis,500400003100,Configuration Audit & Analysis,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,13125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37088000,Consumer Roles,370880004000,Consumer Roles,Base Fee,,All,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,46.88,,,###36422300,Corporate Card Profile Data Interface ,364223003100,Corporate Card Profile Data Interface ,Setup Fee,,All,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422700,Corporate Travel Department ,364227003100,Corporate Travel Department ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51420000,Custom Connector,514200003100,Custom Connector,Setup Fee,,All,125.00,,,,,,,,,,,,,,,,,,,,,,,,,125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###50011000,Custom Consulting Services,500110003100,Custom Consulting Services,Setup Fee,,All,156.00,,,,,,,,,,,,,,,,,,,,,,,,,156.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###50121000,Custom Extract File,501210003100,Custom Extract File,Setup Fee,,All,94.00,,,,,,,,,,,,,,,,,,,,,,,,,94.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51480000,Custom Onsite Training,514800003100,Custom Onsite Training,Setup Fee,,All,125.00,,,,,,,,,,,,,,,,,,,,,,,,,125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51440000,Custom QuickStart Guide,514400003100,Custom QuickStart Guide,Setup Fee,,All,156.00,,,,,,,,,,,,,,,,,,,,,,,,,156.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###50030000,Custom Reports,500300003100,Custom Reports,Setup Fee,,All,94.00,,,,,,,,,,,,,,,,,,,,,,,,,94.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51450000,Custom Training Materials,514500003100,Custom Training Materials,Setup Fee,,All,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51470000,Custom Virtual Training,514700003100,Custom Virtual Training,Setup Fee,,All,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51410000,Defined Extract File,514100003100,Defined Extract File,Setup Fee,,All,983.00,,,,,,,,,,,,,,,,,,,,,,,,,983.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###30842000,E-Invoice Import Set Up,308420003100,E-Invoice Import Set Up,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51414000,Expense Advanced Configuration Training ,514140003100,Expense Advanced Configuration Training ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5313.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51417000,Expense Boot Camp ,514170003100,Expense Boot Camp ,Setup Fee,,All,313.00,,,,,,,,,,,,,,,,,,,,,,,,,938.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000000000,Expense,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000004000,Expense,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5313.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000003100,Expense,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5313.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800000000,Expense Pay EMEA,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.19,1.19,1.19,1.19,1.19,1.13,1.13,1.13,1.13,1.09,1.01,0.99,0.82,0.71,0.66,,,###37080000,Expense Pay EMEA,370800004000,Expense Pay EMEA,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,12.50,62.50,125.00,187.50,250.00,312.50,375.00,500.00,625.00,750.00,831.25,950.00,1068.75,1187.50,1484.38,1687.50,1968.75,2250.00,2812.50,5437.50,7593.75,9875.00,12281.25,14125.00,0.00,,,###37080000,Expense Pay EMEA,370800003100,Expense Pay EMEA,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1562.50,1562.50,1562.50,1562.50,1718.75,,,###37070000,Expense Pay North America,370700000000,Expense Pay North America,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.19,1.19,1.19,1.19,1.19,1.13,1.13,1.13,1.13,1.09,1.01,0.99,0.82,0.71,0.66,,,###37070000,Expense Pay North America,370700004000,Expense Pay North America,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,12.50,62.50,125.00,187.50,250.00,312.50,375.00,500.00,625.00,712.50,831.25,950.00,1068.75,1187.50,1406.25,1687.50,1968.75,2250.00,2718.75,5062.50,7406.25,8187.50,10593.75,13250.00,,,###37070000,Expense Pay North America,370700003100,Expense Pay North America,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1250.00,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1406.25,1562.50,1562.50,1562.50,1562.50,1718.75,,,###36400000,Expense,364000000000,Expense,Usage Fee,,All,7.31,7.31,6.75,6.01,5.66,5.40,5.20,5.08,4.75,4.63,4.55,4.45,4.38,4.30,4.23,4.15,4.08,3.88,3.63,3.25,2.61,2.11,1.63,1.30,1.18,7.31,7.31,6.75,6.01,5.66,5.40,5.20,5.08,4.75,4.63,4.55,4.45,4.38,4.30,4.23,4.15,4.08,3.88,3.63,3.25,2.61,2.11,1.63,1.30,1.18,,,###36400000,Expense,364000004000,Expense,Base Fee,,All,0.00,73.06,337.50,601.25,849.38,1080.00,1300.00,1524.38,1900.00,2312.50,2730.00,3115.00,3500.00,3870.00,4225.00,5187.50,6112.50,6781.25,7250.00,8125.00,13031.25,15843.75,16312.50,19425.00,23500.00,0.00,73.06,337.50,601.25,849.38,1080.00,1300.00,1524.38,1900.00,2312.50,2730.00,3115.00,3500.00,3870.00,4225.00,5187.50,6112.50,6781.25,7250.00,8125.00,13031.25,15843.75,16312.50,19425.00,23500.00,,,###36400000,Expense,364000003100,Expense,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,625.00,625.00,937.50,1250.00,1656.25,2125.00,2500.00,2812.50,3125.00,3593.75,4062.50,4687.50,5000.00,5312.50,5625.00,6250.00,6875.00,7500.00,8125.00,10000.00,12500.00,15625.00,18750.00,21875.00,25000.00,,,###50122000,Extract Split,501220003100,Extract Split,Setup Fee,,All,313.00,,,,,,,,,,,,,,,,,,,,,,,,,938.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###30844000,FTP/PGP Set Up Fee,308440003100,FTP/PGP Set Up Fee,Setup Fee,,All,313.00,,,,,,,,,,,,,,,,,,,,,,,,,313.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36428000,GDS Conversion,364280003100,GDS Conversion,Setup Fee,,All,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51490000,Hands-On Report Authoring Class,514900003100,Hands-On Report Authoring Class,Setup Fee,,All,4875.00,,,,,,,,,,,,,,,,,,,,,,,,,4875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000000000,Intelligence for Expense,Usage Fee,,All,1.10,1.10,1.01,0.90,0.85,0.81,0.78,0.76,0.71,0.69,0.68,0.67,0.66,0.65,0.63,0.62,0.61,0.58,0.54,0.49,0.39,0.32,0.24,0.19,0.18,1.10,1.10,1.01,0.90,0.85,0.81,0.78,0.76,0.71,0.69,0.68,0.67,0.66,0.65,0.63,0.62,0.61,0.58,0.54,0.49,0.39,0.32,0.24,0.19,0.18,,,###36600000,Intelligence for Expense,366000004000,Intelligence for Expense,Base Fee,,All,0.00,10.96,50.63,90.19,127.41,162.00,195.00,228.66,285.00,346.88,409.50,467.25,525.00,580.50,633.75,778.13,916.88,1017.19,1087.50,1218.75,1954.69,2376.56,2446.88,2913.75,3525.00,0.00,10.96,50.63,90.19,127.41,162.00,195.00,228.66,285.00,346.88,409.50,467.25,525.00,580.50,633.75,778.13,916.88,1017.19,1087.50,1218.75,1954.69,2376.56,2446.88,2913.75,3525.00,,,###36600000,Intelligence for Expense,366000003100,Intelligence for Expense,Setup Fee,,All,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,2343.75,2343.75,2343.75,2343.75,2343.75,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,2343.75,2343.75,2343.75,2343.75,2343.75,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,,,###37085000,Intelligence for Invoice Processing,370850000000,Intelligence for Invoice Processing,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.56,0.56,0.46,0.38,0.33,0.29,0.29,0.29,0.27,0.27,0.25,0.25,0.24,0.24,0.24,0.24,0.24,0.24,0.23,0.21,0.19,0.18,0.17,0.16,0.15,,,###37085000,Intelligence for Invoice Processing,370850004000,Intelligence for Invoice Processing,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,5.63,22.88,37.88,49.36,57.38,71.72,86.06,107.25,133.59,151.88,175.88,195.00,217.69,235.31,294.14,352.97,411.80,457.50,525.00,951.56,1350.00,1715.63,2348.44,2962.50,,,###37085000,Intelligence for Invoice Processing,370850003100,Intelligence for Invoice Processing,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,2343.75,2343.75,2343.75,2343.75,2343.75,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,,,###36700000,Intelligence for Travel & Expense,367000000000,Intelligence for Travel & Expense,Usage Fee,,All,1.92,1.92,1.77,1.58,1.49,1.42,1.37,1.33,1.25,1.21,1.19,1.17,1.15,1.13,1.11,1.09,1.07,1.02,0.95,0.85,0.68,0.55,0.43,0.34,0.31,1.92,1.92,1.77,1.58,1.49,1.42,1.37,1.33,1.25,1.21,1.19,1.17,1.15,1.13,1.11,1.09,1.07,1.02,0.95,0.85,0.68,0.55,0.43,0.34,0.31,,,###36700000,Intelligence for Travel & Expense,367000004000,Intelligence for Travel & Expense,Base Fee,,All,0.00,19.18,88.59,157.76,222.86,283.50,341.25,400.05,498.75,607.03,716.63,817.69,918.75,1015.88,1109.06,1361.72,1604.53,1780.08,1903.13,2132.81,3419.06,4154.06,4278.75,5103.00,6168.75,0.00,19.18,88.59,157.76,222.86,283.50,341.25,400.05,498.75,607.03,716.63,817.69,918.75,1015.88,1109.06,1361.72,1604.53,1780.08,1903.13,2132.81,3419.06,4154.06,4278.75,5103.00,6168.75,,,###36700000,Intelligence for Travel & Expense,367000003100,Intelligence for Travel & Expense,Setup Fee,,All,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,2343.75,2343.75,2343.75,2343.75,2343.75,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,2343.75,2343.75,2343.75,2343.75,2343.75,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,3125.00,,,###51412000,Introduction to Analysis,514120003100,Introduction to Analysis,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,313.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51411000,Introduction to Intelligence,514110003100,Introduction to Intelligence,Setup Fee,,All,313.00,,,,,,,,,,,,,,,,,,,,,,,,,625.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830000000,Invoice Capture,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.73,0.72,0.72,0.72,0.72,0.69,0.69,0.69,0.69,0.69,0.66,0.63,0.59,0.56,0.53,0.50,,,###37083000,Invoice Capture,370830004000,Invoice Capture,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,7.81,39.06,78.13,117.19,156.25,195.31,234.38,312.50,365.63,431.25,503.13,575.00,646.88,687.50,859.38,1031.25,1203.13,1375.00,1640.63,3125.00,4453.13,5625.00,7968.75,10000.00,,,###37083000,Invoice Capture,370830003100,Invoice Capture,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1093.75,1250.00,1250.00,1250.00,1250.00,1562.50,1562.50,1875.00,2187.50,2500.00,3125.00,3750.00,,,###37084000,Invoice Check Payments,370840000000,Invoice Check Payments,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.73,0.72,0.72,0.72,0.72,0.69,0.69,0.69,0.69,0.69,0.66,0.63,0.59,0.56,0.53,0.50,,,###37082000,Invoice Processing,370820000000,Invoice Processing,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3.75,3.75,3.05,2.53,2.19,1.91,1.91,1.91,1.79,1.78,1.69,1.68,1.63,1.61,1.57,1.57,1.57,1.57,1.53,1.40,1.27,1.20,1.14,1.04,0.99,,,###37082000,Invoice Processing,370820004000,Invoice Processing,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,37.50,152.50,252.50,329.06,382.50,478.13,573.75,715.00,890.63,1012.50,1172.50,1300.00,1451.25,1568.75,1960.94,2353.13,2745.31,3050.00,3500.00,6343.75,9000.00,11437.50,15656.25,19750.00,,,###37082000,Invoice Processing,370820003100,Invoice Processing,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1912.50,1912.50,1912.50,1912.50,2324.38,2756.25,2789.38,2796.88,3531.25,3984.38,4535.00,4980.63,5259.38,6056.25,6805.63,7371.25,7968.75,8500.00,8500.00,9456.25,12537.50,13148.75,15937.50,15937.50,19725.00,,,###51424000,Managed Reporting (12 Transactions),514240000000,Managed Reporting (12 Transactions),Usage Fee,,All,9.11,9.11,2.83,1.82,1.40,1.33,1.16,0.94,0.71,0.59,0.49,0.43,0.38,0.35,0.31,0.25,0.21,0.19,0.16,0.16,0.12,0.09,0.06,0.05,0.04,9.11,9.11,2.83,1.82,1.40,1.33,1.16,0.94,0.71,0.59,0.49,0.43,0.38,0.35,0.31,0.25,0.21,0.19,0.16,0.16,0.12,0.09,0.06,0.05,0.04,,,###51424000,Managed Reporting (12 Transactions),514240004000,Managed Reporting (12 Transactions),Base Fee,,All,0.00,91.13,141.25,181.88,210.00,265.00,289.06,281.25,285.00,293.75,296.25,297.50,305.00,315.00,312.50,312.50,318.75,328.13,325.00,390.63,593.75,656.25,625.00,750.00,875.00,0.00,91.13,141.25,181.88,210.00,265.00,289.06,281.25,285.00,293.75,296.25,297.50,305.00,315.00,312.50,312.50,318.75,328.13,325.00,390.63,593.75,656.25,625.00,750.00,875.00,,,###51424000,Managed Reporting (12 Transactions),514240003100,Managed Reporting (12 Transactions),Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###51425000,Managed Reporting (24 Transactions),514250000000,Managed Reporting (24 Transactions),Usage Fee,,All,17.31,17.31,5.37,3.46,2.66,2.52,2.20,1.78,1.35,1.12,0.94,0.81,0.72,0.67,0.59,0.48,0.40,0.36,0.31,0.30,0.23,0.17,0.12,0.10,0.08,17.31,5.37,3.46,2.66,2.52,2.20,1.78,1.35,1.12,0.94,0.81,0.72,0.67,0.59,0.48,0.40,0.36,0.31,0.30,0.23,0.17,0.12,0.10,0.08,0.04,,,###51425000,Managed Reporting (24 Transactions),514250004000,Managed Reporting (24 Transactions),Base Fee,,All,0.00,173.14,268.38,345.56,399.00,503.50,549.22,534.38,541.50,558.13,562.88,565.25,579.50,598.50,593.75,593.75,605.63,623.44,617.50,742.19,1128.13,1246.88,1187.50,1425.00,1662.50,0.00,53.68,172.78,266.00,377.63,439.38,445.31,406.13,446.50,469.06,484.50,507.06,532.00,534.38,475.00,504.69,534.38,540.31,593.75,564.06,831.25,890.63,950.00,1246.88,875.00,,,###51425000,Managed Reporting (24 Transactions),514250003100,Managed Reporting (24 Transactions),Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###51426000,Managed Reporting (36 Transactions),514260000000,Managed Reporting (36 Transactions),Usage Fee,,All,24.60,24.60,7.63,4.91,3.78,3.58,3.12,2.53,1.92,1.59,1.33,1.15,1.03,0.95,0.84,0.68,0.57,0.51,0.44,0.42,0.32,0.24,0.17,0.14,0.12,24.60,7.63,4.91,3.78,3.58,3.12,2.53,1.92,1.59,1.33,1.15,1.03,0.95,0.84,0.68,0.57,0.51,0.44,0.42,0.32,0.24,0.17,0.14,0.12,0.08,,,###51426000,Managed Reporting (36 Transactions),514260004000,Managed Reporting (36 Transactions),Base Fee,,All,0.00,246.04,381.38,491.06,567.00,715.50,780.47,759.38,769.50,793.13,799.88,803.25,823.50,850.50,843.75,843.75,860.63,885.94,877.50,1054.69,1603.13,1771.88,1687.50,2025.00,2362.50,0.00,76.28,245.53,378.00,536.63,624.38,632.81,577.13,634.50,666.56,688.50,720.56,756.00,759.38,675.00,717.19,759.38,767.81,843.75,801.56,1181.25,1265.63,1350.00,1771.88,1662.50,,,###51426000,Managed Reporting (36 Transactions),514260003100,Managed Reporting (36 Transactions),Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###NEWSKU4,Meeting Management ,NEWSKU43100,Meeting Management Application,Setup Fee,,All,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,1125.00,,,###NEWSKU4,Meeting Management ,NEWSKU40000,Meeting Management Application,Usage Fee,,All,1.88,1.88,1.88,1.88,1.88,1.88,1.88,1.88,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.41,1.41,1.41,1.25,1.25,1.25,1.88,1.88,1.88,1.88,1.88,1.88,1.88,1.88,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.56,1.41,1.41,1.41,1.25,1.25,1.25,,,###NEWSKU4,Meeting Management ,NEWSKU44000,Meeting Management Application,Base Fee,,All,0.00,18.75,93.75,187.50,281.25,375.00,468.75,562.50,625.00,781.25,937.50,1093.75,1250.00,1406.25,1562.50,1953.13,2343.75,2734.38,3125.00,3515.63,7031.25,10546.88,12500.00,18750.00,25000.00,0.00,18.75,93.75,187.50,281.25,375.00,468.75,562.50,625.00,781.25,937.50,1093.75,1250.00,1406.25,1562.50,1953.13,2343.75,2734.38,3125.00,3515.63,7031.25,10546.88,12500.00,18750.00,25000.00,,,###36426000,Meeting Management Custom Profile Setup,364260003100,Meeting Management Custom Profile Setup,Setup Fee,,All,938.00,,,,,,,,,,,,,,,,,,,,,,,,,938.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422800,Meeting Management Custom Site/Configuration,364228003100,Meeting Management Custom Site/Configuration,Setup Fee,,All,281.00,,,,,,,,,,,,,,,,,,,,,,,,,281.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890000000,Paper Receipt Handling,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,3.75,,,###37089000,Paper Receipt Handling,370890004000,Paper Receipt Handling,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,37.50,187.50,375.00,562.50,750.00,937.50,1125.00,1500.00,1875.00,2250.00,2625.00,3000.00,3375.00,3750.00,4687.50,5625.00,6562.50,7500.00,9375.00,18750.00,28125.00,37500.00,56250.00,75000.00,,,###37089000,Paper Receipt Handling,370890003100,Paper Receipt Handling,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,187.50,187.50,187.50,375.00,375.00,375.00,375.00,375.00,375.00,562.50,562.50,750.00,750.00,750.00,750.00,750.00,1078.13,1078.13,1078.13,1078.13,1437.50,1437.50,1437.50,1437.50,1437.50,,,###37030000,Policy Audit,370300000000,Policy Audit,Usage Fee,,All,3.99,3.99,3.99,3.99,3.99,3.83,3.83,3.83,3.83,3.71,3.57,3.43,3.29,3.16,3.04,2.98,2.92,2.86,2.72,2.56,2.31,2.13,2.09,2.09,2.09,3.99,3.99,3.99,3.99,3.99,3.83,3.83,3.83,3.83,3.71,3.57,3.43,3.29,3.16,3.04,2.98,2.92,2.86,2.72,2.56,2.31,2.13,2.09,2.09,2.09,,,###37030000,Policy Audit,370300004000,Policy Audit,Base Fee,,All,0.00,39.94,199.69,399.38,599.06,766.25,957.81,1149.38,1532.50,1856.25,2141.25,2397.50,2635.00,2846.25,3037.50,3718.75,4378.13,4998.44,5437.50,6390.63,11562.50,15984.38,20875.00,31312.50,41750.00,0.00,39.94,199.69,399.38,599.06,766.25,957.81,1149.38,1532.50,1856.25,2141.25,2397.50,2635.00,2846.25,3037.50,3718.75,4378.13,4998.44,5437.50,6390.63,11562.50,15984.38,20875.00,31312.50,41750.00,,,###37030000,Policy Audit,370300003100,Policy Audit,Setup Fee,,All,1250.00,1250.00,1250.00,1250.00,1250.00,1562.50,1649.38,2133.13,2896.88,3506.25,4420.00,4725.00,4875.00,5183.75,5484.38,5484.38,5484.38,5789.38,6500.00,7008.13,7190.63,7921.88,8328.13,8531.25,8531.25,1250.00,1250.00,1250.00,1250.00,1250.00,1562.50,1649.38,2133.13,2896.88,3506.25,4420.00,4725.00,4875.00,5183.75,5484.38,5484.38,5484.38,5789.38,6500.00,7008.13,7190.63,7921.88,8328.13,8531.25,8531.25,,,###37086000,Professional Author Roles,370860004000,Professional Author Roles,Base Fee,,All,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,25.00,,,###51416000,Project Team Jump Start Training for Expense ,514160003100,Project Team Jump Start Training for Expense ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5312.50,,,,,,,,,,,,,,,,,,,,,,,,,,,###51415000,Project Team Jump Start Training for Travel & Expense ,514150003100,Project Team Jump Start Training for Travel & Expense ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,6875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200000000,Receipt Audit,Usage Fee,,All,3.09,3.09,3.09,3.09,3.09,2.97,2.97,2.97,2.97,2.88,2.77,2.66,2.55,2.45,2.36,2.31,2.26,2.21,2.11,1.96,1.83,1.76,1.65,1.62,1.62,3.09,3.09,3.09,3.09,3.09,2.97,2.97,2.97,2.97,2.88,2.77,2.66,2.55,2.45,2.36,2.31,2.26,2.21,2.11,1.96,1.83,1.76,1.65,1.62,1.62,,,###37020000,Receipt Audit,370200004000,Receipt Audit,Base Fee,,All,0.00,30.94,154.69,309.38,464.06,593.75,742.19,890.63,1187.50,1440.63,1661.25,1859.38,2040.00,2205.00,2356.25,2882.81,3393.75,3871.88,4212.50,4906.25,9156.25,13171.88,16500.00,24281.25,32375.00,0.00,30.94,154.69,309.38,464.06,593.75,742.19,890.63,1187.50,1440.63,1661.25,1859.38,2040.00,2205.00,2356.25,2882.81,3393.75,3871.88,4212.50,4906.25,9156.25,13171.88,16500.00,24281.25,32375.00,,,###37020000,Receipt Audit,370200003100,Receipt Audit,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###51428000,Service Administration - Expense,514280000000,Service Administration - Expense,Usage Fee,,All,6.98,6.98,2.85,1.63,1.01,0.81,0.69,0.64,0.57,0.54,0.53,0.52,0.51,0.48,0.46,0.41,0.37,0.34,0.30,0.25,0.22,0.19,0.14,0.11,0.11,6.98,6.98,2.85,1.63,1.01,0.81,0.69,0.64,0.57,0.54,0.53,0.52,0.51,0.48,0.46,0.41,0.37,0.34,0.30,0.25,0.22,0.19,0.14,0.11,0.11,,,###51428000,Service Administration - Expense,514280004000,Service Administration - Expense,Base Fee,,All,0.00,69.81,142.50,162.50,151.88,161.25,173.44,191.25,227.50,268.75,318.75,363.13,405.00,433.13,456.25,515.63,553.13,590.63,600.00,625.00,1093.75,1406.25,1375.00,1593.75,2125.00,0.00,69.81,142.50,162.50,151.88,161.25,173.44,191.25,227.50,268.75,318.75,363.13,405.00,433.13,456.25,515.63,553.13,590.63,600.00,625.00,1093.75,1406.25,1375.00,1593.75,2125.00,,,###51428000,Service Administration - Expense,514280003100,Service Administration - Expense,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###51429000,Service Administration - Travel & Expense,514290000000,Service Administration - Travel & Expense,Usage Fee,,All,8.38,8.38,3.42,1.95,1.22,0.97,0.83,0.77,0.68,0.65,0.64,0.62,0.61,0.58,0.55,0.50,0.44,0.41,0.36,0.30,0.26,0.23,0.17,0.13,0.13,8.38,8.38,3.42,1.95,1.22,0.97,0.83,0.77,0.68,0.65,0.64,0.62,0.61,0.58,0.55,0.50,0.44,0.41,0.36,0.30,0.26,0.23,0.17,0.13,0.13,,,###51429000,Service Administration - Travel & Expense,514290004000,Service Administration - Travel & Expense,Base Fee,,All,0.00,83.78,171.00,195.00,182.25,193.50,208.13,229.50,273.00,322.50,382.50,435.75,486.00,519.75,547.50,618.75,663.75,708.75,720.00,750.00,1312.50,1687.50,1650.00,1912.50,2550.00,0.00,83.78,171.00,195.00,182.25,193.50,208.13,229.50,273.00,322.50,382.50,435.75,486.00,519.75,547.50,618.75,663.75,708.75,720.00,750.00,1312.50,1687.50,1650.00,1912.50,2550.00,,,###51429000,Service Administration - Travel & Expense,514290003100,Service Administration - Travel & Expense,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###36411800,Service Termination Extension ,364118003100,Service Termination Extension ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,3125.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###34000000,Single Sign-On,343000003100,Single Sign-On,Setup Fee,,All,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,1563.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###60510000,Third Party Meeting Registration - Modified Configuration,605100003100,Third Party Meeting Registration - Modified Configuration,Setup Fee,,All,1875.00,,,,,,,,,,,,,,,,,,,,,,,,,1875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36429000,Third-Party Meeting Registration - New Configuration,364290003100,Third-Party Meeting Registration - New Configuration,Setup Fee,,All,4688.00,,,,,,,,,,,,,,,,,,,,,,,,,4688.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422500,Third-Party Travel Integration ,364225003100,Third-Party Travel Integration ,Setup Fee,,All,2000.00,,,,,,,,,,,,,,,,,,,,,,,,,2000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51413000,Travel & Expense Advanced Configuration Training ,514130003100,Travel & Expense Advanced Configuration Training ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,6875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###50390000,Travel & Expense Boot Camp,503900003100,Travel & Expense Boot Camp,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,6875.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###34830000,Travel Agency Conversion,348300003100,Travel Agency Conversion,Setup Fee,,All,938.00,,,,,,,,,,,,,,,,,,,,,,,,,938.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000000000,Travel - Premier,Usage Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,1.83,1.83,1.69,1.50,1.41,1.35,1.30,1.27,1.19,1.16,1.14,1.11,1.09,1.08,1.06,1.04,1.02,0.97,0.91,0.81,0.65,0.53,0.41,0.33,0.29,,,###36500000,Travel Premier,365000004000,Travel - Premier,Base Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,0.00,18.25,84.38,150.00,211.88,270.00,325.00,380.63,475.00,578.13,682.50,778.75,875.00,967.50,1056.25,1296.88,1528.13,1695.31,1812.50,2031.25,3250.00,3937.50,4062.50,4875.00,5875.00,,,###36500000,Travel Premier,365000003100,Travel - Premier,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,468.75,468.75,625.00,625.00,1000.00,1000.00,1093.75,1093.75,1093.75,1093.75,1406.25,1562.50,1562.50,1562.50,1875.00,1875.00,2500.00,2500.00,2812.50,4062.50,4687.50,4687.50,4687.50,4687.50,4687.50,,,###31640000,Travel Set Up Post Initial Implementation ,316400003100,Travel Set Up Post Initial Implementation ,Setup Fee,,All,2188.00,,,,,,,,,,,,,,,,,,,,,,,,,2188.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000004000,TripIt Pro,Base Fee,,N/A,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000003100,TripIt Pro,Setup Fee,,N/A,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270000000,User Support Desk,Usage Fee,,All,0.91,0.91,0.86,0.78,0.74,0.71,0.71,0.67,0.63,0.59,0.59,0.59,0.59,0.59,0.59,0.59,0.57,0.56,0.54,0.47,0.38,0.31,0.25,0.21,0.19,0.91,0.91,0.86,0.78,0.74,0.71,0.71,0.67,0.63,0.59,0.59,0.59,0.59,0.59,0.59,0.59,0.57,0.56,0.54,0.47,0.38,0.31,0.25,0.21,0.19,,,###51427000,User Support Desk,514270004000,User Support Desk,Base Fee,,All,0.00,9.06,43.13,77.50,110.63,141.25,176.56,200.63,252.50,296.88,352.50,411.25,470.00,528.75,587.50,734.38,853.13,984.38,1087.50,1171.88,1875.00,2343.75,2500.00,3187.50,3875.00,0.00,9.06,43.13,77.50,110.63,141.25,176.56,200.63,252.50,296.88,352.50,411.25,470.00,528.75,587.50,734.38,853.13,984.38,1087.50,1171.88,1875.00,2343.75,2500.00,3187.50,3875.00,,,###51427000,User Support Desk,514270003100,User Support Desk,Setup Fee,,All,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,###36411400,USGSA Travel Allowance Rate Service ,364114003100,USGSA Travel Allowance Rate Service ,Setup Fee,,Professional/Premium,,,,,,,,,,,,,,,,,,,,,,,,,,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340000000,Web Services,Usage Fee,,All,5.56,5.56,2.20,1.36,0.98,0.77,0.64,0.54,0.44,0.37,0.32,0.28,0.25,0.23,0.20,0.20,0.19,0.19,0.18,0.16,0.13,0.11,0.08,0.06,0.06,5.56,5.56,2.20,1.36,0.98,0.77,0.64,0.54,0.44,0.37,0.32,0.28,0.25,0.23,0.20,0.20,0.19,0.19,0.18,0.16,0.13,0.11,0.08,0.06,0.06,,,###51434000,Web Services,514340004000,Web Services,Base Fee,,All,0.00,55.63,110.00,136.25,146.25,153.75,159.38,161.25,175.00,184.38,191.25,196.88,200.00,202.50,200.00,250.00,290.63,328.13,362.50,406.25,656.25,796.88,812.50,937.50,1125.00,0.00,55.63,110.00,136.25,146.25,153.75,159.38,161.25,175.00,184.38,191.25,196.88,200.00,202.50,200.00,250.00,290.63,328.13,362.50,406.25,656.25,796.88,812.50,937.50,1125.00,,,###51434000,Web Services,514340003100,Web Services,Setup Fee,,All,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,3125.00,3125.00,3125.00,4687.50,4687.50,4687.50,4687.50,6250.00,6250.00,6250.00,625.00,625.00,625.00,625.00,625.00,625.00,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,1562.50,3125.00,3125.00,3125.00,4687.50,4687.50,4687.50,4687.50,6250.00,6250.00,6250.00,,,###36422400,XML Profile Interface ,364224003100,XML Profile Interface ,Setup Fee,,All,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,1125.00,,,,,,,,,,,,,,,,,,,,,,,,,,, ";
str3 = "PO ID-APA,PO Name,PI ID,PI Name,Item Type,Edition,Impl Method,One Time,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411700,12 Week Test Entity ,364117003100,12 Week Test Entity ,Setup Fee,,AUS,4599.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411500,Add Cash Advance ,364115003100,Add Cash Advance ,Setup Fee,,AUS,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU2,Add Expense Pay  NA Post Initial Implementation ,NEWSKU23100,Add Expense Pay  NA Post Initial Implementation ,Setup Fee,,AUS,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Add Invoice ACH Payments Post Initial Implementation Setup,364220003100,Add Invoice ACH Payments Post Initial Implementation Setup,Setup Fee,,AUS,2500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36424000,Add New PNR Mapping Template,364240003100,Add New PNR Mapping Template,Setup Fee,,AUS,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36425000,Add New Profile Template,364250003100,Add New Profile Template,Setup Fee,,AUS,3679.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411200,Add Travel Allowance Configuration - Custom Import,364112003100,Add Travel Allowance Configuration - Custom Import,Setup Fee,,AUS,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411300,Add Travel Allowance Configuration - US GSA Import,364113003100,Add Travel Allowance Configuration - US GSA Import,Setup Fee,,AUS,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411600,Add Travel Request ,364116003100,Add Travel Request ,Setup Fee,,AUS,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422600,Additional Country/Configuration Setup,364226003100,Additional Country/Configuration Setup,Setup Fee,,AUS,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51422000,Additional Multi Country Expense Configuration ,514220003100,Additional Multi Country Expense Configuration ,Setup Fee,,AUS,30660.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36419000,Additional Policy Creation,364190003100,Additional Policy Creation,Setup Fee,,AUS,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51421000,Additional Single Country Expense Configuration ,514210003100,Additional Single Country Expense Configuration ,Setup Fee,,AUS,18396.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36418000,Additional Supported Corporate Card Feed,364180003100,Additional Supported Corporate Card Feed,Setup Fee,,AUS,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###31700000,Additional VAT Configuration,317000003100,Additional VAT Configuration,Setup Fee,,AUS,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###32810000,Additional Workflow Creation,328100003100,Additional Workflow Creation,Setup Fee,,AUS,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Automated ERP Import Interface ,364220003100,Automated ERP Import Interface ,Setup Fee,,AUS,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37087000,Business Author Roles,370870004000,Business Author Roles,Base Fee,,AUS,,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,,,,,,,,,,,,,,,,,,,,,,,,,,,###36417000,Certify New Coporate Card for Expense Pay,364170003100,Certify New Coporate Card for Expense Pay,Setup Fee,,AUS,4088.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36416000,Certify Non-Supported Corporate Card Feeds for Expense,364160003100,Certify Non-Supported Corporate Card Feeds for Expense,Setup Fee,,AUS,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50040000,Configuration Audit & Analysis,500400003100,Configuration Audit & Analysis,Setup Fee,,AUS,21462.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37088000,Consumer Roles,370880004000,Consumer Roles,Base Fee,,AUS,,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422300,Corporate Card Profile Data Interface ,364223003100,Corporate Card Profile Data Interface ,Setup Fee,,AUS,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422700,Corporate Travel Department ,364227003100,Corporate Travel Department ,Setup Fee,,AUS,5519.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51420000,Custom Connector,514200003100,Custom Connector,Setup Fee,,AUS,280.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50011000,Custom Consulting Services,500110003100,Custom Consulting Services,Setup Fee,,AUS,256.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50121000,Custom Extract File,501210003100,Custom Extract File,Setup Fee,,AUS,210.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51480000,Custom Onsite Training,514800003100,Custom Onsite Training,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51440000,Custom QuickStart Guide,514400003100,Custom QuickStart Guide,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50030000,Custom Reports,500300003100,Custom Reports,Setup Fee,,AUS,256.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51450000,Custom Training Materials,514500003100,Custom Training Materials,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51470000,Custom Virtual Training,514700003100,Custom Virtual Training,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51410000,Defined Extract File,514100003100,Defined Extract File,Setup Fee,,AUS,2100.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30842000,E-Invoice Import Set Up,308420003100,E-Invoice Import Set Up,Setup Fee,,AUS,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000000000,Expense,Usage Fee,,AUS,,11.48,11.48,11.05,9.83,9.27,8.82,8.54,8.32,7.78,7.57,7.36,7.14,6.93,6.72,6.51,6.30,6.08,5.87,5.66,5.04,4.38,3.44,2.80,2.52,2.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000004000,Expense,Base Fee,,AUS,,0.00,114.80,552.30,982.80,1390.20,1764.00,2135.00,2494.80,3113.60,3787.00,4418.40,4998.00,5544.00,6048.00,6510.00,7875.00,9114.00,10265.50,11312.00,12600.00,21910.00,25830.00,28000.00,37800.00,44800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000003100,Expense,Setup Fee,,AUS,,14000.00,14000.00,17885.00,20440.00,20440.00,22995.00,22995.00,24017.00,25550.00,30660.00,33215.00,35770.00,38325.00,40880.00,45990.00,48545.00,48545.00,51100.00,51100.00,53655.00,64386.00,66430.00,71540.00,71540.00,76650.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51414000,Expense Advanced Configuration Training ,514140003100,Expense Advanced Configuration Training ,Setup Fee,,AUS,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51417000,Expense Boot Camp ,514170003100,Expense Boot Camp ,Setup Fee,,AUS,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000000000,Expense,Usage Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000004000,Expense,Base Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000003100,Expense,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800000000,Expense Pay EMEA,Usage Fee,,AUS,,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,1.94,1.94,1.94,1.94,1.94,1.84,1.84,1.84,1.84,1.78,1.66,1.61,1.34,1.15,1.08,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800004000,Expense Pay EMEA,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800003100,Expense Pay EMEA,Setup Fee,,AUS,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2555.00,2555.00,2555.00,2555.00,2810.50,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700000000,Expense Pay North America,Usage Fee,,AUS,,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.52,1.43,1.43,1.43,1.43,1.43,1.36,1.33,1.33,1.33,1.27,1.14,1.10,0.83,0.64,0.57,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700004000,Expense Pay North America,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700003100,Expense Pay North America,Setup Fee,,AUS,,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###50122000,Extract Split,501220003100,Extract Split,Setup Fee,,AUS,2100.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30844000,FTP/PGP Set Up Fee,308440003100,FTP/PGP Set Up Fee,Setup Fee,,AUS,700.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36428000,GDS Conversion,364280003100,GDS Conversion,Setup Fee,,AUS,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51490000,Hands-On Report Authoring Class,514900003100,Hands-On Report Authoring Class,Setup Fee,,AUS,7972.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000000000,Intelligence for Expense,Usage Fee,,AUS,,1.72,1.72,1.66,1.47,1.39,1.32,1.28,1.25,1.17,1.14,1.10,1.07,1.04,1.01,0.98,0.95,0.91,0.88,0.85,0.76,0.66,0.52,0.42,0.38,0.34,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000004000,Intelligence for Expense,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000003100,Intelligence for Expense,Setup Fee,,AUS,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850000000,Intelligence for Invoice Processing,Usage Fee,,AUS,,0.92,0.92,0.75,0.62,0.54,0.47,0.47,0.47,0.44,0.44,0.41,0.41,0.40,0.40,0.38,0.38,0.38,0.38,0.37,0.34,0.31,0.29,0.28,0.26,0.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850004000,Intelligence for Invoice Processing,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850003100,Intelligence for Invoice Processing,Setup Fee,,AUS,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000000000,Intelligence for Travel & Expense,Usage Fee,,AUS,,3.01,3.01,2.90,2.58,2.43,2.32,2.24,2.18,2.04,1.99,1.93,1.88,1.82,1.76,1.71,1.65,1.60,1.54,1.48,1.32,1.15,0.91,0.74,0.66,0.59,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000004000,Intelligence for Travel & Expense,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000003100,Intelligence for Travel & Expense,Setup Fee,,AUS,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51412000,Introduction to Analysis,514120003100,Introduction to Analysis,Setup Fee,,AUS,511.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51411000,Introduction to Intelligence,514110003100,Introduction to Intelligence,Setup Fee,,AUS,1022.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830000000,Invoice Capture,Usage Fee,,AUS,,0.31,0.31,0.29,0.25,0.21,0.18,0.18,0.18,0.17,0.17,0.16,0.16,0.15,0.15,0.15,0.15,0.15,0.15,0.14,0.13,0.12,0.11,0.11,0.10,0.09,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830004000,Invoice Capture,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830003100,Invoice Capture,Setup Fee,,AUS,,521.22,521.22,521.22,521.22,623.42,623.42,623.42,681.67,822.71,958.64,977.03,1086.39,1194.72,1303.05,1520.74,1629.07,1629.07,1737.40,1737.40,1933.62,2302.57,2389.44,2606.10,2606.10,2823.79,,,,,,,,,,,,,,,,,,,,,,,,,,,###37084000,Invoice Check Payments,370840000000,Invoice Check Payments,Usage Fee,,AUS,,5.06,5.06,5.06,5.06,5.06,4.85,4.85,4.85,4.85,4.71,4.53,4.34,4.17,4.01,3.85,3.77,3.70,3.62,3.44,3.21,2.99,2.87,2.70,2.65,2.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820000000,Invoice Processing,Usage Fee,,AUS,,6.13,6.13,4.99,4.13,3.59,3.13,3.13,3.13,2.92,2.91,2.76,2.74,2.66,2.64,2.57,2.57,2.57,2.57,2.49,2.29,2.07,1.96,1.87,1.71,1.61,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820004000,Invoice Processing,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820003100,Invoice Processing,Setup Fee,,AUS,,3127.32,3127.32,3127.32,3127.32,3800.82,4507.02,4561.19,4573.45,5774.30,6515.25,7415.63,8144.32,8600.13,9903.18,11128.56,12053.47,13030.50,13899.20,13899.20,15462.86,20501.32,21500.84,26061.00,26061.00,32254.32,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240000000,Managed Reporting (12 Transactions),Usage Fee,,AUS,,14.90,14.90,4.62,2.97,2.29,2.17,1.89,1.53,1.17,0.96,0.81,0.69,0.62,0.57,0.51,0.41,0.35,0.31,0.27,0.26,0.19,0.14,0.10,0.08,0.07,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240004000,Managed Reporting (12 Transactions),Base Fee,,AUS,,0.00,149.01,230.97,297.40,343.39,433.33,472.68,459.90,466.03,480.34,484.43,486.47,498.74,515.09,511.00,511.00,521.22,536.55,531.44,638.75,970.90,1073.10,1022.00,1226.40,1430.80,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240003100,Managed Reporting (12 Transactions),Setup Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250000000,Managed Reporting (24 Transactions),Usage Fee,,AUS,,28.31,28.31,8.78,5.65,4.35,4.12,3.59,2.91,2.21,1.83,1.53,1.32,1.18,1.09,0.97,0.78,0.66,0.58,0.50,0.49,0.37,0.27,0.19,0.16,0.14,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250004000,Managed Reporting (24 Transactions),Base Fee,,AUS,,0.00,283.11,438.85,565.06,652.44,823.32,898.08,873.81,885.46,912.65,920.41,924.30,947.60,978.67,970.90,970.90,990.32,1019.45,1009.74,1213.63,1844.71,2038.89,1941.80,2330.16,2718.52,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250003100,Managed Reporting (24 Transactions),Setup Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260000000,Managed Reporting (36 Transactions),Usage Fee,,AUS,,40.23,40.23,12.47,8.03,6.18,5.85,5.10,4.14,3.15,2.59,2.18,1.88,1.68,1.55,1.38,1.10,0.94,0.83,0.72,0.69,0.52,0.39,0.28,0.22,0.19,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260004000,Managed Reporting (36 Transactions),Base Fee,,AUS,,0.00,402.32,623.62,802.99,927.16,1169.99,1276.22,1241.73,1258.29,1296.92,1307.96,1313.47,1346.59,1390.74,1379.70,1379.70,1407.29,1448.69,1434.89,1724.63,2621.43,2897.37,2759.40,3311.28,3863.16,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260003100,Managed Reporting (36 Transactions),Setup Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU43100,Meeting Management Application,Setup Fee,,AUS,,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU40000,Meeting Management Application,Usage Fee,,AUS,,3.07,3.07,3.07,3.07,3.07,3.07,3.07,3.07,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.30,2.30,2.30,2.04,2.04,2.04,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU44000,Meeting Management Application,Base Fee,,AUS,,0.00,30.66,153.30,306.60,459.90,613.20,766.50,919.80,1022.00,1277.50,1533.00,1788.50,2044.00,2299.50,2555.00,3193.75,3832.50,4471.25,5110.00,5748.75,11497.50,17246.25,20440.00,30660.00,40880.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36426000,Meeting Management Custom Profile Setup,364260003100,Meeting Management Custom Profile Setup,Setup Fee,,AUS,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422800,Meeting Management Custom Site/Configuration,364228003100,Meeting Management Custom Site/Configuration,Setup Fee,,AUS,460.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890000000,Paper Receipt Handling,Usage Fee,,AUS,,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890004000,Paper Receipt Handling,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890003100,Paper Receipt Handling,Setup Fee,,AUS,,306.60,306.60,306.60,613.20,613.20,613.20,613.20,613.20,613.20,919.80,919.80,1226.40,1226.40,1226.40,1226.40,1226.40,1762.95,1762.95,1762.95,1762.95,2350.60,2350.60,2350.60,2350.60,2350.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300000000,Policy Audit,Usage Fee,,AUS,,6.53,6.53,6.53,6.53,6.53,6.26,6.26,6.26,6.26,6.07,5.84,5.60,5.39,5.17,4.97,4.86,4.77,4.67,4.45,4.18,3.78,3.49,3.41,3.41,3.41,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300004000,Policy Audit,Base Fee,,AUS,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300003100,Policy Audit,Setup Fee,,AUS,,2044.00,2044.00,2044.00,2044.00,2044.00,2555.00,2697.06,3488.09,4736.97,5733.42,7227.58,7726.32,7971.60,8476.47,8968.05,8968.05,8968.05,9466.79,10628.80,11459.69,11758.11,12953.85,13618.15,13950.30,13950.30,,,,,,,,,,,,,,,,,,,,,,,,,,,###37086000,Professional Author Roles,370860004000,Professional Author Roles,Base Fee,,AUS,,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,,,,,,,,,,,,,,,,,,,,,,,,,,,###51416000,Project Team Jump Start Training for Expense ,514160003100,Project Team Jump Start Training for Expense ,Setup Fee,,AUS,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51415000,Project Team Jump Start Training for Travel & Expense ,514150003100,Project Team Jump Start Training for Travel & Expense ,Setup Fee,,AUS,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200000000,Receipt Audit,Usage Fee,,AUS,,5.06,5.06,5.06,5.06,5.06,4.85,4.85,4.85,4.85,4.71,4.53,4.34,4.17,4.01,3.85,3.77,3.70,3.62,3.44,3.21,2.99,2.87,2.70,2.65,2.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200004000,Receipt Audit,Base Fee,,AUS,,0.00,50.59,252.95,505.89,758.84,970.90,1213.63,1456.35,1941.80,2355.71,2716.48,3040.45,3335.81,3605.62,3852.94,4713.98,5549.46,6331.29,6888.28,8022.70,14972.30,21538.65,26980.80,39704.70,52939.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200003100,Receipt Audit,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280000000,Service Administration - Expense,Usage Fee,,AUS,,11.42,11.42,4.66,2.66,1.66,1.32,1.13,1.04,0.93,0.88,0.87,0.85,0.83,0.79,0.75,0.67,0.60,0.55,0.49,0.41,0.36,0.31,0.22,0.17,0.17,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280004000,Service Administration - Expense,Base Fee,,AUS,,0.00,114.16,233.02,265.72,248.35,263.68,283.61,312.73,372.01,439.46,521.22,593.78,662.26,708.25,746.06,843.15,904.47,965.79,981.12,1022.00,1788.50,2299.50,2248.40,2606.10,3474.80,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280003100,Service Administration - Expense,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290000000,Service Administration - Travel & Expense,Usage Fee,,AUS,,13.70,13.70,5.59,3.19,1.99,1.58,1.36,1.25,1.12,1.05,1.04,1.02,0.99,0.94,0.90,0.81,0.72,0.66,0.59,0.49,0.43,0.37,0.27,0.21,0.21,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290004000,Service Administration - Travel & Expense,Base Fee,,AUS,,0.00,136.99,279.62,318.86,298.02,316.41,340.33,375.28,446.41,527.35,625.46,712.54,794.71,849.90,895.27,1011.78,1085.36,1158.95,1177.34,1226.40,2146.20,2759.40,2698.08,3127.32,4169.76,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290003100,Service Administration - Travel & Expense,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411800,Service Termination Extension ,364118003100,Service Termination Extension ,Setup Fee,,AUS,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34000000,Single Sign-On,343000003100,Single Sign-On,Setup Fee,,AUS,3500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###60510000,Third Party Meeting Registration - Modified Configuration,605100003100,Third Party Meeting Registration - Modified Configuration,Setup Fee,,AUS,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36429000,Third-Party Meeting Registration - New Configuration,364290003100,Third-Party Meeting Registration - New Configuration,Setup Fee,,AUS,7665.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422500,Third-Party Travel Integration ,364225003100,Third-Party Travel Integration ,Setup Fee,,AUS,3270.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000000000,Expense,Usage Fee,,AUS,,11.48,11.48,11.05,9.83,9.27,8.82,8.54,8.32,7.78,7.57,7.36,7.14,6.93,6.72,6.51,6.30,6.08,5.87,5.66,5.04,4.38,3.44,2.80,2.52,2.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000004000,Expense,Base Fee,,AUS,,3519.77,3519.77,3386.70,6026.53,5683.14,5408.42,5236.73,5099.37,4773.15,6966.57,6773.41,8756.50,8498.95,8241.41,7983.86,7726.32,10711.68,10341.46,9971.25,8885.27,10300.33,8095.47,6581.68,5923.51,5265.34,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000003100,Expense,Setup Fee,,AUS,,2.87,2.87,2.76,2.46,2.31,2.21,2.14,2.07,1.95,1.89,1.83,1.79,1.74,1.68,1.62,1.57,1.53,1.47,1.41,1.26,1.09,0.87,0.70,0.63,0.56,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000000000,Travel,Usage Fee,,AUS,,879.94,879.94,845.60,1510.92,1416.49,1356.40,1313.47,1270.55,1193.29,1738.42,1686.91,2197.71,2129.03,2060.35,1991.67,1923.00,2690.26,2591.54,2492.81,2221.32,2566.86,2040.32,1645.42,1480.88,1316.34,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000004000,Travel,Base Fee,,AUS,,14000.00,14000.00,17885.00,20440.00,20440.00,22995.00,22995.00,24017.00,25550.00,30660.00,33215.00,35770.00,38325.00,40880.00,45990.00,48545.00,48545.00,51100.00,51100.00,53655.00,64386.00,66430.00,71540.00,71540.00,76650.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000003100,Travel,Setup Fee,,AUS,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,3066.00,3066.00,3066.00,4088.00,4088.00,4088.00,4088.00,4088.00,6132.00,8176.00,8176.00,8176.00,9811.20,10220.00,10220.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51413000,Travel & Expense Advanced Configuration Training ,514130003100,Travel & Expense Advanced Configuration Training ,Setup Fee,,AUS,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50390000,Travel & Expense Boot Camp,503900003100,Travel & Expense Boot Camp,Setup Fee,,AUS,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34830000,Travel Agency Conversion,348300003100,Travel Agency Conversion,Setup Fee,,AUS,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000000000,Travel - Premier,Usage Fee,,AUS,,2.87,2.87,2.76,2.46,2.31,2.21,2.14,2.07,1.95,1.89,1.83,1.79,1.74,1.68,1.62,1.57,1.53,1.47,1.41,1.26,1.09,0.87,0.70,0.63,0.56,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000004000,Travel - Premier,Base Fee,,AUS,,13199.13,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000003100,Travel - Premier,Setup Fee,,AUS,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,3066.00,3066.00,3066.00,4088.00,4088.00,4088.00,4088.00,4088.00,6132.00,8176.00,8176.00,8176.00,9811.20,10220.00,10220.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###31640000,Travel Set Up Post Initial Implementation ,316400003100,Travel Set Up Post Initial Implementation ,Setup Fee,,AUS,3577.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000004000,TripIt Pro,Base Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000003100,TripIt Pro,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270000000,User Support Desk,Usage Fee,,AUS,,1.48,1.48,1.41,1.27,1.21,1.15,1.15,1.09,1.03,0.97,0.96,0.96,0.96,0.96,0.96,0.96,0.93,0.92,0.89,0.77,0.61,0.51,0.41,0.35,0.32,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270004000,User Support Desk,Base Fee,,AUS,,6815.26,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270003100,User Support Desk,Setup Fee,,AUS,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411400,USGSA Travel Allowance Rate Service ,364114003100,USGSA Travel Allowance Rate Service ,Setup Fee,,AUS,5000.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340000000,Web Services,Usage Fee,,AUS,,9.10,9.10,3.60,2.23,1.59,1.26,1.04,0.88,0.72,0.60,0.52,0.46,0.41,0.37,0.33,0.33,0.32,0.31,0.30,0.27,0.21,0.17,0.13,0.10,0.09,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340004000,Web Services,Base Fee,,AUS,,41831.58,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340003100,Web Services,Setup Fee,,AUS,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,5110.00,5110.00,5110.00,7665.00,7665.00,7665.00,7665.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422400,XML Profile Interface ,364224003100,XML Profile Interface ,Setup Fee,,AUS,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, ";
str4 = "PO ID-APA,PO Name,PI ID,PI Name,Item Type,Edition,Impl Method,One Time,0,10,50,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000,2500,5000,7500,10000,15000,20000,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411700,12 Week Test Entity ,364117003100,12 Week Test Entity ,Setup Fee,,,4599.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411500,Add Cash Advance ,364115003100,Add Cash Advance ,Setup Fee,,,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU2,Add Expense Pay  NA Post Initial Implementation ,NEWSKU23100,Add Expense Pay  NA Post Initial Implementation ,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Add Invoice ACH Payments Post Initial Implementation Setup,364220003100,Add Invoice ACH Payments Post Initial Implementation Setup,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36424000,Add New PNR Mapping Template,364240003100,Add New PNR Mapping Template,Setup Fee,,,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36425000,Add New Profile Template,364250003100,Add New Profile Template,Setup Fee,,,3679.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411200,Add Travel Allowance Configuration - Custom Import,364112003100,Add Travel Allowance Configuration - Custom Import,Setup Fee,,,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411300,Add Travel Allowance Configuration - US GSA Import,364113003100,Add Travel Allowance Configuration - US GSA Import,Setup Fee,,,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411600,Add Travel Request ,364116003100,Add Travel Request ,Setup Fee,,,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422600,Additional Country/Configuration Setup,364226003100,Additional Country/Configuration Setup,Setup Fee,,,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51422000,Additional Multi Country Expense Configuration ,514220003100,Additional Multi Country Expense Configuration ,Setup Fee,,,30660.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36419000,Additional Policy Creation,364190003100,Additional Policy Creation,Setup Fee,,,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51421000,Additional Single Country Expense Configuration ,514210003100,Additional Single Country Expense Configuration ,Setup Fee,,,18396.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36418000,Additional Supported Corporate Card Feed,364180003100,Additional Supported Corporate Card Feed,Setup Fee,,,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###31700000,Additional VAT Configuration,317000003100,Additional VAT Configuration,Setup Fee,,,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###32810000,Additional Workflow Creation,328100003100,Additional Workflow Creation,Setup Fee,,,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422000,Automated ERP Import Interface ,364220003100,Automated ERP Import Interface ,Setup Fee,,,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37087000,Business Author Roles,370870004000,Business Author Roles,Base Fee,,,,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,30.66,,,,,,,,,,,,,,,,,,,,,,,,,,,###36417000,Certify New Coporate Card for Expense Pay,364170003100,Certify New Coporate Card for Expense Pay,Setup Fee,,,4088.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36416000,Certify Non-Supported Corporate Card Feeds for Expense,364160003100,Certify Non-Supported Corporate Card Feeds for Expense,Setup Fee,,,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50040000,Configuration Audit & Analysis,500400003100,Configuration Audit & Analysis,Setup Fee,,,21642.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37088000,Consumer Roles,370880004000,Consumer Roles,Base Fee,,,,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,76.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422300,Corporate Card Profile Data Interface ,364223003100,Corporate Card Profile Data Interface ,Setup Fee,,,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422700,Corporate Travel Department ,364227003100,Corporate Travel Department ,Setup Fee,,,5519.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51420000,Custom Connector,514200003100,Custom Connector,Setup Fee,,,280.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50011000,Custom Consulting Services,500110003100,Custom Consulting Services,Setup Fee,,,256.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50121000,Custom Extract File,501210003100,Custom Extract File,Setup Fee,,,210.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51480000,Custom Onsite Training,514800003100,Custom Onsite Training,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51440000,Custom QuickStart Guide,514400003100,Custom QuickStart Guide,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50030000,Custom Reports,500300003100,Custom Reports,Setup Fee,,,256.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51450000,Custom Training Materials,514500003100,Custom Training Materials,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51470000,Custom Virtual Training,514700003100,Custom Virtual Training,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51410000,Defined Extract File,514100003100,Defined Extract File,Setup Fee,,,2100.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30842000,E-Invoice Import Set Up,308420003100,E-Invoice Import Set Up,Setup Fee,,,2555.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000000000,Expense,Usage Fee,,,,11.48,11.48,11.05,9.83,9.27,8.82,8.54,8.32,7.78,7.57,7.36,7.14,6.93,6.72,6.51,6.30,6.08,5.87,5.66,5.04,4.38,3.44,2.80,2.52,2.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000004000,Expense,Base Fee,,,,0.00,114.80,552.30,982.80,1390.20,1764.00,2135.00,2494.80,3113.60,3787.00,4418.40,4998.00,5544.00,6048.00,6510.00,7875.00,9114.00,10265.50,11312.00,12600.00,21910.00,25830.00,28000.00,37800.00,44800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,364000003100,Expense,Setup Fee,,,,14000.00,14000.00,17885.00,20440.00,20440.00,22995.00,22995.00,24017.00,25550.00,30660.00,33215.00,35770.00,38325.00,40880.00,45990.00,48545.00,48545.00,51100.00,51100.00,53655.00,64386.00,66430.00,71540.00,71540.00,76650.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000000000,Expense,Usage Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000004000,Expense,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU,Expense integrated with Third-Party Travel,364000003100,Expense,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000000000,Expense,Usage Fee,,,,11.48,11.48,11.05,9.83,9.27,8.82,8.54,8.32,7.78,7.57,7.36,7.14,6.93,6.72,6.51,6.30,6.08,5.87,5.66,5.04,4.38,3.44,2.80,2.52,2.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000004000,Expense,Base Fee,,,,0.00,114.80,552.30,982.80,1390.20,1764.00,2135.00,2494.80,3113.60,3787.00,4418.40,4998.00,5544.00,6048.00,6510.00,7875.00,9114.00,10265.50,11312.00,12600.00,21910.00,25830.00,28000.00,37800.00,44800.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36400000,Expense,364000003100,Expense,Setup Fee,,,,14000.00,14000.00,17885.00,20440.00,20440.00,22995.00,22995.00,24017.00,25550.00,30660.00,33215.00,35770.00,38325.00,40880.00,45990.00,48545.00,48545.00,51100.00,51100.00,53655.00,64386.00,66430.00,71540.00,71540.00,76650.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51414000,Expense Advanced Configuration Training ,514140003100,Expense Advanced Configuration Training ,Setup Fee,,,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51417000,Expense Boot Camp ,514170003100,Expense Boot Camp ,Setup Fee,,,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800000000,Expense Pay EMEA,Usage Fee,,,,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,2.04,1.94,1.94,1.94,1.94,1.94,1.84,1.84,1.84,1.84,1.78,1.66,1.61,1.34,1.15,1.08,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800004000,Expense Pay EMEA,Base Fee,,,,0.00,20.44,102.20,204.40,306.60,408.80,511.00,613.20,817.60,1022.00,1165.08,1359.26,1553.44,1747.62,1941.80,2299.50,2759.40,3219.30,3679.20,4445.70,8278.20,12110.70,13388.20,17322.90,21666.40,,,,,,,,,,,,,,,,,,,,,,,,,,,###37080000,Expense Pay EMEA,370800003100,Expense Pay EMEA,Setup Fee,,,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2299.50,2555.00,2555.00,2555.00,2555.00,2810.50,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700000000,Expense Pay North America,Usage Fee,,,,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.52,1.43,1.43,1.43,1.43,1.43,1.36,1.33,1.33,1.33,1.27,1.14,1.10,0.83,0.64,0.57,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700004000,Expense Pay North America,Base Fee,,,,0.00,15.33,76.65,153.30,229.95,306.60,383.25,459.90,613.20,761.39,858.48,1001.56,1144.64,1287.72,1430.80,1699.08,1992.90,2325.05,2657.20,3168.20,5723.20,8278.20,8278.20,9657.90,11446.40,,,,,,,,,,,,,,,,,,,,,,,,,,,###37070000,Expense Pay North America,370700003100,Expense Pay North America,Setup Fee,,,,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###50122000,Extract Split,501220003100,Extract Split,Setup Fee,,,2100.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###30844000,FTP/PGP Set Up Fee,308440003100,FTP/PGP Set Up Fee,Setup Fee,,,700.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36428000,GDS Conversion,364280003100,GDS Conversion,Setup Fee,,,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51490000,Hands-On Report Authoring Class,514900003100,Hands-On Report Authoring Class,Setup Fee,,,7972.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000000000,Intelligence for Expense,Usage Fee,,,,1.72,1.72,1.66,1.47,1.39,1.32,1.28,1.25,1.17,1.14,1.10,1.07,1.04,1.01,0.98,0.95,0.91,0.88,0.85,0.76,0.66,0.52,0.42,0.38,0.34,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000004000,Intelligence for Expense,Base Fee,,,,0.00,17.22,82.85,147.42,208.53,264.60,320.25,374.22,467.04,568.05,662.76,749.70,831.60,907.20,976.50,1181.25,1367.10,1539.83,1696.80,1890.00,3286.50,3874.50,4200.00,5670.00,6720.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36600000,Intelligence for Expense,366000003100,Intelligence for Expense,Setup Fee,Premier,,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850000000,Intelligence for Invoice Processing,Usage Fee,Premier,,,0.92,0.92,0.75,0.62,0.54,0.47,0.47,0.47,0.44,0.44,0.41,0.41,0.40,0.40,0.38,0.38,0.38,0.38,0.37,0.34,0.31,0.29,0.28,0.26,0.24,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850004000,Intelligence for Invoice Processing,Base Fee,Premier,,,0.00,9.20,37.41,61.93,80.71,93.82,117.27,140.73,175.38,218.45,248.35,287.59,318.86,355.96,384.78,480.98,577.17,673.37,748.10,858.48,1556.00,2207.52,2805.39,3840.17,4844.28,,,,,,,,,,,,,,,,,,,,,,,,,,,###37085000,Intelligence for Invoice Processing,370850003100,Intelligence for Invoice Processing,Setup Fee,,,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000000000,Intelligence for Travel & Expense,Usage Fee,,,,3.01,3.01,2.90,2.58,2.43,2.32,2.24,2.18,2.04,1.99,1.93,1.88,1.82,1.76,1.71,1.65,1.60,1.54,1.48,1.32,1.15,0.91,0.74,0.66,0.59,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000004000,Intelligence for Travel & Expense,Base Fee,,,,0.00,30.14,144.94,258.13,364.71,463.34,560.81,654.44,817.32,993.72,1158.95,1313.00,1455.89,1587.60,1708.14,2065.35,2394.63,2695.98,2969.40,3307.50,5747.70,6791.40,7350.00,9922.50,11760.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36700000,Intelligence for Travel & Expense,367000003100,Intelligence for Travel & Expense,Setup Fee,,,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,3832.50,3832.50,3832.50,3832.50,3832.50,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51412000,Introduction to Analysis,514120003100,Introduction to Analysis,Setup Fee,,,511.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51411000,Introduction to Intelligence,514110003100,Introduction to Intelligence,Setup Fee,,,1022.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830000000,Invoice Capture,Usage Fee,,,,0.31,0.31,0.29,0.25,0.21,0.18,0.18,0.18,0.17,0.17,0.16,0.16,0.15,0.15,0.15,0.15,0.15,0.15,0.14,0.13,0.12,0.11,0.11,0.10,0.09,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830004000,Invoice Capture,Base Fee,,,,0.00,3.07,14.31,24.53,32.19,36.79,45.99,55.19,69.50,86.87,98.11,114.46,122.64,137.97,153.30,191.63,229.95,268.28,286.16,332.15,613.20,843.15,1124.20,1533.00,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37083000,Invoice Capture,370830003100,Invoice Capture,Setup Fee,,,,521.22,521.22,521.22,521.22,623.42,623.42,623.42,681.67,822.71,958.64,977.03,1086.39,1194.72,1303.05,1520.74,1629.07,1629.07,1737.40,1737.40,1933.62,2302.57,2389.44,2606.10,2606.10,2823.79,,,,,,,,,,,,,,,,,,,,,,,,,,,###37084000,Invoice Check Payments,370840000000,Invoice Check Payments,Usage Fee,,,,5.06,5.06,5.06,5.06,5.06,4.85,4.85,4.85,4.85,4.71,4.53,4.34,4.17,4.01,3.85,3.77,3.70,3.62,3.44,3.21,2.99,2.87,2.70,2.65,2.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820000000,Invoice Processing,Usage Fee,,,,6.13,6.13,4.99,4.13,3.59,3.13,3.13,3.13,2.92,2.91,2.76,2.74,2.66,2.64,2.57,2.57,2.57,2.57,2.49,2.29,2.07,1.96,1.87,1.71,1.61,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820004000,Invoice Processing,Base Fee,,,,0.00,61.32,249.37,412.89,538.08,625.46,781.83,938.20,1169.17,1456.35,1655.64,1917.27,2125.76,2373.08,2565.22,3206.53,3847.83,4489.14,4987.36,5723.20,10373.30,14716.80,18702.60,25601.10,32295.20,,,,,,,,,,,,,,,,,,,,,,,,,,,###37082000,Invoice Processing,370820003100,Invoice Processing,Setup Fee,,,,3127.32,3127.32,3127.32,3127.32,3800.82,4507.02,4561.19,4573.45,5774.30,6515.25,7415.63,8144.32,8600.13,9903.18,11128.56,12053.47,13030.50,13899.20,13899.20,15462.86,20501.32,21500.84,26061.00,26061.00,32254.32,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240000000,Managed Reporting (12 Transactions),Usage Fee,,,,14.90,14.90,4.62,2.97,2.29,2.17,1.89,1.53,1.17,0.96,0.81,0.69,0.62,0.57,0.51,0.41,0.35,0.31,0.27,0.26,0.19,0.14,0.10,0.08,0.07,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240004000,Managed Reporting (12 Transactions),Base Fee,,,,0.00,149.01,230.97,297.40,343.39,433.33,472.68,459.90,466.03,480.34,484.43,486.47,498.74,515.09,511.00,511.00,521.22,536.55,531.44,638.75,970.90,1073.10,1022.00,1226.40,1430.80,,,,,,,,,,,,,,,,,,,,,,,,,,,###51424000,Managed Reporting (12 Transactions),514240003100,Managed Reporting (12 Transactions),Setup Fee,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250000000,Managed Reporting (24 Transactions),Usage Fee,,,,28.31,28.31,8.78,5.65,4.35,4.12,3.59,2.91,2.21,1.83,1.53,1.32,1.18,1.09,0.97,0.78,0.66,0.58,0.50,0.49,0.37,0.27,0.19,0.16,0.14,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250004000,Managed Reporting (24 Transactions),Base Fee,,,,0.00,283.11,438.85,565.06,652.44,823.32,898.08,873.81,885.46,912.65,920.41,924.30,947.60,978.67,970.90,970.90,990.32,1019.45,1009.74,1213.63,1844.71,2038.89,1941.80,2330.16,2718.52,,,,,,,,,,,,,,,,,,,,,,,,,,,###51425000,Managed Reporting (24 Transactions),514250003100,Managed Reporting (24 Transactions),Setup Fee,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260000000,Managed Reporting (36 Transactions),Usage Fee,,,,40.23,40.23,12.47,8.03,6.18,5.85,5.10,4.14,3.15,2.59,2.18,1.88,1.68,1.55,1.38,1.10,0.94,0.83,0.72,0.69,0.52,0.39,0.28,0.22,0.19,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260004000,Managed Reporting (36 Transactions),Base Fee,,,,0.00,402.32,623.62,802.99,927.16,1169.99,1276.22,1241.73,1258.29,1296.92,1307.96,1313.47,1346.59,1390.74,1379.70,1379.70,1407.29,1448.69,1434.89,1724.63,2621.43,2897.37,2759.40,3311.28,3863.16,,,,,,,,,,,,,,,,,,,,,,,,,,,###51426000,Managed Reporting (36 Transactions),514260003100,Managed Reporting (36 Transactions),Setup Fee,,,,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,0.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU43100,Meeting Management Application,Setup Fee,,,,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU40000,Meeting Management Application,Usage Fee,,,,3.07,3.07,3.07,3.07,3.07,3.07,3.07,3.07,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.56,2.30,2.30,2.30,2.04,2.04,2.04,,,,,,,,,,,,,,,,,,,,,,,,,,,###NEWSKU4,Meeting Management ,NEWSKU44000,Meeting Management Application,Base Fee,,,,0.00,30.66,153.30,306.60,459.90,613.20,766.50,919.80,1022.00,1277.50,1533.00,1788.50,2044.00,2299.50,2555.00,3193.75,3832.50,4471.25,5110.00,5748.75,11497.50,17246.25,20440.00,30660.00,40880.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36426000,Meeting Management Custom Profile Setup,364260003100,Meeting Management Custom Profile Setup,Setup Fee,,,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422800,Meeting Management Custom Site/Configuration,364228003100,Meeting Management Custom Site/Configuration,Setup Fee,,,460.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890000000,Paper Receipt Handling,Usage Fee,,,,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,6.13,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890004000,Paper Receipt Handling,Base Fee,,,,0.00,61.32,306.60,613.20,919.80,1226.40,1533.00,1839.60,2452.80,3066.00,3679.20,4292.40,4905.60,5518.80,6132.00,7665.00,9198.00,10731.00,12264.00,15330.00,30660.00,45990.00,61320.00,91980.00,122640.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###37089000,Paper Receipt Handling,370890003100,Paper Receipt Handling,Setup Fee,,,,306.60,306.60,306.60,613.20,613.20,613.20,613.20,613.20,613.20,919.80,919.80,1226.40,1226.40,1226.40,1226.40,1226.40,1762.95,1762.95,1762.95,1762.95,2350.60,2350.60,2350.60,2350.60,2350.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300000000,Policy Audit,Usage Fee,,,,6.53,6.53,6.53,6.53,6.53,6.26,6.26,6.26,6.26,6.07,5.84,5.60,5.39,5.17,4.97,4.86,4.77,4.67,4.45,4.18,3.78,3.49,3.41,3.41,3.41,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300004000,Policy Audit,Base Fee,,,,0.00,65.31,326.53,653.06,979.59,1252.97,1566.22,1879.46,2505.94,3035.34,3501.37,3920.39,4308.75,4654.19,4966.92,6080.90,7159.11,8173.45,8891.40,10449.95,18907.00,26137.65,34134.80,51202.20,68269.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37030000,Policy Audit,370300003100,Policy Audit,Setup Fee,,,,2044.00,2044.00,2044.00,2044.00,2044.00,2555.00,2697.06,3488.09,4736.97,5733.42,7227.58,7726.32,7971.60,8476.47,8968.05,8968.05,8968.05,9466.79,10628.80,11459.69,11758.11,12953.85,13618.15,13950.30,13950.30,,,,,,,,,,,,,,,,,,,,,,,,,,,###37086000,Professional Author Roles,370860004000,Professional Author Roles,Base Fee,,,,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,40.88,,,,,,,,,,,,,,,,,,,,,,,,,,,###51416000,Project Team Jump Start Training for Expense ,514160003100,Project Team Jump Start Training for Expense ,Setup Fee,,,8687.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51415000,Project Team Jump Start Training for Travel & Expense ,514150003100,Project Team Jump Start Training for Travel & Expense ,Setup Fee,,,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200000000,Receipt Audit,Usage Fee,,,,5.06,5.06,5.06,5.06,5.06,4.85,4.85,4.85,4.85,4.71,4.53,4.34,4.17,4.01,3.85,3.77,3.70,3.62,3.44,3.21,2.99,2.87,2.70,2.65,2.65,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200004000,Receipt Audit,Base Fee,,,,0.00,50.59,252.95,505.89,758.84,970.90,1213.63,1456.35,1941.80,2355.71,2716.48,3040.45,3335.81,3605.62,3852.94,4713.98,5549.46,6331.29,6888.28,8022.70,14972.30,21538.65,26980.80,39704.70,52939.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###37020000,Receipt Audit,370200003100,Receipt Audit,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280000000,Service Administration - Expense,Usage Fee,,,,11.42,11.42,4.66,2.66,1.66,1.32,1.13,1.04,0.93,0.88,0.87,0.85,0.83,0.79,0.75,0.67,0.60,0.55,0.49,0.41,0.36,0.31,0.22,0.17,0.17,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280004000,Service Administration - Expense,Base Fee,,,,0.00,114.16,233.02,265.72,248.35,263.68,283.61,312.73,372.01,439.46,521.22,593.78,662.26,708.25,746.06,843.15,904.47,965.79,981.12,1022.00,1788.50,2299.50,2248.40,2606.10,3474.80,,,,,,,,,,,,,,,,,,,,,,,,,,,###51428000,Service Administration - Expense,514280003100,Service Administration - Expense,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290000000,Service Administration - Travel & Expense,Usage Fee,,,,13.70,13.70,5.59,3.19,1.99,1.58,1.36,1.25,1.12,1.05,1.04,1.02,0.99,0.94,0.90,0.81,0.72,0.66,0.59,0.49,0.43,0.37,0.27,0.21,0.21,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290004000,Service Administration - Travel & Expense,Base Fee,,,,0.00,136.99,279.62,318.86,298.02,316.41,340.33,375.28,446.41,527.35,625.46,712.54,794.71,849.90,895.27,1011.78,1085.36,1158.95,1177.34,1226.40,2146.20,2759.40,2698.08,3127.32,4169.76,,,,,,,,,,,,,,,,,,,,,,,,,,,###51429000,Service Administration - Travel & Expense,514290003100,Service Administration - Travel & Expense,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411800,Service Termination Extension ,364118003100,Service Termination Extension ,Setup Fee,,,5110.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34000000,Single Sign-On,343000003100,Single Sign-On,Setup Fee,,,3500.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###60510000,Third Party Meeting Registration - Modified Configuration,605100003100,Third Party Meeting Registration - Modified Configuration,Setup Fee,,,3066.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36429000,Third-Party Meeting Registration - New Configuration,364290003100,Third-Party Meeting Registration - New Configuration,Setup Fee,,,7665.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422500,Third-Party Travel Integration ,364225003100,Third-Party Travel Integration ,Setup Fee,,,3270.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000000000,Travel,Usage Fee,,,,2.87,2.87,2.76,2.46,2.31,2.21,2.14,2.07,1.95,1.89,1.83,1.79,1.74,1.68,1.62,1.57,1.53,1.47,1.41,1.26,1.09,0.87,0.70,0.63,0.56,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000004000,Travel,Base Fee,,,,0.00,28.70,137.90,246.40,346.50,442.40,535.50,621.60,778.40,945.00,1100.40,1254.40,1388.80,1512.00,1624.00,1960.00,2289.00,2572.50,2828.00,3150.00,5460.00,6510.00,7000.00,9450.00,11200.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36391120,Travel & Expense,365000003100,Travel,Setup Fee,,,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,3066.00,3066.00,3066.00,4088.00,4088.00,4088.00,4088.00,4088.00,6132.00,8176.00,8176.00,8176.00,9811.20,10220.00,10220.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000000000,Travel - Premier,Usage Fee,,,,2.87,2.87,2.76,2.46,2.31,2.21,2.14,2.07,1.95,1.89,1.83,1.79,1.74,1.68,1.62,1.57,1.53,1.47,1.41,1.26,1.09,0.87,0.70,0.63,0.56,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000004000,Travel - Premier,Base Fee,,,,0.00,28.70,137.90,246.40,346.50,442.40,535.50,621.60,778.40,945.00,1100.40,1254.40,1388.80,1512.00,1624.00,1960.00,2289.00,2572.50,2828.00,3150.00,5460.00,6510.00,7000.00,9450.00,11200.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36500000,Travel Premier,365000003100,Travel - Premier,Setup Fee,,,,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,2044.00,3066.00,3066.00,3066.00,4088.00,4088.00,4088.00,4088.00,4088.00,6132.00,8176.00,8176.00,8176.00,9811.20,10220.00,10220.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###51413000,Travel & Expense Advanced Configuration Training ,514130003100,Travel & Expense Advanced Configuration Training ,Setup Fee,,,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###50390000,Travel & Expense Boot Camp,503900003100,Travel & Expense Boot Camp,Setup Fee,,,11242.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###34830000,Travel Agency Conversion,348300003100,Travel Agency Conversion,Setup Fee,,,1533.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###31640000,Travel Set Up Post Initial Implementation ,316400003100,Travel Set Up Post Initial Implementation ,Setup Fee,,,3577.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000004000,TripIt Pro,Base Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###91600000,TripIt Pro,916000003100,TripIt Pro,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270000000,User Support Desk,Usage Fee,,,,1.48,1.48,1.41,1.27,1.21,1.15,1.15,1.09,1.03,0.97,0.96,0.96,0.96,0.96,0.96,0.96,0.93,0.92,0.89,0.77,0.61,0.51,0.41,0.35,0.32,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270004000,User Support Desk,Base Fee,,,,0.00,14.82,70.52,126.73,180.89,230.97,288.72,328.06,412.89,485.45,576.41,672.48,768.54,864.61,960.68,1200.85,1395.03,1609.65,1778.28,1916.25,3066.00,3832.50,4088.00,5212.20,6336.40,,,,,,,,,,,,,,,,,,,,,,,,,,,###51427000,User Support Desk,514270003100,User Support Desk,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###36411400,USGSA Travel Allowance Rate Service ,364114003100,USGSA Travel Allowance Rate Service ,Setup Fee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340000000,Web Services,Usage Fee,,,,9.10,9.10,3.60,2.23,1.59,1.26,1.04,0.88,0.72,0.60,0.52,0.46,0.41,0.37,0.33,0.33,0.32,0.31,0.30,0.27,0.21,0.17,0.13,0.10,0.09,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340004000,Web Services,Base Fee,,,,0.00,90.96,179.87,222.80,239.15,251.41,260.61,263.68,286.16,301.49,312.73,321.93,327.04,331.13,327.04,408.80,475.23,536.55,592.76,664.30,1073.10,1303.05,1328.60,1533.00,1839.60,,,,,,,,,,,,,,,,,,,,,,,,,,,###51434000,Web Services,514340003100,Web Services,Setup Fee,,,,1022.00,1022.00,1022.00,1022.00,1022.00,1022.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,2555.00,5110.00,5110.00,5110.00,7665.00,7665.00,7665.00,7665.00,10220.00,10220.00,10220.00,,,,,,,,,,,,,,,,,,,,,,,,,,,###36422400,XML Profile Interface ,364224003100,XML Profile Interface ,Setup Fee,,,1840.00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###";

csvArr = split( str4, "###" );
retArr = String[];
currentPriceList = "";
tierArr = String[];
implMethodIndex = -1;
retVal = "";
perQuantityIndex = -1;
perHourIndex = -1;
oneTimeIndex = -1;
PIDict = dict( "string" );
tempIDValue = 1;
for record in csvArr{
	// Holds data for the return string for this record
	recordArr = split( record, "," );
	// Define values speciifc to this pricelist
	if ( find( recordArr[0], "PO ID" ) <> -1 ){
		perQuantityIndex = -1;
		perHourIndex = -1;
		oneTimeIndex = -1;
		// Pricelist takes form of "PO ID-Pricelist
		poidArr = split( recordArr[0], "-" );
		currentPriceList = poidArr[1];
		tierArr = String[];
		implMethodIndex = findinarray( recordArr, "Impl Method" );
		// Iterate through the header to build tier information
		index = 0;
		for recordData in recordArr{
			// Append all numbers
			if ( recordData == "0" AND sizeofarray( tierArr ) <= 1 ){
				ZEROTIER_INDEX = index;
			}
			if ( recordData == "Per Quantity" ){
				perQuantityIndex = index;
			}
			if( recordData == "Per Hour" ){
				perHourIndex = index;
			}
			if( recordData == "One Time" ){
				oneTimeIndex = index;
			}
				
			if ( isnumber( recordData ) AND recordData <> "" ){
				append( tierArr, recordData );
			}
			index = index + 1;
		}
		continue;
	}
	// Loop through the tiers, generating all valid line items for this record
	index = ZEROTIER_INDEX - 1;
	min = "-1";
	max = "-1";
	implMethod = "";
	currentPIID = recordArr[PI_INDEX];
	if( containskey( PIDict, currentPIID ) <> true ){
		put( PIDict, currentPIID, "exists" );
	}else{
		currentPIID = "plHol" + string(tempIDValue);
		tempIdValue = tempIDValue + 1;
	}
	
	if ( recordArr[implMethodIndex ] == "AUS" ){
		implMethod = "AUS";
	}
	else{
		implMethod = "Standard";
	}
	exceptionDataArr = String[];
	if ( perQuantityIndex <> -1 AND recordArr[perQuantityIndex] <> "" ){
	append( exceptionDataArr, currentPIID );
		append( exceptionDataArr, "1" );
		append( exceptionDataArr, "9999999" );
		if ( implMethod == "AUS" ){
			append( exceptionDataArr, "AUS" );
		}
		else{
			append( exceptionDataArr, "" );
		}
		append( exceptionDataArr, recordArr[perQuantityIndex] );
		append( exceptionDataArr, "USD" );
		append( exceptionDataArr, currentPriceList );
		append( exceptionDataArr, "" );
		retVal = retVal + join( exceptionDataArr, "," ) + "###";
		index = index + 1;
		continue;
	}
	if ( perHourIndex <> -1 AND recordArr[perHourIndex] <> "" ){
	append( exceptionDataArr, currentPIID );
		append( exceptionDataArr, "1" );
		append( exceptionDataArr, "9999999" );
		if ( implMethod == "AUS" ){
			append( exceptionDataArr, "AUS" );
		}
		else{
			append( exceptionDataArr, "" );
		}
		append( exceptionDataArr, recordArr[perHourIndex] );
		append( exceptionDataArr, "USD" );
		append( exceptionDataArr, currentPriceList );
		append( exceptionDataArr, "" );
		retVal = retVal + join( exceptionDataArr, "," ) + "###";
		index = index + 1;
		continue;
	}
	if ( oneTimeIndex <> -1 AND recordArr[oneTimeIndex] <> "" ){
	append( exceptionDataArr, currentPIID );
		append( exceptionDataArr, "1" );
		append( exceptionDataArr, "9999999" );
		if ( implMethod == "AUS" ){
			append( exceptionDataArr, "AUS" );
		}
		else{
			append( exceptionDataArr, "" );
		}
		
		append( exceptionDataArr, recordArr[oneTimeIndex] );
		append( exceptionDataArr, "USD" );
		append( exceptionDataArr, currentPriceList );
		append( exceptionDataArr, "" );
		retVal = retVal + join( exceptionDataArr, "," ) + "###";
		index = index + 1;
		continue;
	}
	
	isAscending = false;
	
	for tier in tierArr{
		recordDataArr = String[];
		if ( min <> "-1" AND tier == "0" ){
			implMethod = "Professional";
		}
		// Case where we need to make an entry into the table
		if ( min <> "-1" AND recordArr[index] <> "" AND recordArr[index] <> "0.00"){
			append( recordDataArr, currentPIID );
			if( tier == "0" OR recordArr[index + 1] == "" ){
				max = "9999999";
			}
			else{
				tempMax = atoi(tier) - 1;
				max = string( tempMax );
			}
			if ( min == "0" ){
				min = "1";
			}
			if ( index == ZEROTIER_INDEX + 1 AND isnumber( recordArr[index] ) AND isnumber( recordArr[index - 1] ) ){
				previousValue = atof( recordArr[index - 1] );
				currentValue = atof( recordArr[index] );
				if ( currentValue > previousValue ){
					isAscending = true;
				}
			}
			append( recordDataArr, min );
			append( recordDataArr, max );
			append( recordDataArr, implMethod);
			if ( isAscending <> true ){
				append( recordDataArr, recordArr[index] );
			}
			else{
				tempFloat = atof( recordArr[index]);
				tempFloat = tempFloat / atoi( min );
				append( recordDataArr, string( tempFloat ));
			}
			append( recordDataArr, "USD" );
			append( recordDataArr, currentPriceList );
			append( recordDataArr, "" );
			retVal = retVal + join( recordDataArr, "," ) + "###";
			min = tier;
			index = index + 1;
			continue;
		}
		min = tier;
		index = index + 1;
	}
	tempMin = atoi( max ) + 1;
	min = string( tempMin );
	max = "9999999";
	recordDataArr = String[];
	if ( recordArr[index] <> "" AND recordArr[index] <> "0.00" ){
		append( recordDataArr, currentPIID );
		append( recordDataArr, min );
		append( recordDataArr, max );
		append( recordDataArr, implMethod );
		if ( isAscending <> true ){
			append( recordDataArr, recordArr[index] );
		}
		else{
			tempFloat = atof( recordArr[index]);
			tempFloat = tempFloat / atoi(min );
			append( recordDataArr, string(tempFloat ));
		}
		append( recordDataArr, "USD" );
		append( recordDataArr, currentPriceList );
		append( recordDataArr, "" );
		retVal = retVal + join( recordDataArr, "," ) + "###";
	}
}

return retVal;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5021152</id><bm_lib_func_id>5021150</bm_lib_func_id><param_name><![CDATA[input]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_processTierPricingWorksheet.bm_lib_func_param_input_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>114594112</id><name><![CDATA[Set Date to Last Day of Month]]></name><variable_name><![CDATA[setDateToLastDayOfMonth]]></variable_name><description><![CDATA[Set the string date passed in, to the last day of the month. Used for CSYS-37214.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>114594111</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_setDateToLastDayOfMonth]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>114594111</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setDateToLastDayOfMonth_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435936000</date_modified><guid><![CDATA[5609f4bb-be6d-43d3-b97e-ef9e6572a3e2]]></guid><script_size>998</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//Logic to set date strings to last day of the month
//applies to date strings in yyyy-MM-dd format

newDate = "";
yearVal = "";
monthVal = "";
dayVal = "";
splitNewDate = string[];

if( find(inputDate,"-") <> -1 ){
	splitNewDate = split(inputDate, "-");
	yearVal = splitNewDate[0];
	monthVal = splitNewDate[1];
	dayVal = splitNewDate[2];
}

isLeapYear = false;
if (isnumber(yearVal)){
	isLeapYear = isleap(atoi(yearVal)); 
}

daysDict = dict("integer");
put(daysDict,"00",31);
put(daysDict,"01",31);
if (NOT isLeapYear){put(daysDict,"02",28);}
else {put(daysDict,"02",29);}
put(daysDict,"03",31);
put(daysDict,"04",30);
put(daysDict,"05",31);
put(daysDict,"06",30);
put(daysDict,"07",31);
put(daysDict,"08",31);
put(daysDict,"09",30);
put(daysDict,"10",31);
put(daysDict,"11",30);
put(daysDict,"12",31);

if (sizeofarray(splitNewDate) > 0 AND isnumber(dayVal) AND isnumber(monthVal) AND isnumber(yearVal)){
	lastDayOfMonth = string(get(daysDict, monthVal));
	newDate = yearVal + "-" + monthVal + "-" + lastDayOfMonth;
}

return newDate;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>114594113</id><bm_lib_func_id>114594112</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setDateToLastDayOfMonth.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5030102</id><name><![CDATA[convertDictCurrency]]></name><variable_name><![CDATA[convertDictCurrency]]></variable_name><description></description><return_type>4</return_type><func_type>1</func_type><function_id>5030101</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_convertDictCurrency]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5030101</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_convertDictCurrency_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435927000</date_modified><guid><![CDATA[LEGACY_5030101]]></guid><script_size>309</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> convertDictCurrency
Converts a float attributes value to USD currency.

*/


// Lookup the Float Attribute 
foundValue = 0.0;
valueFound = false;

lookupKey = docNum + delimiter + commerceField;

if (containskey(floatsDict, lookupKey)) {
	foundValue = get(floatsDict, lookupKey);
	valueFound = true;
}

if ( valueFound <> true ){
	return false;
}

foundValue = foundValue * conversionFactor;
foundValue = round( foundValue, roundingDecimal );

put( floatsDict, lookupKey, foundValue );

return true;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5030104</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030105</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030106</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[delimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_delimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030107</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[commerceField]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_commerceField_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030108</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[conversionFactor]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>4</datatype><date_modified>1508547403000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_conversionFactor_4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5030109</id><bm_lib_func_id>5030102</bm_lib_func_id><param_name><![CDATA[roundingDecimal]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547403000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_convertDictCurrency.bm_lib_func_param_roundingDecimal_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5151700</id><name><![CDATA[Set XML Attribute]]></name><variable_name><![CDATA[setXMLAttribute]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>5151699</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_setXMLAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[xmlString = "<rampPlanDetails className='rampPlanDetails' rowCounterDisplayName='Ramp Plans' parentNodeName='rampPlanDetails' childNodeName='rampPlanDetail'><rampPlanDetail><from displayName='From' readOnly='false'>1</from><to displayName='To' readOnly='true'>4</to><transactions displayName='Transactions' readOnly='false'>1000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>5</from><to displayName='To' readOnly='true'>14</to><transactions displayName='Transactions' readOnly='false'>2000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>15</from><to displayName='To' readOnly='true'>and beyond</to><transactions displayName='Transactions' readOnly='false'>3000</transactions></rampPlanDetail></rampPlanDetails>";

elementArr = String[];
append( elementArr, "transactions" );
attributeArr = String[];
append( attributeArr, "displayName");
append( attributeArr, "someAttr");
DELIMITER = "@.@";

attributeValueDict = dict("string");
put(attributeValueDict, "transactions" + DELIMITER + "displayName", "someDisplay" );
put(attributeValueDict, "transactions" + DELIMITER + "someAttr", "someValue" );

spliceNodeName = "transactions";

numIndex = 3;

return util.setXMLAttribute(elementArr, attributeArr, DELIMITER, attributeValueDict, numIndex, xmlString );]]></main_script_text><_children><bm_function><id>5151699</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setXMLAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435928000</date_modified><guid><![CDATA[LEGACY_5151699]]></guid><script_size>976</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> Set XML Attribute */
/* Gives the specified XML element the specified attribute value. 
Affects all elements with that name */
/*
elementArr = String[];
attributeArr = String[];
DELIMITER = "@.@";
attributeValueDict = dict("string"); // Key element + DELIMITER + attribute, value = value of attribute
numberOfIndices
*/
result = "";

//openingTag = "<" + spliceNodeName;
spliceNodeIndex = -1;
spliceStartIndex = -1;
spliceEndIndex = -1;

remaining = originalXmlString;



newNodeValues = range( numberOfIndices );
for element in elementArr{
	for attribute in attributeArr{
		soFar = "";
		tempRemaining = remaining;
		elemAttrKey = element + DELIMITER + attribute;
		if ( containskey( attributeValueDict, elemAttrKey ) <> true ){
			continue;
		}
		attrValue = get( attributeValueDict, elemAttrKey );
		openingTag = "<" + element;
		spliceNodeIndex = -1;
		spliceStartIndex = -1;
		spliceEndIndex = -1;
		if ( find( tempRemaining, openingTag ) <> -1 ){
			for newValue in newNodeValues {			
				spliceNodeIndex = find(tempRemaining, openingTag + " ");
				if ( spliceNodeIndex == -1 ){
					spliceNodeIndex = find(tempRemaining, openingTag + ">" );
				}
				spliceEndIndex = find( tempRemaining, ">", spliceNodeIndex);
				valueIndex = find( tempRemaining, attribute, spliceNodeIndex, spliceEndIndex );
				// Case attribute already exists
				if ( valueIndex <> - 1 ){
					// Establish the input range for the value
					writeStartIndex = find( tempRemaining, "'", valueIndex );
					writeEndIndex = find( tempRemaining, "'", writeStartIndex + 1 );
					soFar = soFar + substring( tempRemaining, 0,writeStartIndex + 1) + attrValue;
					tempRemaining = substring( tempRemaining, writeEndIndex );
				}
				else{
					spliceEndIndex = spliceEndIndex;
					soFar = soFar + substring( tempRemaining, 0, spliceEndIndex ) + " " + attribute + "=" + "'" + attrValue + "'";
					tempRemaining = subString( tempRemaining, spliceEndIndex );
				}
			}
			remaining = soFar + tempRemaining;
		}
	}					
}
	
result = remaining;

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5151702</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[elementArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_elementArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5151703</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[attributeArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_attributeArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5151704</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[DELIMITER]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_DELIMITER_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5151705</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[attributeValueDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547403000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_attributeValueDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5151706</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[numberOfIndices]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547403000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_numberOfIndices_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5151707</id><bm_lib_func_id>5151700</bm_lib_func_id><param_name><![CDATA[originalXMLString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547403000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_setXMLAttribute.bm_lib_func_param_originalXMLString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4904401</id><name><![CDATA[getConversionRate]]></name><variable_name><![CDATA[getConversionRate]]></variable_name><description><![CDATA[NOT USED. Obtains the conversion rate for a specific currencyCode from the conversionRate commerce data table.]]></description><return_type>2</return_type><func_type>1</func_type><function_id>4904400</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getConversionRate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4904400</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getConversionRate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435925000</date_modified><guid><![CDATA[LEGACY_4904400]]></guid><script_size>223</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[conversionRate = 0.0;

conversionRateRecords = bmql("select conversionRate from currencyData where currencyCode = $currencyCode");

for conversionRateRecord in conversionRateRecords {
	rate = get(conversionRateRecord, "conversionRate");
	if (isnumber(rate)) {
		conversionRate = atof(rate);
		break;
	}
}

return conversionRate;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4904403</id><bm_lib_func_id>4904401</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getConversionRate.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4962263</id><name><![CDATA[Approval Triggers]]></name><variable_name><![CDATA[approvalTriggers]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4962262</function_id><date_modified>1626951330000</date_modified><guid><![CDATA[bm_lib_func_util_approvalTriggers]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4962262</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_approvalTriggers_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626951330000</date_modified><guid><![CDATA[LEGACY_4962262]]></guid><script_size>2129</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/******************************************************************************
* Triggering script.
* Takes the following parameters:
*
*  generic parameters:
*
*	historyMsgArray(string[]) - cells are[all history messages, in the correct order - based on ApprovalHierarchy table]
*	previousApprovalSequencer(string) - the previous revision's approval sequance string.
*	REVnum(integer) - the current revision number.
*
*
*  implementation specific:
*
*	
******************************************************************************/
//debugging tools:
debug = false;
debug1 = false;

ret = "";

/***************************************************************************\
|              GENERIC ATTRIBUTES AND ACTIONS - DO NOT CHANGE               |
\***************************************************************************/
AppFlag_varName = string[];
AppMsg_varName = string[];
Hierarchy_array = integer[];
PRVapprovalArray = string[];
reasonNameArray = string[];

approverGroupArray = string[];
approverLoginVarArray = string[];
approverLoginValueArray = string[];
//sequenceArray = string[];

pop=false;
if(previousApprovalSequencer == ""){
	pop=true;
}else{
	PRVapprovalArray = split(previousApprovalSequencer,"^_^");
}
key_dict = dict("integer");
reasonNum = 0;
rez = bmql("SELECT Sequence, ReasonName, FlagVarName, MSG_varName, HR_level, ApproverGroup, emailVar FROM ApprovalHierarchy ORDER BY HR_level");// ORDER BY HR_level  ORDER BY Level");
for entry in rez{
	append(AppFlag_varName,get(entry,"FlagVarName"));
	append(AppMsg_varName,get(entry,"MSG_varName"));
	append(Hierarchy_array,getint(entry,"HR_level"));
	append(approverGroupArray, get(entry, "ApproverGroup"));
	append(reasonNameArray, get(entry, "ReasonName"));
	append(approverLoginVarArray, get(entry, "emailVar"));
	//append(sequenceArray, get(entry,"FlagVarName") + "@_@" + string(getint(entry,"HR_level")) + "@_@" + get(entry, "ApproverGroup") + "@_@");
	put(key_dict,get(entry,"ReasonName"),getint(entry,"Sequence"));
	if(pop){PRVapprovalArray[reasonNum]="N";}
	reasonNum =reasonNum + 1;
}
reason_Key = string[reasonNum];//{"","","","","","","",""};//an array of reasons flags - MUST EQUAL NUMBER OF REASONS.
//approvalMsgArray = string[reasonNum];//{"","","","","","","",""};//an array of reason messages - MUST EQUAL NUMBER OF REASONS.
size = range(reasonNum);
for i in size{
	reason_Key[i] = "";
	//approvalMsgArray[i] = "";
}
/***************************************************************************\
|          END OF GENERIC ATTRIBUTES AND ACTIONS - change start             |
\***************************************************************************/

/******************************************************************************************\
|                                  MANUAL HARD CODED VALUES                                |
\******************************************************************************************/
//create an attribute per reason (with logical name) and assign the corresponding Key_dict value:
//reason1 = get(key_dict,"reason1");

//reason2 = get(Key_dict,"reason2");

/******************************************************************************************\
|                               END OF MANUAL HARD CODED VALUES                            |
\******************************************************************************************/

/*******************************************************************************************************\
|actual triggering: 																					|
|																										|
| For each reason use the script's parameted to evaluate the reason.									|
| if the reason should be fired - place the scripted message into the corresponding cell				|
| of the "approvalMsgArray" array.																				|
| 																										|
|	For example:																						|
|	if(reason1 == condition met){																		|
|		approvalMsgArray[reason1] = approvalMsgArray[reason1] + "reason 1 is me because " + meaningfull_value + ".";	|
|	}																									|
|																										|
| This will enable tracking if the reason is required after revision.									|
|																										|
\*******************************************************************************************************/

// Get the login values from the dictionary
for loginVar in approverLoginVarArray {
  if(containskey(approverLoginDict, loginVar)) {
    tempApproverLoginValue = get(approverLoginDict, loginVar);
    if(len(tempApproverLoginValue) > 0) {
      append(approverLoginValueArray, tempApproverLoginValue);
    } else {
      append(approverLoginValueArray, "NA");
    }
  } else {
    append(approverLoginValueArray, "NA");
  }
}
/**********************************************************\
|               END OF EDITABLE SECTION                    |
\**********************************************************/
for app in size {

	if(approvalMsgArray[app] <> historyMsgArray[app] AND approvalMsgArray[app] <> "" AND approverLoginValueArray[app] <> "NA"){//if the history changed always set to Q.
		reason_Key[app] = "Q"; 
	}else{
		if(PRVapprovalArray[app]=="N" OR PRVapprovalArray[app]=="A" OR approvalMsgArray[app] == "" OR approverLoginValueArray[app] == "NA"){//if the history is the same and the reason was approved in the last revision:
			reason_Key[app] = "N";//request the reason again.
		}else{
			reason_Key[app] = "Q";
		}
	}
}


Pflag = false;//Pending flag - true once the first reason is set to pending.
sequencer = "";
//reasonSequence = join(sequenceArray, "^_^");

size = range(sizeofarray(reason_Key));
HR_level = 1;

allPending = "";
currentPending = "";

for i in size {
	if(reason_Key[i] == "N"){								//if this reason is not required;
		sequencer = sequencer + "N^_^";							//set the sequencer to N
		ret = ret + "1~" + AppFlag_varName[i] + "~NA|";			//and the flag to "NA"
	} 
	elif(reason_Key[i] == "Q" AND HR_level <> Hierarchy_array[i] AND Pflag){					//if reason is required AND it is not the first reason:
		sequencer = sequencer + "Q^_^"; 						//set the sequencer to Q
		ret = ret + "1~" + AppFlag_varName[i] + "~queueing|";	//and the flag to "queueing"
		/*if(allPending <> "") {
		  allPending = allPending + ",";
		}
		allPending = allPending + approverVarArray[i];*/
		
	}
	else{													//if the reason is required AND it is the first reason:
		sequencer = sequencer + "P^_^";							//set the sequencer to "A"
		ret = ret + "1~" + AppFlag_varName[i] + "~pending|";	//and the trigger to "pending"
		HR_level = Hierarchy_array[i];
		/*if(currentPending <> "") {
		  currentPending = currentPending + ",";
		}
		currentPending = currentPending + approverVarArray[i];
		if(allPending <> "") {
		  allPending = allPending + ",";
		}
		allPending = allPending + approverVarArray[i];*/
		
		Pflag = true;											//set the flag to true.
	}
	ret = ret + "1~" + AppMsg_varName[i] + "~" + approvalMsgArray[i] + "|";
}

/*

put(miscStrDict, "allPending", allPending);
put(miscStrDict, "currentPending", currentPending);*/

sequencer = substring(sequencer,0,-3); //trim the last delimiter;
ret = ret + "1~sequence_quote~" + sequencer + "|";
//ret = ret + "1~approvalSequence_quote~" + reasonSequence + "|";
return ret;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4962265</id><bm_lib_func_id>4962263</bm_lib_func_id><param_name><![CDATA[approvalMsgArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626951330000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_approvalTriggers.bm_lib_func_param_approvalMsgArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4962266</id><bm_lib_func_id>4962263</bm_lib_func_id><param_name><![CDATA[historyMsgArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626951330000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_approvalTriggers.bm_lib_func_param_historyMsgArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4962267</id><bm_lib_func_id>4962263</bm_lib_func_id><param_name><![CDATA[previousApprovalSequencer]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_approvalTriggers.bm_lib_func_param_previousApprovalSequencer_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4977392</id><bm_lib_func_id>4962263</bm_lib_func_id><param_name><![CDATA[approverLoginDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626951330000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_approvalTriggers.bm_lib_func_param_approverLoginDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4904425</id><name><![CDATA[getRoundingDecimals]]></name><variable_name><![CDATA[getRoundingDecimals]]></variable_name><description><![CDATA[NOT USED. Obtains the number of rounding decimals for a specific currencyCode.]]></description><return_type>3</return_type><func_type>1</func_type><function_id>4904424</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getRoundingDecimals]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4904424</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRoundingDecimals_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435917000</date_modified><guid><![CDATA[LEGACY_4904424]]></guid><script_size>223</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[roundingDecimals = 0;

currencyDataRecords = bmql("select numDecimals from currencyData where currencyCode = $currencyCode");

for currencyDataRecord in currencyDataRecords {
	decimals = get(currencyDataRecord, "numDecimals");
	if (isnumber(decimals)) {
		roundingDecimals = atoi(decimals);
		break;
	}
}

return roundingDecimals;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4904427</id><bm_lib_func_id>4904425</bm_lib_func_id><param_name><![CDATA[currencyCode]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getRoundingDecimals.bm_lib_func_param_currencyCode_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>170672264</id><name><![CDATA[Get Attributes Dict Value]]></name><variable_name><![CDATA[getAttributesDictValue]]></variable_name><description><![CDATA[Parses a value from the attributes dict.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>170672263</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getAttributesDictValue]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>170672263</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAttributesDictValue_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435938000</date_modified><guid><![CDATA[6c4837a8-eeb0-4ea5-b787-700d9262afb9]]></guid><script_size>146</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[parsedVal = "";
ATTR_DELIMITER = "~";

if(valueString <> ""){
	parsedValSplit = split(valueString, ATTR_DELIMITER);
	parsedValSplitted = parsedValSplit[2]; 
	parsedVal = replace(parsedValSplitted , "|", "");
}

return parsedVal;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>170672265</id><bm_lib_func_id>170672264</bm_lib_func_id><param_name><![CDATA[valueString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getAttributesDictValue.bm_lib_func_param_valueString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4974819</id><name><![CDATA[buildCustomArraySetRow]]></name><variable_name><![CDATA[buildCustomArraySetRow]]></variable_name><description><![CDATA[NOT USED.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4974818</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_buildCustomArraySetRow]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4974818</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_buildCustomArraySetRow_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435913000</date_modified><guid><![CDATA[LEGACY_4974818]]></guid><script_size>420</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> buildCustomArraySetRow

from - String
to - String
transactions - String
undeletable - String
*/
result = "<div class='arraySetRow ";
if (undeletable) {
	result = result + " undeletable";
}
result = result + "'><div>";
result = result + "<input type='text' name='from' class='from' ";
if (isnumber(from) and atof(from) > 0.0) {
	result = result + "value='" + from + "'";
}
result = result + "/></div><div>";
result = result + "<input type='text' name='to' class='to' ";
if (isnumber(to) and atof(to) > 0.0) {
	result = result + "value='" + to + "'";
}
result = result + "/></div><div>";
result = result + "<input type='text' name='transactions' class='transactions'";
if (isnumber(transactions) and atof(transactions) > 0.0) {
	result = result + "value='" + transactions + "'";
}
result = result + "/></div></div>";

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4974828</id><bm_lib_func_id>4974819</bm_lib_func_id><param_name><![CDATA[from]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_buildCustomArraySetRow.bm_lib_func_param_from_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4974829</id><bm_lib_func_id>4974819</bm_lib_func_id><param_name><![CDATA[to]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_buildCustomArraySetRow.bm_lib_func_param_to_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4974830</id><bm_lib_func_id>4974819</bm_lib_func_id><param_name><![CDATA[transactions]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_buildCustomArraySetRow.bm_lib_func_param_transactions_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4974831</id><bm_lib_func_id>4974819</bm_lib_func_id><param_name><![CDATA[undeletable]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1508547402000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_buildCustomArraySetRow.bm_lib_func_param_undeletable_0]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>933157431</id><name><![CDATA[Is Date Within The Current Quarter]]></name><variable_name><![CDATA[isDateWithinTheCurrentQuarter]]></variable_name><description><![CDATA[CSYS-99026, it checks the input date is within current quarter or not.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>933157430</function_id><date_modified>1591278538000</date_modified><guid><![CDATA[bm_lib_func_util_isDateWithinTheCurrentQuarter]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>933157430</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_isDateWithinTheCurrentQuarter_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435942000</date_modified><guid><![CDATA[13f332c0-1ef1-461e-a397-856238f2d35e]]></guid><script_size>1634</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-99026 (OK. 5-14-2020) to check the input date is within current quarter or not
//DATE_FORMAT_PREFERENCE_SLASH = "MM/dd/yyyy";

DATE_FORMAT_PREFERENCE_HYPHEN = "yyyy-MM-dd";
result = false;
dateDelimiter = "-";
monthvalue = "";
dashString = "";
dateSplit = string[];
timezone = util.getUserTimeZone();
currentDate = datetostr(getdate());
currentDateText = substring(currentDate, 0, 10);
yearVal = "";
startDate = "";
endDate = "";
inputDateStr = substring(inputDate, 0, 10);
dashString1 = "";
dateSplit1 = string[];
dateValue = getdate();
currentQuarterStartDate = getdate();
currentQuarterEndDate = getdate();


if(inputDate <> "" AND NOT(isnull(inputDate)))
{
	if(find(inputDateStr,"-") <> -1 ){
		dashString1 = inputDateStr;
	}
	elif(find(inputDateStr,"/") <> -1 ){ 
		dateSplit1 = split(inputDateStr,"/");
		dashString1 = dateSplit1[2] + "-" + dateSplit1[0] + "-" + dateSplit1[1];
	}

	if(find(currentDateText,"-") <> -1 ){
		dateSplit = split(currentDateText,"-");
		monthvalue = dateSplit[1];
		yearVal = dateSplit[0];
	}
	elif( find(currentDateText,"/") <> -1 ){ 
		dateSplit = split(currentDateText,"/");
		dashString = dateSplit[2] + "-" + dateSplit[0] + "-" + dateSplit[1];
		dateSplit = split(dashString,"-");
		monthvalue = dateSplit[1];
		yearVal = dateSplit[0];
	}				
	
	//Calculating the Quarters based on Calendar date.
	if( sizeofarray(dateSplit) > 0 AND isnumber(monthvalue))
	{	
		month = atoi(monthvalue);		
		if (month > 0 AND month <=3){		
			StartDate = yearVal + "-01-01";
			endDate = yearVal + "-03-31";
		}
		if (month >= 4 AND month <=6){
			StartDate = yearVal + "-04-01";
			endDate = yearVal + "-06-30";
			}
		if (month >= 7 AND month <=9){
			StartDate = yearVal + "-07-01";
			endDate = yearVal + "-09-30";		
		}
		if (month >= 10 AND month <=12){
			StartDate = yearVal + "-10-01";
			endDate = yearVal + "-12-31";		
		}	
	}
	if(timezone <> ""){
		dateValue = strtojavadate(dashString1, DATE_FORMAT_PREFERENCE_HYPHEN, timezone);
		currentQuarterStartDate = strtojavadate(StartDate, DATE_FORMAT_PREFERENCE_HYPHEN, timezone);
		currentQuarterEndDate = strtojavadate(endDate, DATE_FORMAT_PREFERENCE_HYPHEN, timezone);
	}
	else{
		dateValue = strtojavadate(dashString1, DATE_FORMAT_PREFERENCE_HYPHEN);
		currentQuarterStartDate = strtojavadate(StartDate, DATE_FORMAT_PREFERENCE_HYPHEN);
		currentQuarterEndDate = strtojavadate(endDate, DATE_FORMAT_PREFERENCE_HYPHEN);
	}
	
	withinCurrentQuarter1 = comparedates(dateValue,currentQuarterStartDate);
	withinCurrentQuarter2 = comparedates(dateValue,currentQuarterEndDate);

	if(withinCurrentQuarter1 <> -1 AND withinCurrentQuarter2 <> 1){	
		result = true;
	}
}

return result;]]></script_text><_children><bm_lib_func_assoc><id>933157433</id><caller_func_id>933157430</caller_func_id><called_lib_func_id>170675968</called_lib_func_id><rule_area><![CDATA[Is Date Within The Current Quarter]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1591278538000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[df1730b5-0cfc-40ef-b19e-d3ce93bb3e4b]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>933157434</id><bm_lib_func_id>933157431</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1591278538000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_isDateWithinTheCurrentQuarter.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4839911</id><name><![CDATA[getConfigValue]]></name><variable_name><![CDATA[getConfigValue]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>4839910</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getConfigValue]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4839910</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getConfigValue_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435904000</date_modified><guid><![CDATA[LEGACY_4839910]]></guid><script_size>205</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = "";

configInfoSet = split(configAttrInfo, "|^|");
for eachConfigInfoSet in configInfoSet {
  configAttr = split(eachConfigInfoSet, "~");
  configAttrVarName = configAttr[0];
  configAttrVarValue = configAttr[2];
  if ( configAttrVarName == inputConfigInfoVarName ) {
    result = configAttrVarValue;
    break;
  }
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4839913</id><bm_lib_func_id>4839911</bm_lib_func_id><param_name><![CDATA[configAttrInfo]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getConfigValue.bm_lib_func_param_configAttrInfo_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4839914</id><bm_lib_func_id>4839911</bm_lib_func_id><param_name><![CDATA[inputConfigInfoVarName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547401000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getConfigValue.bm_lib_func_param_inputConfigInfoVarName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722817</id><name><![CDATA[Set Ramp Plan Data]]></name><variable_name><![CDATA[setRampPlanData]]></variable_name><description><![CDATA[Moved from pricing script.
Puts all of the ramp information in dictionaries.]]></description><return_type>10</return_type><func_type>1</func_type><function_id>15722816</function_id><date_modified>1652990318000</date_modified><guid><![CDATA[bm_lib_func_util_setRampPlanData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722816</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setRampPlanData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1652990318000</date_modified><guid><![CDATA[testconcur_12852346]]></guid><script_size>8858</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util.evaluateActionsAnd

This util is an export from the pricing script used to save space.
It sets up the ramp plans by creating pseudo line items, which just exist in the dictionaries.

10-20-2016: CSYS-70683 changes (KA):
>set howManyRamps for grouped Bases to that of the first core Base ramp plan
>set trxns for grouped Base ramp plans to that of the first core Base ramp plan
>> with the exception of products whose trxns do not have to match the core
>Made UNIT based extended service ramps behave like grouped extended service ramps

docNumlist = string[]
stringsDict
integersDict
floatsDict
*/
DELIMITER = "@.@";
TILDE_DELIMITER = "~";
PART_NUM = "_part_number";
SEQ_NUM = "_sequence_number";
PARENT_DOC_NUM = "_parent_doc_number";
IMPLEMENTATION_METHOD = "implementationMethod_line";
CORE_OFFERING = "coreOffering_line";
EDITION_LINE = "edition_line";
ADV_LEARNING_SERVICES_REQUIRED = "advLearningSvcsReqd_line";

QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
TRANSACTION_BY_BC = "transactionsBC";
PREV_TRANSACTIONS = "prevNumCommittedTransaction_line";
PREV_DISCOUNT = "prevDiscount_line";
IS_TRANS_OVERRIDDEN = "numTransOverride_line";
IS_GROUPED = "isPartOfPackage_line"; //This form field is checked if the user wishes to DYNAMICALLY GROUP this line item
IS_UNITBASED = "unitBasedTransaction";
IS_PRODUCTBASED = "productBasedTransaction_line";//CSYS-94381
PARENT_PRODUCT_POID_INDEX = "parentProductPOIDIndex";//CSYS-94381
PARENT_INDEX_DOC_NUM = "parentIndexDocNum";//CSYS-94381
TRANS_VALIDATION_APPLIES = "transValidationApplies"; //CSYS-70683
DISCOUNT = "discount_line";
DISCOUNT_TYPE = "discountType_line";
CORE_SERVICE = "Core Service";
INCREMENTAL_FEE = "Incremental";
BASE_FEE = "Base";

//Ramp plan attribute variable names
RAMP_PLAN_OVERRIDE = "overrideDefaultRampPlan_line";
RAMP_PLAN_DETAIL = "rampPlanDetails_line";
RAMP_PLAN_DETAIL_SAVE_XML = "rampPlanDetailXMLSave_line";
RAMP_DELIMITER = "-_**_-";
PO_RAMP_OVERRIDE = "poRampOverride";
PRIMARY_BASE_FEE = "primaryBaseFee";
ROLLUP_DOC_NUM = "rollupDocNum";
TRANS_STRING = "transString";
FROM = "from";
TO = "to";
RAMP_PLAN_MESSAGE = "rampPlanMessageText_line";
UNIT_BASED_CAN_HAVE_INDEPENDENT_RAMP_PLAN = "unitBasedCanHaveIndependentRampPlan";//CSYS-95500

// Used for Base Fee that are not rampable to unify
NUMBER_RAMP_ENTRIES = "numRampEntries";
TRANSACTION_RATIO = "transactionRatio";
PO_ID = "poId_line";
PI_ITEM_TYPE = "piItemType_line"; 
RAMP_FLAG = "rampFlag_line";
ROLL_UP = "rollUp_line";
PO_CATEGORY = "poCategory_line";
TRUE_STR = "true";
FALSE_STR = "false";
IS_RAMPABLE = "isRampable";
INCREMENTAL_FEE_FOR_PO = "incrementalFeeForPO";
INCREMENTAL_PI = "incrementalPi";
CONFIG_IMPLEMENTATION_METHODS = "implementationMethods_concur";

// Set all ramp plan information to be used later in the script.
// This includes transactions and prices
newDocNumList = String[];

for docNum in docNumList {
	append( newDocNumList, docNum );
	itemType = get( stringsDict, docNum + DELIMITER + PI_ITEM_TYPE );
	// Convert the number of transactions into index form
	isRampable = FALSE_STR;
	howManyRamps = 0; //renamed from howManyTransactions to howManyRamps for CSYS-70683
	poID = "";
	parentDocNum = "";
	poRampOverride = "";
	rollupDocNum = "";
	primaryBaseDocNum = "";
	isGrouped = "";
	unitBased = ""; //CSYS-70683
	transValidation = ""; //CSYS-70683
	poCat = ""; //CSYS_70683
	rampFlag = "";
	lineTransactions = 0;
	isProductBased = "";
	pi = "";
	transString = "";
	unitBasedCanHaveIndependentRamps = "";
	overrideRampPrice = "";
	childTransString = "";  //CSYS-105113 (OK. 12-28-2021)
	
	if ( containskey( stringsDict, docNum + DELIMITER + PO_ID ) ){
		poID = get( stringsDict, docNum + DELIMITER + PO_ID );
	}

	if( containskey(stringsDict,docNum + DELIMITER + PART_NUM )){ //CSYS-70683
		pi = get( stringsDict, docNum + DELIMITER + PART_NUM );
	}

	if(containskey( stringsDict, docNum + DELIMITER + PARENT_DOC_NUM )){
		parentDocNum = get( stringsDict, docNum + DELIMITER + PARENT_DOC_NUM );
	}

	if(containskey( stringsDict, parentDocNum + RAMP_DELIMITER  + poID + DELIMITER + PO_RAMP_OVERRIDE )){
		poRampOverride = get( stringsDict, parentDocNum + RAMP_DELIMITER + poID + DELIMITER + PO_RAMP_OVERRIDE );
	}

	if(containskey( stringsDict, parentDocNum + RAMP_DELIMITER + poID + DELIMITER + ROLLUP_DOC_NUM )){
		rollupDocNum = get( stringsDict, parentDocNum + RAMP_DELIMITER + poID + DELIMITER + ROLLUP_DOC_NUM );
	}

	if(containskey( stringsDict, parentdocNum + DELIMITER + PRIMARY_BASE_FEE )){
		primaryBaseDocNum = get( stringsDict, parentdocNum + DELIMITER + PRIMARY_BASE_FEE );
	}

	if(containskey( stringsDict, docNum + DELIMITER + IS_GROUPED )){
		isGrouped = get( stringsDict, docNum + DELIMITER + IS_GROUPED );
	}

	if(containskey( stringsDict, docNum + DELIMITER + IS_UNITBASED )){ //CSYS-70683
		unitBased = get( stringsDict, docNum + DELIMITER + IS_UNITBASED );
	}

	if(poID <> "" AND containskey( stringsDict, poID + DELIMITER + TRANS_VALIDATION_APPLIES )){ //CSYS-70683
		transValidation = get( stringsDict, poID + DELIMITER + TRANS_VALIDATION_APPLIES );
	}

	if(containskey( stringsDict, docNum + DELIMITER + PO_CATEGORY )){ //CSYS-70683
		poCat = get( stringsDict, docNum + DELIMITER + PO_CATEGORY );
	}

	if(containskey( stringsDict, docNum + DELIMITER + RAMP_FLAG )){
		rampFlag = get( stringsDict, docNum + DELIMITER + RAMP_FLAG );
	}

	if(containskey( integersDict, docNum + DELIMITER + TRANSACTIONS ))	{
		lineTransactions = get( integersDict, docNum + DELIMITER + TRANSACTIONS );
	}

	if(containskey( stringsDict, docNum + DELIMITER + IS_PRODUCTBASED ))	{//CSYS-94381 (LN. 1-9-2019) Determined in Pricing
		isProductBased = get( stringsDict, docNum + DELIMITER + IS_PRODUCTBASED );
	}

	//CSYS-95500 (LN. 4-24-2019) Determined in Pricing
	if(containskey( stringsDict, docNum + DELIMITER + UNIT_BASED_CAN_HAVE_INDEPENDENT_RAMP_PLAN )){
		unitBasedCanHaveIndependentRamps = get( stringsDict, docNum + DELIMITER + UNIT_BASED_CAN_HAVE_INDEPENDENT_RAMP_PLAN );
	}

	//CSYS-95500 (LN. 4-24-2019) Determined in Pricing
	if(containskey( stringsDict, docNum + DELIMITER + "overrideRampPrice" )){
		overrideRampPrice = get( stringsDict, docNum + DELIMITER + "overrideRampPrice" );
	}
	
	//CSYS-95500 (LN. 4-24-2019) Allowing CREATE Unit Based Products to have independent ramps in a given scenario
	if ( ((transValidation == TRUE_STR OR poCat == CORE_SERVICE) AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR))) OR (poCat <> CORE_SERVICE AND transValidation <> TRUE_STR AND isGrouped == TRUE_STR) /*added the transValidation, poCategory, and unitBased checks for CSYS-70683*/
		OR (poCat <> CORE_SERVICE AND transValidation <> TRUE_STR AND unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR)){ //CSYS-101182 (TT. 03/12/2020)

		poRampOverride = "";
		rollupDocNum = primaryBaseDocNum;
		
		if(containskey(stringsDict, rollupDocNum + DELIMITER + RAMP_PLAN_OVERRIDE)) {
			poRampOverride = get(stringsDict, rollupDocNum + DELIMITER + RAMP_PLAN_OVERRIDE);
		}
		
		// Move the XML from the Core Base Fee to this documents Ramp XML
		if ( itemType == BASE_FEE ){

			rampXML = "";
			fromValue = "";
			toValue = "";

			if ( containskey( stringsDict, rollupDocNum + DELIMITER + RAMP_PLAN_DETAIL )){
				rampXML = get( stringsDict, rollupDocNum + DELIMITER + RAMP_PLAN_DETAIL );
			}

			if ( containskey( stringsDict, rollupDocNum + DELIMITER + FROM )){
				fromValue = get( stringsDict, rollupDocNum + DELIMITER + FROM );
			}

			if( containskey( stringsDict, rollupDocNum + DELIMITER + TO )){
				toValue = get( stringsDict, rollupDocNum + DELIMITER + TO );
			}

			//At some point, we may consider parsing ramp transactions here, to prevent the rare mismatch
			//even though the rare mismatch is corrected upon Save/Submit

			put( stringsDict, docNum + DELIMITER + RAMP_PLAN_DETAIL, rampXML );
			put( stringsDict, docNum + DELIMITER + FROM, fromValue );
			put( stringsDict, docNum + DELIMITER + TO, toValue );
		}
	}

	if ( rollupDocNum == "" ){
		rollupDocNum = docNum;
	}

	if ( containskey( stringsDict, docNum + DELIMITER + TRANS_STRING  )){

		//CSYS-94381 (LN. 1-9-2019) Grab the transaction string from the Parent Base Fee and assign it to it's cooresponding Child Base Fee
		if(containskey(stringsDict, poID + DELIMITER + PARENT_INDEX_DOC_NUM) AND itemType == BASE_FEE){
			parentDocNumRamp = get(stringsDict, poID + DELIMITER + PARENT_INDEX_DOC_NUM);
			transString = get( stringsDict, parentDocNumRamp + DELIMITER + TRANS_STRING );
			childTransString = transString;  //CSYS-105113 (OK. 12-28-2021)
		}
		else {//otherwise business as usual

			/*
				CSYS-95500 (LN. 4-24-2019)
				If the Core service only has one Ramp, allow CREATE Unit Based Products to add more than one ramp, where each ramp's TRXN count will always match the
				final ramp.
					Example:
						Ramp 1: 1-2, 250 Trxns
						Ramp 2: 3-4, 250 Trxns
						Ramp 3: 4 and beyond, 250 Trxns
			*/
			if(unitBased == TRUE_STR AND itemType == BASE_FEE){
				transArray = split(get( stringsDict, docNum + DELIMITER + TRANS_STRING ), DELIMITER);

				if(unitBasedCanHaveIndependentRamps == TRUE_STR){
					if(sizeofarray(transArray) > 1){
						finalRampTrxnIndex = sizeofarray(transArray) -1;
						trans = transArray[finalRampTrxnIndex];
						newTransArray = String[];

						for eachIndex in transArray {
							append(newTransArray, trans);
						}

						transString = join(newTransArray, DELIMITER);
						put(stringsDict, docNum + DELIMITER + TRANS_STRING, transString);
					}
					else {
						//If there is only one ramp, set Overrirde Default Famp to FALSE
						poRampOverride = "";
					}
				}
				
				//Set Override Default Ramp to TRUE when Override Ramp Price is TRUE
				if(overrideRampPrice == TRUE_STR){
					poRampOverride = TRUE_STR;
				}
				
			}
			
			transString = get( stringsDict, docNum + DELIMITER + TRANS_STRING );
				
		}
		
	}

	transArr = split( transString, DELIMITER );
	
	// If we are rampable
	finalTransactionRatio = 1;

	if ( itemType == BASE_FEE AND rampFlag == "Y"){ 

		isRampable = TRUE_STR;
		
		/* 
		We are setting all grouped line item ramp plans to have the same ratio as the Primary Core Ramp plan.  We do not 
		want to force change if we do not need to.  If we do, we want to break down the transactions, find the ratio, and
		apply it to the current transactions 
		
		CSYS-70683 - added the transValidation, poCategory, and unitBased checks
		CSYS-94381 - (LN. 1-9-2019) added the isProductBased check
		CSYS-95500 (LN. 4-24-2019) Allowing CREATE Unit Based Products to have independent ramps in a given scenario
		*/
		if ( rollupDocNum <> docNum AND 
			((transValidation == TRUE_STR OR poCat == CORE_SERVICE) AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR) )) OR
			(poCat <> CORE_SERVICE AND transValidation <> TRUE_STR AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR))) OR isProductBased == TRUE_STR ){//CSYS-101182 TT (03/12/2020)
			
			//CSYS-94381 - (LN. 1-9-2019) Dynamically set the Ramp Plan Message via the messageTable based on this Child's Base PI number
			if(containskey(stringsDict, poID + DELIMITER + PARENT_INDEX_DOC_NUM)){
				tableRes = BMQL("SELECT messageCode FROM messageTable WHERE basePi = $pi");

				dynamicMessage = "";

				for entry in tableRes {
					dynamicMessage = get(entry, "messageCode");
				}

				put( stringsDict, docNum + DELIMITER + RAMP_PLAN_MESSAGE, dynamicMessage );
			}
			else {//business as usual, display the UNIT/Bundled language 
				put( stringsDict, docNum + DELIMITER + RAMP_PLAN_MESSAGE, "RAMP_PLAN_GROUPED_READ_ONLY" );
			}
			
			
			newTransRatios = Float[];
			newTransArr = String[];
			coretransString = "";
			
			//CSYS-101182 (TT. 12/07/2020)
			//Ramp's tranx count
			if ( containskey( stringsDict, rollupDocNum + DELIMITER + TRANS_STRING  )){
				coretransString = get( stringsDict, rollupDocNum + DELIMITER + TRANS_STRING );
			}
			coreTransArr = split( coretransString, DELIMITER );
			
			//CSYS-105113 (OK. 12-28-2021) Audit SLA product is considered as child product. so it should have the same ramp transaction count of parent product. example: Policy Audit or Receipt Audit
			if (childTransString <> "") {
				coreTransArr = split( childTransString, DELIMITER );
			}
			
			//Core's committed tranx
			coreTransactions = get( integersDict, rollupDocNum + DELIMITER + TRANSACTIONS );

			for transaction in coreTransArr{

				if ( lineTransactions <> 0 ){

					customAtoiNumber = 0;

					if ( isnumber( transaction )){
						customAtoiNumber = integer(atof(transaction));
					}
					//LIN: Updated the condition for divide by 0 error for INC0396866
					if ( coreTransactions <> 0 ){
						transRatio = (customAtoiNumber*1.0) / (coreTransactions*1.0);
					}
					// End
				}
				else{

					transRatio = 1.0;
				}

				append( newTransRatios, transRatio );
			}

			if ( coreTransactions <> 0 ){
				finalTransactionRatio = (lineTransactions*1.0)/ (coreTransactions*1.0 );
			}

			for newRatio in newTransRatios{

				newRampTransaction = round(newRatio * lineTransactions, 0 );
				append( newTransArr, String(newRampTransaction) );
			}

			transArr = newTransArr;
		}

		//CSYS-95500 (LN 4-24-2019) Display an alternative message for those CREATE Unit Based Products that can have independent ramps
		if(unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps == TRUE_STR){
			put( stringsDict, docNum + DELIMITER + RAMP_PLAN_MESSAGE, "RAMP_PLAN_UNIT_BASED_INDEPENDENT_RAMPS_TRANS_COUNT" );
		}

		howManyRamps = sizeofarray( transArr );
	}

	put( stringsDict, docNum + DELIMITER + IS_RAMPABLE, isRampable );

	if ( isRampable == TRUE_STR ){

		/*
		CSYS-70683 - added the transValidation, poCategory, and unitBased checks
		CSYS-94381 - (LN. 1-9-2019) added the isProductBased check
		CSYS-95500 (LN. 4-24-2019) Allowing CREATE Unit Based Products to have independent ramps in a given scenario
		*/
		
		if ( rollupDocNum <> docNum AND 
			((transValidation == TRUE_STR OR poCat == CORE_SERVICE) AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR) )) OR
			(poCat <> CORE_SERVICE AND transValidation <> TRUE_STR AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR))) ){ //CSYS-101182 (TT 03/12/2020)

			//CSYS-70683: set the howManyRamps value to that of the core, for grouped docNums that aren't the rollupDocNum
			//this fixes the parsing error when removing a ramp from a core when an extended service is grouped with the core:
			if(containskey(integersDict, rollupDocNum + DELIMITER + NUMBER_RAMP_ENTRIES) AND isProductBased <> TRUE_STR){
				howManyRamps = get(integersDict, rollupDocNum + DELIMITER + NUMBER_RAMP_ENTRIES);
			}
		}

		put(integersDict, docNum + DELIMITER + NUMBER_RAMP_ENTRIES, howManyRamps );
		
		// Collect the data used to match the ramp plans to the master ramp plan for the PO
		lineRampXML = "";

		if ( containskey( stringsDict, rollupdocNum + DELIMITER + RAMP_PLAN_DETAIL )){

			if(isProductBased <> TRUE_STR){
				lineRampXML = get( stringsDict, rollupdocNum + DELIMITER + RAMP_PLAN_DETAIL );
				
			}
			else {
				//CSYS-94381 - (LN. 1-9-2019) Grab the Parent's Base Fee lineRampXML and assign to the Child's Base Fee
				if(containskey(stringsDict, poID + DELIMITER + PARENT_INDEX_DOC_NUM) AND itemType == BASE_FEE){
					parentDocNumRamp = get(stringsDict, poID + DELIMITER + PARENT_INDEX_DOC_NUM);
					lineRampXML = get( stringsDict, parentDocNumRamp + DELIMITER + RAMP_PLAN_DETAIL );
				}
			}	
		}

		put( stringsDict, docNum + DELIMITER + RAMP_PLAN_DETAIL, lineRampXML );
		put( stringsDict, docNum + DELIMITER + RAMP_PLAN_OVERRIDE, poRampOverride );
		//isTransOverridden = poRampOverride;
		//put( stringsDict, docNum+DELIMITER+ RAMP_PLAN_OVERRIDE, isTransOverridden );
		
		
		/*	***************************	Ramp Pricing ************************* */
		/* First, we're creating a simulated line item for each ramp pricing */
		/* Append all line data except number of transactions to the dictionary, using the format 
		docNum + RAMP_DELIMITER + transaction index + DELIMITER + value */
		transIndex = 0;
		quantity = 0;
		implementationMethod = "";
		coreOffering = "";
		editionVal = "";
		advLearningServicesRequired = "";
		rampPlanOverride = "";
		seqNum = 0;
		disc = 0.0;
		discountType = "";
		rollup = "";
		incDocNum = "";
		incPi = "";
		
		//isTransoverridden = get( stringsDict, docNum+DELIMITER+ IS_TRANS_OVERRIDDEN );
		quantity = get( integersDict, docNum + DELIMITER + QTY );
		implementationMethod = get( stringsDict, docNum + DELIMITER + IMPLEMENTATION_METHOD );
		coreOffering = get( stringsDict, docNum + DELIMITER + CORE_OFFERING );
		editionVal = get( stringsDict, docNum + DELIMITER + EDITION_LINE );
		advLearningServicesRequired = get( stringsDict, docNum + DELIMITER + ADV_LEARNING_SERVICES_REQUIRED );

		if( containskey(stringsDict, docNum + DELIMITER + RAMP_PLAN_OVERRIDE )) {
			rampPlanOverride = get( stringsDict, docNum + DELIMITER + RAMP_PLAN_OVERRIDE );
		}

		if( containskey(integersDict,docNum + DELIMITER + SEQ_NUM  )){
			seqNum = get( integersDict, docNum + DELIMITER + SEQ_NUM );
		}

		if( containskey(stringsDict,docNum + DELIMITER + DISCOUNT  )){
			disc = get( floatsDict, docNum + DELIMITER + DISCOUNT );
		}

		if( containskey(stringsDict, docNum + DELIMITER + DISCOUNT_TYPE )){
			discountType = get( stringsDict, docNum + DELIMITER + DISCOUNT_TYPE );
		}

		if( containskey(stringsDict, docNum + DELIMITER + ROLL_UP)){
			rollup = get( stringsDict, docNum + DELIMITER + ROLL_UP );
		}
		
		// Values for associated incremental fee
		//CSYS-95701 SN. Remove temp fix and check in new variable
        	if(findinarray(travelAndExpenseWithTriplinkProductArr, pi) <> -1){
            		rollup = "No";
        	}

		incKey = parentDocNum + RAMP_DELIMITER + poID + RAMP_DELIMITER + rollup;

		if ( containskey( stringsDict, incKey + DELIMITER + INCREMENTAL_FEE_FOR_PO )){
			incDocNum = get(stringsDict, incKey + DELIMITER + INCREMENTAL_FEE_FOR_PO ); 
		}

		if ( containskey( stringsDict, incdocNum + DELIMITER + PART_NUM )){
			incPi = get( stringsDict, incdocNum + DELIMITER + PART_NUM );
		}


		for transaction in transArr{

			customAtoiNumber = 0;

			if ( isnumber( transaction )){
				customAtoiNumber = integer(atof(transaction));
			}

			trxns = customAtoiNumber;
			rampkey = docNum + RAMP_DELIMITER + string(transIndex);
			rollupRampKey = rollupDocNum + RAMP_DELIMITER + string(transIndex);

			if ( transIndex == howManyRamps - 1 ){
				append(overWriteTransactionArr, rampkey );
			}

			put(integersDict, rampkey + DELIMITER + QTY, quantity);
			//put(stringsDict, rampkey+DELIMITER+ IS_TRANS_OVERRIDDEN, isTransOverridden);
			// Do not group ramps
			put( stringsDict, rampkey + DELIMITER + IS_GROUPED, "false" );
			put( stringsDict, rampkey + DELIMITER + IMPLEMENTATION_METHOD, implementationMethod );
			put( stringsDict, rampkey + DELIMITER + CORE_OFFERING, coreOffering );
			put( stringsDict, rampkey + DELIMITER + EDITION_LINE, editionVal );
			put( stringsDict, rampkey + DELIMITER + ADV_LEARNING_SERVICES_REQUIRED, advLearningServicesRequired );
			put( stringsDict, rampkey + DELIMITER + RAMP_PLAN_OVERRIDE, rampPlanOverride );
			put( stringsDict, rampkey + DELIMITER + IS_TRANS_OVERRIDDEN, TRUE_STR );
			//put(stringsDict, rampkey+DELIMITER+ RAMP_PLAN_DETAIL, lineItemRampPlan);
			

			//CSYS-70683: set the trxns nodes to that of the core, for grouped/unit based docNums that aren't the rollupDocNum.
			//Regarding roducts whose transactions don't have to match the core: the ramp transactions don't have to match,
			//so exclude those trxns from getting updated
			//CSYS-95500 (LN. 4-24-2019) Allowing CREATE Unit Based Products to have independent ramps in a given scenario
			if ( rollupDocNum <> docNum AND 
				((transValidation == TRUE_STR OR poCat == CORE_SERVICE) AND (isGrouped == TRUE_STR OR (unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR) ))  /*added the transValidation, poCategory, and unitBased checks for CSYS-70683*/
				OR (poCat <> CORE_SERVICE AND transValidation <> TRUE_STR AND unitBased == TRUE_STR AND unitBasedCanHaveIndependentRamps <> TRUE_STR) ) {//CSYS-101182 (TT 3/12/2020)
 				if(containskey(integersDict, rollupRampKey + DELIMITER + TRANSACTIONS)){
					trxns = get(integersDict, rollupRampKey + DELIMITER + TRANSACTIONS);
				}
			}

			put( integersDict, rampkey + DELIMITER + TRANSACTIONS, trxns );
				
			put( integersDict, rampkey + DELIMITER + SEQ_NUM, seqNum );
			put( floatsDict, rampkey + DELIMITER + DISCOUNT, disc );
			put( floatsDict, rampKey + DELIMITER + TRANSACTION_RATIO, finalTransactionRatio );// Transaction Ratio for Grouped Ramp plan incremental fees
			put( stringsDict, rampkey + DELIMITER + PART_NUM, pi );
			put( stringsDict, rampkey + DELIMITER + DISCOUNT_TYPE, discountType );
			put( stringsDict, rampkey + DELIMITER + PARENT_DOC_NUM, parentDocNum );
			put( stringsDict, rampkey + DELIMITER + ROLL_UP, rollup );
			put( stringsDict, rampkey + DELIMITER + INCREMENTAL_PI, incPi );
			put( stringsDict, rampkey + DELIMITER + PO_ID, poID );
			put( stringsDict, rampkey + DELIMITER + PARENT_DOC_NUM, parentDocNum );
			put( piDict, rampKey, pi );

			append(newDocNumList, rampkey);
		
			//Populate the modelToLineDocNumsDict
			lineDocNums = string[];

			if (containskey(modelToLineDocNumsDict, parentDocNum)) {
				lineDocNums = get(modelToLineDocNumsDict, parentDocNum);
			}

			append(lineDocNums, rampkey);
			put( modelToLineDocNumsDict, parentDocNum, lineDocNums );
			
			//Populate the modelToLinePartNumsDict
			linePartNums = string[];

			if (containskey(modelToLinePartNumsDict, parentDocNum)) {
				linePartNums = get(modelToLinePartNumsDict, parentDocNum);
			} 

			append(linePartNums, rampkey);
			put( modelToLinePartNumsDict, parentDocNum, linePartNums );
			
			//Populate the implementationMethod
			modelImplementationMethod = get(stringsDict, parentdocNum + DELIMITER + CONFIG_IMPLEMENTATION_METHODS);
			// Required for Promotion
			append(implementationMethodArr, modelImplementationMethod);
			//append(partNumArr, pi);
			put( stringsDict, rampkey + DELIMITER + IMPLEMENTATION_METHOD, modelImplementationMethod );

			transIndex = transIndex + 1;
		}
	}
}

return newDocNumList;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722818</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1652990318000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722819</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1652990318000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722820</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1652990318000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722821</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[docNumList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1652990318000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_docNumList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722822</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[overWriteTransactionArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1652990318000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_overWriteTransactionArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722823</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[piDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1652990318000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_piDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722824</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[modelToLineDocNumsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1652990318000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_modelToLineDocNumsDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722825</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[modelToLinePartNumsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1652990318000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_modelToLinePartNumsDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722826</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[implementationMethodArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1652990318000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_implementationMethodArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>781705253</id><bm_lib_func_id>15722817</bm_lib_func_id><param_name><![CDATA[travelAndExpenseWithTriplinkProductArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1652990318000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_setRampPlanData.bm_lib_func_param_travelAndExpenseWithTriplinkProductArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5007075</id><name><![CDATA[evalArrayAttribute]]></name><variable_name><![CDATA[evalArrayAttribute]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>5007074</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_evalArrayAttribute]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5007074</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_evalArrayAttribute_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435921000</date_modified><guid><![CDATA[LEGACY_5007074]]></guid><script_size>410</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> evalArrayAttribute

expression - String
arrayAttrDict - String[] Dictionary
*/
retVal = "";
attrLabel = "";
attrValue = "";
condition = expression;

conditionSplitArray = split(condition,"=");
attrLabel = conditionSplitArray[0];
attrValue = substring(conditionSplitArray[1],1,len(conditionSplitArray[1])-1);
if(containskey(arrayAttrDict, attrLabel))
{
	compArray = get(arrayAttrDict, attrLabel);
	if(findinarray(compArray,attrValue)>-1)
	{
		attrValIndex = findinarray(compArray,attrValue);
		retVal = "TRUE::"+string(attrValIndex);
	}
	else
	{
		retVal = "FALSE";
	}
}

return retVal;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5007077</id><bm_lib_func_id>5007075</bm_lib_func_id><param_name><![CDATA[expression]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_evalArrayAttribute.bm_lib_func_param_expression_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5007078</id><bm_lib_func_id>5007075</bm_lib_func_id><param_name><![CDATA[arrayAttrDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_evalArrayAttribute.bm_lib_func_param_arrayAttrDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4974841</id><name><![CDATA[getXMLNode]]></name><variable_name><![CDATA[getXMLNode]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>4974840</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getXMLNode]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4974840</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getXMLNode_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435913000</date_modified><guid><![CDATA[LEGACY_4974840]]></guid><script_size>741</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getXMLNode 

xmlString - String
xmlNodeName - String
*/
result = String[];

// maximum number of elements
loop = split(xmlString,"<" + xmlNodeName);
rest = xmlString;

attrTag = "<" + xmlNodeName + " ";
noAttrTag = "<" + xmlNodeName + ">";
emptyTag = "<" + xmlNodeName + "/>";
endTag = "</" + xmlNodeName + ">";

nodeTypes = String[]{attrTag,noAttrTag,emptyTag};
nodeTypeRange = range(sizeofarray(nodeTypes));

for i in loop {
	nextNodeIndex = -1;
	nextNodeType = -1;
	
	for j in nodeTypeRange {
		index = find(rest,nodeTypes[j]);
		if(index > -1 and (nextNodeIndex == -1 or nextNodeIndex > index)) {
			nextNodeIndex = index;
			nextNodeType = j;
		}
	}
	
	if(nextNodeIndex == -1) {
		break;
	}
	
	if(nodeTypes[nextNodeType] == emptyTag) {
		endIndex = nextNodeIndex + len(emptyTag);
	}
	else {
		endIndex = find(rest,endTag);
		if(endIndex == -1) {
			break;
		}
		endIndex = endIndex + len(endTag);
	}
	append(result,substring(rest,nextNodeIndex,endIndex));
	rest = substring(rest,endIndex);
}
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4974843</id><bm_lib_func_id>4974841</bm_lib_func_id><param_name><![CDATA[xmlString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getXMLNode.bm_lib_func_param_xmlString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4974844</id><bm_lib_func_id>4974841</bm_lib_func_id><param_name><![CDATA[xmlNodeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getXMLNode.bm_lib_func_param_xmlNodeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4904440</id><name><![CDATA[getMiscCommerceData]]></name><variable_name><![CDATA[getMiscCommerceData]]></variable_name><description><![CDATA[NOT USED. Returns a String dictionary containing the key-value pairs in the miscCommerceData table.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4904439</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getMiscCommerceData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4904439</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getMiscCommerceData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435925000</date_modified><guid><![CDATA[LEGACY_4904439]]></guid><script_size>235</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[commerceDataDict = dict("string");

records = bmql("select miscDataKey, miscDataVal from miscCommerceData");

for record in records {
	put(commerceDataDict, get(record, "miscDataKey"), get(record, "miscDataVal"));
}

return commerceDataDict;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>25446704</id><name><![CDATA[Validate Dollar And Percent Rule]]></name><variable_name><![CDATA[validateDollarAndPercentRule]]></variable_name><description><![CDATA[For Rule Constraining Dollar Amount and Validate Dollar Amt]]></description><return_type>4</return_type><func_type>1</func_type><function_id>25446703</function_id><date_modified>1626948725000</date_modified><guid><![CDATA[bm_lib_func_util_validateDollarAndPercentRule]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>25446703</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_validateDollarAndPercentRule_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948726000</date_modified><guid><![CDATA[concur_25446703]]></guid><script_size>373</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[dollarArray = string[];
percentArray = string[];
result = false;



for docNum in docNumList {

	if (containskey(dollarDict, docNum)){
		append(dollarArray, docNum);
	}
	elif (containskey(percentDict, docNum)){
		append(percentArray, docNum);
	}
}

if (isempty(dollarArray) or isempty(percentArray)){
	result = false;

}
else {
	result = true;

}
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>25446706</id><bm_lib_func_id>25446704</bm_lib_func_id><param_name><![CDATA[dollarDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948725000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_validateDollarAndPercentRule.bm_lib_func_param_dollarDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>25446707</id><bm_lib_func_id>25446704</bm_lib_func_id><param_name><![CDATA[percentDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948725000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_validateDollarAndPercentRule.bm_lib_func_param_percentDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>25446708</id><bm_lib_func_id>25446704</bm_lib_func_id><param_name><![CDATA[docNumList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948725000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_validateDollarAndPercentRule.bm_lib_func_param_docNumList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>517677422</id><name><![CDATA[hideCrossModelMessage]]></name><variable_name><![CDATA[hideCrossModelMessage]]></variable_name><description><![CDATA[CSYS-89647]]></description><return_type>4</return_type><func_type>1</func_type><function_id>517677421</function_id><date_modified>1701944753000</date_modified><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>517677421</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_hideCrossModelMessage_1]]></java_class_name><child_class_names></child_class_names><date_modified>1701944753000</date_modified><guid><![CDATA[58a515ed-d70c-4425-88b4-95ebb55869fc]]></guid><script_size>4177</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//Existing intel script has been transformed into this util. However, refactoring of this script still needs to be done, which should include taking only one side of boolean logic, and any contrary condition will hence take the other side. Note that attribute names need refactoring as well 

if(coreOfferings <> "" AND implementationMethods <> ""){
	
	intelMappingDict = dict("string");
	coreHasSelectableIntellDict = dict("string");
	parentDocNumArray = integer[];
	//myIntellMappingArray = string[];
	//coreWithIntellArray = string[];
	extServPOArray = string[];
	corePOArray = string[];
	corePONameArray = string[];
	allParentDocNums = string[];
	crossModelTrigger = false;
	nonReconfigTrigger = false;
	intellOnOtherCores = false;
	reconfiguredDocNum = "";
	PO_DELIMITER = "~";
	//IESCNQRCPQ-1295
	isConsIntOnFirstCoreNotonSecond = false;
	poListOfConsInt = string[] {"203744","329165","346220"}; //PO IDs of consultative Intelligence
	//END

	//CSYS-89209 (LN. 2-9-2018) Setting up new Constants, Arrays and Dictionaries to leverage logic
	CORE_SERVICE = "Core Service";
	BASE_FEE = "Base";
	coreMappingArr = string[];
	intellMappingArr = string[];
	intellTerminateDict = dict("string");
	intellNoneDict = dict("string");

	
	current_core = "";
	rez = BMQL("SELECT selectedDocumentNumber_quote, listOfCoreOffering_quote, listOfImplementationMethods_quote FROM commerce.quote_process");

	for entry in rez{
		current_core = get(entry, "listOfCoreOffering_quote");
		reconfiguredDocNum = get(entry, "selectedDocumentNumber_quote");
	}
	
	if(current_core == "" OR (find(current_core, "$$") == -1 AND reconfigure == "true")){
		return true; //never fire the rule when adding the first core or reconfiguring the first core when it's the only core on the quote
	}
	
	/*
	intellRez = bmql("SELECT RelatedIntelPO, CoreWithoutIntel FROM AddCoreWithIntell");
	for entry in intellRez {
		intellPO = get(entry,"RelatedIntelPO");
		CoreWithoutIntell = get(entry,"CoreWithoutIntel");
		append(myIntellMappingArray, intellPO);
		append(coreWithIntellArray, CoreWithoutIntell);
	}


	INTELL_PO5 = "662007"; //Insight Premium for Expense (CSYS-68545. KA. 8-11-2016)
	INTELL_PO6 = "662299"; //Insight Premium for Travel & Expense (CSYS-68545. KA. 8-11-2016)
	INTELL_PO7 = "662306"; //Insight Preimum for Invoice Processing (CSYS-68545. KA. 8-11-2016)
	INTELL_PO8 = "662323"; //Insight Premium for Concur Request - Standalone (CSYS-68545. KA. 8-11-2016)
	
	append(myIntellMappingArray, INTELL_PO5);
	append(myIntellMappingArray, INTELL_PO6);
	append(myIntellMappingArray, INTELL_PO7);
	append(myIntellMappingArray, INTELL_PO8);
	*/
	// Query ExtServValidation to populate the collection objects
	queryResult = bmql("SELECT ExtServicePOs, CorePOs FROM ExtServValidation where ServiceAttribute = $attributeName");
	for entry in queryResult {
		extServPOs = get(entry,"ExtServicePOs");
		corePOs = get(entry,"CorePOs");
		extServPOArray = split(extServPOs, PO_DELIMITER);
		corePOArray = split(corePOs, PO_DELIMITER);
		break;
	}
	partRecords = bmql("select part_number, description, custom_field1, custom_field2 from _parts where custom_field1 in $corePOArray");
	
	for partRecord in partRecords {
		corePOName = get(partRecord, "custom_field2");
		append(corePONameArray, corePOName);
	}
	//End
	
	lineItemsInfo = util.getLineItemsInfoFromCommerceToConfig(reconfiguredDocNum);
	reconfiguredCoreOffering = get(lineItemsInfo,"coreOffering_line");
	reconfiguredDocNumber = get(lineItemsInfo,"_document_number");
	
	isIntellOnQuote = false;	
	lineRez = BMQL("SELECT poId_line, _parent_doc_number, _document_number, _part_number, assetAction_line, lineDescription_line, poCategory_line FROM commerce.line_process");

	for entry in lineRez {
		docNum = get(entry,"_document_number");
		pi = get(entry,"_part_number");
		lineDescription = get(entry, "lineDescription_line");
		assetAction = get(entry, "assetAction_line");//CSYS-89209
		poCategory = get(entry, "poCategory_line");//CSYS-89209
		poID = get(entry,"poId_line");//CSYS-89209

		if (pi == "") { //models only
			if (findinarray(corePONameArray, lineDescription) <> -1){
				put(coreHasSelectableIntellDict, docNum, "true"); //core on the quote has selectable intell
			}
			append(allParentDocNums, docNum);
		}

		//CSYS-89209 Determine how many cores exist on the Assets, utilized in the Reconfigure = TRUE portion of the logic
		if(pi <> "" AND poCategory == CORE_SERVICE AND assetAction <> "TERMINATE" AND assetAction <> "CREATE"){
			if(findinarray(coreMappingArr, poID) == -1){
				append(coreMappingArr, poID);
			}	
		}
	}

	//CSYS-89209 Loop through assets
	for entry in lineRez{
		pi = get(entry,"_part_number");
		poID = get(entry,"poId_line");
		assetAction = get(entry,"assetAction_line");
		parentDocNum = get(entry,"_parent_doc_number");

		if(pi <> ""){

			if(containskey(coreHasSelectableIntellDict, parentDocNum)){
				//If there is a model with a selectable Intell, and the Intell asset is a NONE action code, and there are more 1 or more cores on the asset, map this to the dict
				if((assetAction == "NONE" OR assetAction == "MODIFY") AND findinarray(extServPOArray, poID) <> -1 AND sizeofarray(coreMappingArr) >= 1){					
					put(intellNoneDict, "1", "true");

					//If the poID doesn't yet exist in the array, append it to the intellMappingArr
					if(findinarray(intellMappingArr, poID) == -1){
						append(intellMappingArr, poID);
					}
				
				}

				//If there is a TERMINATED Intell, map to the dictionary
				if(assetAction == "TERMINATE" AND findinarray(extServPOArray, poID) <> -1){
					put(intellTerminateDict, "1", "true");
				}

			}
		}
	}


	for entry in lineRez {
		pi = get(entry,"_part_number");
		poID = get(entry,"poId_line");
		assetAction = get(entry,"assetAction_line");
		parentDocNum = get(entry,"_parent_doc_number");
		if (pi <> ""){
			if (get(coreHasSelectableIntellDict, parentDocNum) == "true"){
				if (isnumber(parentDocNum)){
					parentDocNumInt = atoi(parentDocNum);
				}
				append(parentDocNumArray, parentDocNumInt);
				if (get(intelMappingDict , parentDocNum) <> "true"){
					put(intelMappingDict , parentDocNum, "false");
				}
				if (assetAction <> "TERMINATE" AND findinarray(extServPOArray, poID) <> -1){ //if line is a non-terminated intell
					put(intelMappingDict , parentDocNum, "true");
					isIntellOnQuote = true;				
	
				}
				//IESCNQRCPQ-1295
				if((assetAction == "NONE" OR assetAction == "MODIFY") AND findinarray(poListOfConsInt, poID) <> -1 AND containskey(intellNoneDict, "1") AND sizeofarray(coreMappingArr) >= 1 AND sizeofarray(intellMappingArr) < 2){
					isConsIntOnFirstCoreNotonSecond = true;
				}//END
			}	
		}
	}
	
	parentCount = 0;
	trueFalseString = "";
	for index1 in parentDocNumArray {
		if (parentDocNumArray[parentCount] <> parentDocNumArray[parentCount - 1]){
			//append(finalParentDocNumArray, string(index1) + get(intellMappingDict,string(index1)));
			trueFalseString = trueFalseString + string(index1) +  get(intelMappingDict, string(index1));
		}
		parentCount = parentCount + 1;
	}
	
	if (find(trueFalseString, "true") <> -1 AND find(trueFalseString, "false") <> -1){ 	
		crossModelTrigger = true;
	}
	
	//check nonreconfigured models
	nonConfigString = "";
	intellOnOtherCoresStr = "";
	for index in allParentDocNums {
		if(index <> reconfiguredDocNumber){ //ignore reconfigured doc num
			nonConfigString = nonConfigString + get(coreHasSelectableIntellDict, index); //append the rest of the selectable intell evals to new boolean string
			intellOnOtherCoresStr = intellOnOtherCoresStr + get(intelMappingDict, index);
		}
	}
	
	nonSelectableString = "";
	nonSelectableOnly = false;
	for index in allParentDocNums { //don't ignore reconfigured doc num
		nonSelectableString = nonSelectableString + get(coreHasSelectableIntellDict, index);
	}
	
	if (find(nonSelectableString, "true") == -1){ 	
		nonSelectableOnly = true;
	}
	
	if (find(nonConfigString, "true") <> -1){ 	
		nonReconfigTrigger = true;
	}
	
	if (find(intellOnOtherCoresStr, "true") <> -1){ 
		intellOnOtherCores = true;
	}
	
	//initialize variables for config attributes
	reconfig = reconfigure;
	businessIntell = attributeValue;
	
	//Are there any line items on the quote already
	hasLineItems = false; //piece 1
	for entry in lineRez {
		lineDescription = get(entry,"lineDescription_line");
		if (lineDescription <> ""){ //if we see any line items on the quote
			hasLineItems = true;
			break;
		}
	}
	
	//determine if the core in config has selectable intelligence
	configHasSelectableIntell = false; 
	fullCoreName = coreOfferings + " - " + implementationMethods;
	
	if(coreOfferings == "Invoice Processing" AND implementationMethods == "Standard"){
		fullCoreName = "Invoice Processing - Standard Implementation";
	}
	/*
	intellCoreSet = BMQL("SELECT CoreWithoutIntel FROM AddCoreWithIntell");
	for entry in intellCoreSet {
		intellCoreName = get(entry, "CoreWithoutIntel");
		if (fullCoreName == intellCoreName){
			configHasSelectableIntell = true; //core offering in config has selectable intell
			break;
		}
	}
	*/
	//Start
	if (findinarray(corePONameArray, fullCoreName) <> -1){
		configHasSelectableIntell = true; //core offering in config has selectable intell
	}
	//End
	//determine if intell has been added to the core on the quote already. This is the core that we're dealing with in config currently.
	isIntellOnReconfiguredCore = false; 
	
	for entry in lineRez {
		parentDocNum = get(entry,"_parent_doc_number");
		if (get(intelMappingDict , reconfiguredDocNumber) == "true"){
			isIntellOnReconfiguredCore = true;
			break;
		}
	}
	
	reconfigCoreHasSelectableIntell = get(coreHasSelectableIntellDict, reconfiguredDocNumber); //see if reconfigured core has selectable intell
	
	//hide the message under these conditions
	if (NOT hasLineItems OR NOT configHasSelectableIntell OR (find(current_core, "$$") == -1 AND reconfig == "true")){
		return true; //hide the message if there are no line items on the quote (first trip to config), OR the core in config doesn't have selectable Intell, OR if there is only one core on the quote and that core is being reconfigured
	}
	
	//Additional Core added scenarios
	if (hasLineItems AND configHasSelectableIntell AND reconfig == "false"){
		if (isIntellOnQuote AND businessIntell == "" AND currentAssetSAId == ""){//CSYS-89209 Added the condition that currentAssetSAId = "", implying this is a net new core added to the quote with an existing core that has intell.  This solves the issue of 2 existing cores, one w/ Intell and one w/o Intell - don't fire the rule, hide the message for this scenario
			return false;//show the message
		}
		if(NOT isIntellOnQuote AND businessIntell <> "" AND currentAssetSAId <> ""){//CSYS-89209
			return true;
		}
		if (NOT isIntellOnQuote AND NOT nonSelectableOnly AND businessIntell <> ""){
			return false; //show the message		
		}

	}
	
	//reconfigure scenarios when 2 or more cores exist on the quote
	if (configHasSelectableIntell AND find(current_core, "$$") <> -1 AND reconfig == "true"){

		//CSYS-89209 On reconfigure, if there are 2 asset cores, one core with Intell and the second without - allow this scenario and hide the message
		// IESCNQRCPQ-1295 adding "isConsIntOnFirstCoreNotonSecond" condition
		if(sizeofarray(coreMappingArr) > 1 AND containskey(intellNoneDict, "1") AND NOT(containskey(intellTerminateDict, "1")) AND sizeofarray(intellMappingArr) < 2 AND isConsIntOnFirstCoreNotonSecond == false){
			return true;//hide the message
		}
	
		if (crossModelTrigger AND reconfigCoreHasSelectableIntell == "true" AND isIntellOnReconfiguredCore AND businessIntell <> ""){
			return false; //show the message
		}
		if (crossModelTrigger AND reconfigCoreHasSelectableIntell == "true" AND NOT isIntellOnReconfiguredCore AND businessIntell == ""){
			return false; //show the message
		}
		if (crossModelTrigger AND reconfigCoreHasSelectableIntell <> "true"){
			return false; //show the message			
		}
	
		if (NOT crossModelTrigger AND isIntellOnQuote AND reconfigCoreHasSelectableIntell == "true" AND isIntellOnReconfiguredCore AND nonReconfigTrigger AND businessIntell == ""){
			return false; //show the message
		}
		if (NOT crossModelTrigger AND NOT isIntellOnQuote AND reconfigCoreHasSelectableIntell == "true" AND NOT isIntellOnReconfiguredCore AND nonReconfigTrigger AND businessIntell <> ""){
			return false; //show the message
		}
		
		//Laterally switch from core without selectable intell to one with selectable intell in config:
		if (NOT crossModelTrigger AND reconfigCoreHasSelectableIntell <> "true" AND nonReconfigTrigger AND intellOnOtherCores AND businessIntell == ""){
			return false;
		}
		if (NOT crossModelTrigger AND reconfigCoreHasSelectableIntell <> "true" AND nonReconfigTrigger AND NOT intellOnOtherCores AND businessIntell <> ""){
			return false; //show the message
		}
	}	
}


return true; //hide the message]]></script_text><_children><bm_lib_func_assoc><id>517677429</id><caller_func_id>517677421</caller_func_id><called_lib_func_id>15731085</called_lib_func_id><rule_area><![CDATA[hideCrossModelMessage]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1701944753000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[54f881dc-81b0-45e2-bf23-4bdf6d4f70bc]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>517677423</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[coreOfferings]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_coreOfferings_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>517677424</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[implementationMethods]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_implementationMethods_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>517677425</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[currentAssetSAId]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_currentAssetSAId_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>517677426</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[reconfigure]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_reconfigure_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>517677427</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_attributeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>517677428</id><bm_lib_func_id>517677422</bm_lib_func_id><param_name><![CDATA[attributeValue]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701944753000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_hideCrossModelMessage.bm_lib_func_param_attributeValue_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>170672281</id><name><![CDATA[Get VAT Validation Message]]></name><variable_name><![CDATA[getVATValidationMessage]]></variable_name><description><![CDATA[For CSYS-50180. KA. 8-19-2015. Retrieves the appropriate message to show the user based on validating the entered VAT #.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>170672280</function_id><date_modified>1626948724000</date_modified><guid><![CDATA[bm_lib_func_util_getVATValidationMessage]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>170672280</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getVATValidationMessage_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948724000</date_modified><guid><![CDATA[5c2ecf68-ae84-4471-937f-2c5633311fea]]></guid><script_size>287</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[vatMessage = "";

if(vatValidationResult == "false" AND contractAutomation == "Non-Systematized"){ //if we're dealing with an invalid VAT #
	vatMessage = "<div style='color:red; font-weight:bold; font-size:11px; text-align:left;'>" + "VAT # is invalid. You'll still be able to submit, but you won't be able to request contract documents on the Salesforce Opportunity until the VAT # is valid." + "</div>";
}
if(vatValidationResult == "false" AND contractAutomation == "Systematized"){ //if we're dealing with an invalid VAT #
	vatMessage = "<div style='color:red; font-weight:bold; font-size:11px; text-align:left;'>" + "VAT # is invalid. You won't be able to generate contract documents until you have a valid VAT #." + "</div>";
}
if(vatValidationResult == "error"){ //if the api service is down
	vatMessage = "Unable to validate the VAT #. The service is temporarily down. Proceed as usual.";
}
//CSYS-101903, BS, 02/19/2020, display below message for UK API
if(vatValidationResult == "tokenError"){ //if the token api service is down
	vatMessage = "Unable to validate the VAT #. The token service is temporarily down. Proceed as usual.";
}
//End CSYS-101903

if(find(vatValidationResult, ":true") <> -1){ //if we're dealing with a valid vat #
	companySplit = split(vatValidationResult , "\":"); //split at double quote
	stripQuotes = replace(companySplit[3], "\"", "");
	
	companySplitNext = split(stripQuotes, "},");
	companyName = companySplitNext[0];
	
	vatMessage = vatMessage + "<div align='left' style='color:black; font-weight:bold; font-size:11px;'>" + "VAT # is registered to:" + "<br/>" + companyName + "</div>"; //company info
	vatMessage = vatMessage + "<div align='left' style='color:black; font-size:11px;'>" + "Sales person is responsible to verify this is the correct company." + "<br/>" + "If you are not sure, please double check with the customer." + "</div>"; //sales rep guidance
}

return vatMessage;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>170672282</id><bm_lib_func_id>170672281</bm_lib_func_id><param_name><![CDATA[vatValidationResult]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948724000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getVATValidationMessage.bm_lib_func_param_vatValidationResult_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>170672283</id><bm_lib_func_id>170672281</bm_lib_func_id><param_name><![CDATA[contractAutomation]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948724000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getVATValidationMessage.bm_lib_func_param_contractAutomation_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4917757</id><name><![CDATA[printDebugSubsection]]></name><variable_name><![CDATA[printDebugSubsection]]></variable_name><description><![CDATA[Prints a subsection for debugging output.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4917756</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_printDebugSubsection]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4917756</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_printDebugSubsection_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435926000</date_modified><guid><![CDATA[LEGACY_4917756]]></guid><script_size>224</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> printDebugSubsection

description - String
tabs - Integer
*/
tabString = "";
tabList = range(tabs);
for t in tabList {
	tabString = tabString + "> > ";
}


result = tabString + "--------------------------------------------------------\n";
result = result + tabString + description + "\n";
result = result + tabString + "--------------------------------------------------------\n";

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4917759</id><bm_lib_func_id>4917757</bm_lib_func_id><param_name><![CDATA[description]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_printDebugSubsection.bm_lib_func_param_description_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4917823</id><bm_lib_func_id>4917757</bm_lib_func_id><param_name><![CDATA[tabs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_printDebugSubsection.bm_lib_func_param_tabs_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4917747</id><name><![CDATA[printDebugHeader]]></name><variable_name><![CDATA[printDebugHeader]]></variable_name><description><![CDATA[Prints a header for a debug statement.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4917746</function_id><date_modified>1626948714000</date_modified><guid><![CDATA[bm_lib_func_util_printDebugHeader]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4917746</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_printDebugHeader_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948714000</date_modified><guid><![CDATA[LEGACY_4917746]]></guid><script_size>110</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> printDebugHeader 

title - String
*/

result = "================================================================\n";
result = result + title + "\n";
result = result + "================================================================\n";

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4917749</id><bm_lib_func_id>4917747</bm_lib_func_id><param_name><![CDATA[title]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948714000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_printDebugHeader.bm_lib_func_param_title_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>1116945194</id><name><![CDATA[Set Properties For CIP Parts]]></name><variable_name><![CDATA[setPropertiesForCIPParts]]></variable_name><description><![CDATA[CSYS-100546 (OK. 3-3-2021) Copy of "setPropertiesOfCIPParts" util function.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>1116945193</function_id><date_modified>1711477196000</date_modified><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPParts]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>1116945193</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setPropertiesForCIPParts_1]]></java_class_name><child_class_names></child_class_names><date_modified>1711477196000</date_modified><guid><![CDATA[b4974d58-728c-4877-a28c-d8220c590b57]]></guid><script_size>1628</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-96006
cipPiDict = dict("string");
TILDE_DELIMITER = "~";

//CSYS-100546 (OK. 3-3-2021) Adding logic for CIP Travel Authorized products and removing partnerSpecialty from the below conditions
partnerTypeCIP = get(attributesDict, "accountServicePartnerTypeCIP_quote", "string");
partnerAuthrznsArr = split(partnerAuthrzns, ";");
print "partnerAuthrznsArr ";
print partnerAuthrznsArr ;
cipTravelAuthorized = "";
coreValueArray = String[];
firstCipCore = "";
walkMeAuthorized = ""; //CSYS-104401 (OK. 10-11-2021)

cipRez = BMQL("SELECT partNumber, coreService, ServPartnerSpecialty, ServPartnerAuthrzns FROM cipSetupFees WHERE partNumber IN $partNumArr AND IncludeJapan = 'NO'");

for entry in cipRez {
	cipPi = get(entry, "partNumber");
	cipCore = get(entry, "coreService");
	servicePartnerSpecialty = get(entry, "ServPartnerSpecialty");
	servPartnerAuthrzns = get(entry, "ServPartnerAuthrzns");
	
	//CSYS-100546 (OK. 3-3-2021) check is that cip Travel Authorized or not
	if (partnerTypeCIP == "true" AND (findinarray(partnerAuthrznsArr, "Travel Professional") <> -1 OR findinarray(partnerAuthrznsArr, "Travel Standard") <> -1)) {		
		cipTravelAuthorized = "true";
	}
	
	//CSYS-104401 (OK. 10-11-2021) check is that cip WalkMe Authorized or not
	if (partnerTypeCIP == "true" AND (findinarray(partnerAuthrznsArr, "User Assistant by WalkMe") <> -1)) {		
		walkMeAuthorized = "true";
	}
	
	//if (servicePartnerSpecialty == "" AND servPartnerAuthrzns == ""){ //CSYS-100546 (OK. 3-3-2021) Remove the servicePartnerSpecialty field from cip logic
	if (servPartnerAuthrzns == ""){
		put(cipPiDict, cipPi, "true");
		put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
		print "@35";
		print cipCore;
	}
	else{
		//CSYS-96006
		//if ( find(partnerSpecialty, servicePartnerSpecialty) <> -1 OR find(partnerAuthrzns, servPartnerAuthrzns) <> -1 ){ //CSYS-100546 (OK. 3-3-2021) Remove the servicePartnerSpecialty field from cip logic
		//CSYS-104401 (OK. 10-11-2021) Add WalkMe logic in below condition
		if (find(partnerAuthrzns, servPartnerAuthrzns) <> -1 OR (cipTravelAuthorized == "true" AND (find(servPartnerAuthrzns, "~Travel Professional~") <> -1 OR find(servPartnerAuthrzns, "~Travel Standard~") <> -1)) OR (walkMeAuthorized == "true" AND (find(servPartnerAuthrzns, "~User Assistant by WalkMe~") <> -1))){
			//CSYS-96739 If there dictionary key is not yet populated, continue
						print "@47";
			print cipCore;
			print servPartnerAuthrzns;
			if(NOT(containskey(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore"))){
				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
			}

			//CSYS-96739 If there is already a key in the dictionary, update the key to include Invoice
			else {
			
				if (cipCore == "~Invoice Processing~") { //CSYS-100546 (OK. 3-3-2021) Adding condition for invoice core because we need else condition to support the other core values
					invoiceCore = split(cipCore, TILDE_DELIMITER);
					firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
					firstCipCore = firstCipCore + invoiceCore[1];
					print "@58";
					print invoiceCore;
				}
				else { //CSYS-100546 (OK. 3-3-2021)
					coreArr = split(cipCore, TILDE_DELIMITER);
					firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
					arraySize = sizeofarray(coreArr);
					if (arraySize > 0) {
						for rec in coreArr{
							index = findinarray(coreArr, rec);
							if (coreArr[index] <> coreArr[0] AND coreArr[index] <> coreArr[arraySize - 1]) {
								append (coreValueArray, rec);
							}														
						}
						cipCoreString = join(coreValueArray, "~");
						firstCipCore = firstCipCore + cipCoreString;					
					}
					print "@75";
					print coreArr ;
				}

				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", firstCipCore + TILDE_DELIMITER);
			}

			put(cipPiDict, cipPi, "true");
		}
	}
}
print "@86";
print cipPiDict;
return cipPiDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>1116945196</id><bm_lib_func_id>1116945194</bm_lib_func_id><param_name><![CDATA[partnerSpecialty]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1711477197000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPParts.bm_lib_func_param_partnerSpecialty_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1116945197</id><bm_lib_func_id>1116945194</bm_lib_func_id><param_name><![CDATA[partnerAuthrzns]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1711477197000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPParts.bm_lib_func_param_partnerAuthrzns_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1116945198</id><bm_lib_func_id>1116945194</bm_lib_func_id><param_name><![CDATA[partNumArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1711477197000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPParts.bm_lib_func_param_partNumArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1116945199</id><bm_lib_func_id>1116945194</bm_lib_func_id><param_name><![CDATA[attributesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>34</datatype><date_modified>1711477197000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPParts.bm_lib_func_param_attributesDict_34]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>104420997</id><name><![CDATA[Incremental Base Approval Flag]]></name><variable_name><![CDATA[incrementalBaseApprovalFlag]]></variable_name><description><![CDATA[Approval logic for base and incremental line items to set a flag if the corresponding inc line is less than the base.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>104420996</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>104420996</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_incrementalBaseApprovalFlag_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435941000</date_modified><guid><![CDATA[bcd6e7a1-923a-4334-b018-1945fb984633]]></guid><script_size>2384</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// Moved to commerce library -- ATG on 03/08/16
// Incremental Base Approval Flag Logic - added by ATG 10/25/13
result = "";
QUOTE_DOC_NUM = "1";
ADD_ON = "Add-On Business";
MODIFY_ACTION = "MODIFY";
NONE_ACTION = "NONE";
TERMINATE_ACTION = "TERMINATE";
CREATE_ACTION = "CREATE";
INCREMENTAL_FEE = "Incremental";
BASE_FEE = "Base";
DISCOUNT = "discount_line";
TIER_PRICE = "tierPrice_line";
NET_PRICE = "netPriceEach_line";
ASSET_ACTION = "assetAction_line";
DOCNUM_DELIM = "$*$";
DELIMITER = "@.@";
QUOTE_TYPE = "quoteType_quote";
BUSINESS_UNIT = "ownerBU_quote";

baseFeePrice = float[];
incBaseFee = float[];
baseAction = string[];
incAction = string[];
baseDisc = float[];
incDisc = float[];
tierIncFee = float[];
cntBase = 0;
cntInc = 0;
cntIncTier = 0;
incrementalGreaterThanBaseFlag = false;
baseIncrementalApprovalBypassFlag = false;
quoteType_quote = util.getStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, QUOTE_TYPE);
ownerBU_quote = util.getStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, BUSINESS_UNIT);

for key in seqNumArray { 
	seqNumber = string(key);
	docNum = get(seqNumAttributeMappingDict, seqNumber); //docNum = line._document_number;
	
	familyName = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_custom_field23"); //NEW initialization 
	utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "_part_custom_field23", familyName);
	pi = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_number"); //pi = line._part_number;
	itemType = get(primeStringsDict, docNum + DOCNUM_DELIM + "piItemType_line"); //itemType = line.piItemType_line;
	
	assetAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
	netPriceEach = util.getFloatAttribute(floatsDict, docNum, DELIMITER, NET_PRICE);
	tierPriceEach = util.getFloatAttribute(floatsDict, docNum, DELIMITER, TIER_PRICE);
	disc = util.getFloatAttribute(floatsDict, docNum, DELIMITER, DISCOUNT);

	if( quoteType_quote <> ADD_ON ){ 
	
		if(itemType == BASE_FEE AND (assetAction == CREATE_ACTION OR assetAction == MODIFY_ACTION) AND pi <> "6446"){ 
			append(baseFeePrice, netPriceEach);
			append(baseDisc, disc);
			cntBase = cntBase + 1;
		}
		
		if(itemType == INCREMENTAL_FEE AND (assetAction == CREATE_ACTION OR assetAction == MODIFY_ACTION) AND pi <> "9730") {
			append(incBaseFee, netPriceEach);
			append(tierIncFee, tierPriceEach);
			append(incDisc, disc);
			cntInc = cntInc + 1;
			cntIncTier = cntIncTier + 1;
		}
	
	}elif( quoteType_quote == ADD_ON) {

		if(itemType == BASE_FEE AND (assetAction <> TERMINATE_ACTION) AND pi <> "6446"){ 
			append(baseFeePrice, netPriceEach);
			append(baseAction, assetAction);
			append(baseDisc, disc);
			cntBase = cntBase + 1;
		}
		
		if(itemType == INCREMENTAL_FEE AND (assetAction <> TERMINATE_ACTION) AND pi <> "9730") {
			append(incBaseFee, netPriceEach);
			append(incAction, assetAction);
			append(tierIncFee, tierPriceEach);
			append(incDisc, disc);
			cntInc = cntInc + 1;
			cntIncTier = cntIncTier + 1;
		}
	}
}

if (cntBase == cntInc AND cntIncTier == cntInc AND cntInc > 0){
	count = 0;
	
	for incFee in incBaseFee{
	
		if( incFee < baseFeePrice[count] AND tierIncFee[count] <> 0.00 AND ownerBU_quote == "Enterprise BU" AND quoteType_quote <> ADD_ON AND (baseDisc[count] <> 0.0 OR incDisc[count] <> 0.0)){
					incrementalGreaterThanBaseFlag = true;
		}elif( incFee < baseFeePrice[count] AND tierIncFee[count] <> 0.00 AND ownerBU_quote == "Enterprise BU" AND (incAction[count] <> NONE_ACTION OR baseAction[count] <> NONE_ACTION) AND quoteType_quote == ADD_ON AND (baseDisc[count] <> 0.0 OR incDisc[count] <> 0.0)){
					incrementalGreaterThanBaseFlag = true;
		}
		if(ownerBU_quote == "Enterprise BU" AND incrementalGreaterThanBaseFlag == false AND incDisc[count] > 0.0){
				baseIncrementalApprovalBypassFlag = true;
		}
	count = count + 1;
	}
}

utilResultString = util.formAttrValueStr(attributesDict, "incrementalBaseApprovalFlag_quote", QUOTE_DOC_NUM , string(incrementalGreaterThanBaseFlag));
utilResultString = util.formAttrValueStr(attributesDict, "baseIncrementalApprovalBypassFlag_quote", QUOTE_DOC_NUM , string(baseIncrementalApprovalBypassFlag));
put(triggerDict,"incrementalBaseApprovalFlag", string(incrementalGreaterThanBaseFlag));

// END Incremental Base Approval Flag Logic - added by ATG 10/25/13

return "";]]></script_text><_children><bm_lib_func_assoc><id>104421005</id><caller_func_id>104420996</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[Incremental Base Approval Flag]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1458252355000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[967b978c-aeba-49f7-8113-251a786fb27e]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>104421006</id><caller_func_id>104420996</caller_func_id><called_lib_func_id>4906075</called_lib_func_id><rule_area><![CDATA[Incremental Base Approval Flag]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1458252355000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[4f167f3d-406b-42de-9a66-78c9dd2ce27f]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>104421007</id><caller_func_id>104420996</caller_func_id><called_lib_func_id>4906081</called_lib_func_id><rule_area><![CDATA[Incremental Base Approval Flag]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1458252355000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[75476d1f-811d-4e59-a203-1beef76160fa]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>104421008</id><caller_func_id>104420996</caller_func_id><called_lib_func_id>15722747</called_lib_func_id><rule_area><![CDATA[Incremental Base Approval Flag]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1458252355000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[0357f2dd-8fb0-463e-a46e-b3ef38989fe7]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>104420998</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[seqNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1508547406000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_seqNumArray_7]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104420999</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[seqNumAttributeMappingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547406000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_seqNumAttributeMappingDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104421000</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[primeStringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547406000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_primeStringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104421001</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547406000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104421002</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1508547406000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104421003</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[attributesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547406000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_attributesDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>104421004</id><bm_lib_func_id>104420997</bm_lib_func_id><param_name><![CDATA[triggerDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547406000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_incrementalBaseApprovalFlag.bm_lib_func_param_triggerDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>170672273</id><name><![CDATA[Get VAT Validation]]></name><variable_name><![CDATA[getVATValidation]]></variable_name><description><![CDATA[Calls the isvat.eu API to return a string with the following info: whether validation succeeded, and if it did, company name.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>170672272</function_id><date_modified>1697722351000</date_modified><guid><![CDATA[bm_lib_func_util_getVATValidation]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>170672272</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getVATValidation_1]]></java_class_name><child_class_names></child_class_names><date_modified>1697722351000</date_modified><guid><![CDATA[acaa4544-f6a4-4db5-a29d-f2d07451dc2f]]></guid><script_size>1866</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//****** VAT Validation UTIL library ******//
/*
Takes parameters:
vatNumber (vatNumber_quote)
overrideVat (overrideVat_quote)
serviceCountry (_quote_process_serviceAddress_country)

Returns string result of isvat.eu API call
*/
countryCode = "";
validate = "";

dateCheck = (comparedates(strtojavadate(createdDate, "MM/dd/yyyy"), strtojavadate("07/05/2015", "MM/dd/yyyy")) > 0);  // added to only run validation on quotes created after the deployment date
if(dateCheck AND vatNumber <> "" AND NOT overrideVat){ //the other VAT # rule checks to make sure VAT # is not blank for the proper service countries. Only run subsequent logic if the override is false
	//serviceCountry = _quote_process_serviceAddress_country;
	
	rez = bmql("SELECT countryCode FROM VATNumber WHERE serviceCountry = $serviceCountry");
	for entry in rez{
		countryCode = get(entry, "countryCode"); //pull the correct country code from the table, given the service country
	}
	
	//character stripping for existing quotes:
	stripCharArray = string[]{" ", ".", "#", ":", "-", "/", ";"}; //characters to strip
	vatCharArray = split(vatNumber, "");
	count = 0;
	for character in vatCharArray {
		if(findinarray(stripCharArray, character) <> -1){
			vatCharArray[count] = "";
		}
		count = count + 1;
	}
	vatNum = upper(trim(join(vatCharArray, "")));

	if (startswith(vatNum, countryCode) == false){
		return "false"; //false means the VAT # didn't pass the initial format test
	}
	
	vatCountryCode = substring(vatNum, 0, 2);
	latterPortion = substring(vatNum, 2); //vat number minus the country code
	
	//CSYS-101903, BS, 02/05/2020, added below code to validate UK VAT number using hmrc.gov.uk API
	if(vatCountryCode == "GB")
	{
		prod = "prod%";
		//test = "test%";	//Use this URL to test for Sandbox API 
		clientID = "";
		clientSecret = "";
		//IESCNQRCPQ-1189 - Commenting the token authorisation code as now the HRMC has made it open source and no authorisation is required. - Start
		token = "";
		/*
		tokenURL = "https://api.service.hmrc.gov.uk/oauth/token";
		//tokenURL = "https://test-api.service.hmrc.gov.uk/oauth/token;	//Use this URL to get token for Sandbox API 
		
		//Fetching clientID & clientSecret for prod API
		recSet = bmql("SELECT BMIInstance, notes FROM siteInfo WHERE notes LIKE $prod");
		for entry in recSet{
			
			if(find(get(entry, "notes"), "client_id") <> -1){
				clientID = get(entry, "BMIInstance");
			}
			if(find(get(entry, "notes"), "client_secret") <> -1){
				clientSecret = get(entry, "BMIInstance");
			}
		}
		
		params = makeurlparam({'client_id':clientID, 'client_secret':clientSecret, 'grant_type':"client_credentials"});
		
		//Getting OAuth token to be used to call VAT API later in the code
		response = urldatabypost(tokenURL, params, "Error while validating");
		token = "";
		
		if(isnull(response) == false){
			if(find(response, "access_token") <> -1){
				tokenSplit = split(response, ",");
				tokenSplit2 = split(tokenSplit[0], "{\"access_token\":\"");				
				token = substring(tokenSplit2[1],0,-1);
			}
		}
		//IESCNQRCPQ-1189 - End
		*/
		//IESCNQRCPQ-1189 - Updated the condition to do null check
		if(token == ""){
			validate = "";

			//New UK VAT validation API URL
			urlUK = "https://api.service.hmrc.gov.uk/organisations/vat/check-vat-number/lookup/" + latterPortion;
			
			//Uncomment the below URL to get token for Sandbox API 
			//urlUK = "https://test-api.service.hmrc.gov.uk/organisations/vat/check-vat-number/lookup/" + latterPortion;
			
			myHeaders = dict("string");
			put(myheaders, "Accept", "application/vnd.hmrc.1.0+json");
			put(myheaders, "Authorization", "Bearer "+token);
			//responseUK = urldatabyget(urlUK, "", "Error while validating", 5000, myHeaders);
			responseUK = urldata(urlUK, "GET", myHeaders);
			
			if(isnull(responseUK) == false){
				if(containskey(responseUK, "Status-Code")){
					statusCode = get(responseUK, "Status-Code");

					if(statusCode == "404" or statusCode == "400"){	//Error while validating VAT
						errorMessage = get(responseUK, "Error-Message");	
						errorCode = get(responseUK, "code");
						if(find(errorMessage, "targetVrn does not match a registered company") <> -1){ //invalid Vat #
							validate = "{\"valid\":false}";
						}
						if(find(errorMessage, "Invalid targetVrn - Vrn parameters should be 9 or 12 digits") <> -1){ //invalid Vat# format
							validate = "{\"valid\":false}";
						}
						
					}
					if(statusCode == "200"){	//VAT validation successfull
						messageBody = get(responseUK, "Message-Body");
						UKcompanyNameSplit = split(messageBody, ",");
						UKcompanyNameSplit2 = split(UKcompanyNameSplit[0], "{\"name\":\"");	
						UKcompanyName = substring(UKcompanyNameSplit2[1],0,-1);
						validate = "{\"valid\":true,\"cache:{0\":PLACEHOLDER\":\"" + UKcompanyName + "\"},\"address";
					}
				}
			}

			if(find(validate, ":false") <> -1){
				return "false";
			}
			if(find(validate, ":true") == -1 AND find(validate, ":false") == -1){ //If API service is down
				return "error"; //return error string since the API is down
			}		
		}
		else{
			return "tokenError"; //return error string since the token was not generated
		}
	}
	//End CSYS-101903
	else{

		//url = "http://isvat.eu/" + countryCode + "/" + latterPortion +"/"; //commenting this line out and using next line for CSYS-79072 (KA. 3-15-2017)
		//CSYS-99233 (BS. 05-05-2020) Replaced "http" with "https" in the below URL
		//url = "https://ec.europa.eu/taxation_customs/vies/viesquer.do?ms=" + countryCode + "&iso=" + countryCode + "&vat=" + latterPortion;
		//CSYS-107100 - Reading new WSDL and updating the URL - Start
		//siteName = lower(_system_company_name);
		buyerCompanyName = "concur";
		myHeaders = dict("string");
		put(myheaders, "Accept", "text/xml");
		put(myheaders, "Content-Type", "text/xml; charset=UTF-8");
		put(myheaders, "Connection", "Keep-Alive");
		//IESCNQRCPQ-1145 - Updated the URL as per the third party website
		//url = "https://ec.europa.eu/taxation_customs/vies/services/checkVatTestService";
		url = "https://ec.europa.eu/taxation_customs/vies/services/checkVatService";
		vatValidationXMLURL = "https://" + lower(buyerCompanyName) +".bigmachines.com/bmfsweb/"+ lower(buyerCompanyName) + "/image/WebServices/VATValidation_NONUK_Request.xml";
		SoapUpdate = urldatabyget(vatValidationXMLURL,"","error");
		SoapUpdate = replace(SoapUpdate, "COUNTRYCODE", countryCode);
		SoapUpdate = replace(SoapUpdate, "VATNUMBER", latterPortion);
		//validate = urldata(urlUK, "", myHeaders);
		validate= urldatabypost(url, SoapUpdate, "", myHeaders, true);
		//validate = urldatabypost(url, SoapUpdate, "Error while validating");
		companyAddress = "";
		
		validateSplit = split(validate, "<ns2:valid>");
		//print validateSplit;
		validateSplit2 = split(validateSplit[1], "</ns2:valid>");
		print validateSplit2;
		if(validateSplit2[1] <> ""){
			companyNameSplit = split(validateSplit2[1], "<ns2:name>");
			companyNameSplit2 = split(companyNameSplit[1], "</ns2:name>");
			companyAddress = companyNameSplit2[0];
		}
		if(validateSplit2[0] == "true"){
			validate = "{\"valid\":true,\"cache:{0\":PLACEHOLDER\":\"" + companyAddress + "\"},\"address";
		}
		elif(validateSplit2[0] == "false"){
			validate = "{\"valid\":false}";
		}
		//CSYS-107100 - End
		//Commenting - the below code
		/*
		//validate = urldatabypost(url, "", "Error while validating");

		//CSYS-79072 (until a better solution is found):
		if(find(validate, "No, invalid VAT number") <> -1){ //invalid Vat #
			validate = "{\"valid\":false}";
		}
		elif(find(validate, "Yes, valid VAT number") <> -1){ //valid Vat #
			//Commented the below tag code as it was not found as per latest response
			//companyNameSplit = split(validate, ">Name</td>"); //locate the beginning of where we need to parse company name
			//companyNameSplit2 = split(companyNameSplit[1], "</td>"); //split at the </td> delimiter 
			//companyNameSplit3 = split(companyNameSplit2[0], "<td>"); //get rid of the <td> on the front
		//CSYS-104672 : BMI - Issues with VAT Validation : LIN: 11-04-2021 - Updated the tags
			companyNameSplit = split(validate, "Name</label>"); //locate the beginning of where we need to parse company name
			companyNameSplit2 = split(companyNameSplit[1], "</div>"); //split at the </div> delimiter 
			companyNameSplit3 = split(companyNameSplit2[0], "<div >"); //get rid of the <div > on the front
			validate = "{\"valid\":true,\"cache:{0\":PLACEHOLDER\":\"" + companyNameSplit3[1] + "\"},\"address";
		}
		//END CSYS-79072
		*/
		
		if(find(validate, ":false") <> -1){
			return "false";
		}
		if(find(validate, ":true") == -1 AND find(validate, ":false") == -1){ //If API service is down
			return "error"; //return error string since the API is down
		}
	}
}

return validate;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>170672274</id><bm_lib_func_id>170672273</bm_lib_func_id><param_name><![CDATA[vatNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1697722351000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getVATValidation.bm_lib_func_param_vatNumber_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>170672275</id><bm_lib_func_id>170672273</bm_lib_func_id><param_name><![CDATA[overrideVat]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>0</datatype><date_modified>1697722351000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getVATValidation.bm_lib_func_param_overrideVat_0]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>170672276</id><bm_lib_func_id>170672273</bm_lib_func_id><param_name><![CDATA[serviceCountry]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1697722351000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getVATValidation.bm_lib_func_param_serviceCountry_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>170672277</id><bm_lib_func_id>170672273</bm_lib_func_id><param_name><![CDATA[createdDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1697722351000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getVATValidation.bm_lib_func_param_createdDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>463785498</id><name><![CDATA[Get Max Tier For State Local Cust]]></name><variable_name><![CDATA[getMaxTierForStateLocalCust]]></variable_name><description><![CDATA[CSYS-87130]]></description><return_type>3</return_type><func_type>1</func_type><function_id>463785497</function_id><date_modified>1519339491000</date_modified><guid><![CDATA[bm_lib_func_util_getMaxTierForStateLocalCust]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>463785497</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getMaxTierForStateLocalCust_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435942000</date_modified><guid><![CDATA[e76a6b02-58c1-44c8-9443-d67a1b9044c3]]></guid><script_size>398</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getMaxTierForStateLocalCust

numTransactions - Integer
*/
maxTier = 0;

if (numTransactions >= 0){
	if (numTransactions > 0 AND numTransactions <= 50){
		maxTier = 50;
	}
	else{
		if (fmod(numTransactions,100) <> 0){
			maxTier = (Integer(numTransactions/100) + 1)*100;
		}
		else{
			maxTier = Integer(numTransactions/100)*100;
		}
		if (maxTier > 400)
		{
			maxTier = 400;
		}
	}
}

return maxTier;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>463785500</id><bm_lib_func_id>463785498</bm_lib_func_id><param_name><![CDATA[numTransactions]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1519339491000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getMaxTierForStateLocalCust.bm_lib_func_param_numTransactions_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>637233477</id><name><![CDATA[Get Product Based Recurring Services PO]]></name><variable_name><![CDATA[getProductBasedRecurringServicesPO]]></variable_name><description><![CDATA[This script is leveraged to determine the parent/child extended services that must force the same ramp plan on the child poID to match that of the parent poID (CSYS-94381 LN. 1-31-2019)]]></description><return_type>10</return_type><func_type>1</func_type><function_id>637233475</function_id><date_modified>1548960263000</date_modified><guid><![CDATA[bm_lib_func_util_getProductBasedRecurringServicesPO]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>637233475</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getProductBasedRecurringServicesPO_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435943000</date_modified><guid><![CDATA[fcd7ac83-c1ff-4b54-9eb3-7a6b851d60e1]]></guid><script_size>278</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*

####### CSYS-94381 (LN. 1-3-2019) #######

A new utility library to call the ProductBasedRecServs table.
This table returns the parent/child poID's for those child products whose ramp plans need to match the parent.
Return Type = String 
	Returns a string array: [parentPoID~childPoID, ]
*/

resultArr = String[];
TILDE_DELIMITER = "~";

response = BMQL ("SELECT parentPoID, childPoID FROM ProductBasedRecServs");

for entry in response {
	parentPoID = get(entry, "parentPoID");
	childPoID = get(entry, "childPoID");

	append(resultArr, parentPoID + TILDE_DELIMITER + childPoID);
}

return resultArr;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>5187824</id><name><![CDATA[getUnifiedPricingData]]></name><variable_name><![CDATA[getUnifiedPricingData]]></variable_name><description></description><return_type>4</return_type><func_type>1</func_type><function_id>5187823</function_id><date_modified>1626948715000</date_modified><guid><![CDATA[bm_lib_func_util_getUnifiedPricingData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5187823</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getUnifiedPricingData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948716000</date_modified><guid><![CDATA[LEGACY_5187823]]></guid><script_size>800</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> getUnifiedPricingData

uniquePOList - String[]
unifiedPricingDataDict - String[] Dictionary
stringsDict - String Dictionary
*/
result = true;
DELIMITER = "@.@";
unifiedPricingDataResSet = bmql("SELECT coreProdPO, unifiedPO FROM unifiedPricing WHERE coreProdPO IN $uniquePOList AND unifiedPO IN $uniquePOList");
rowCount = 0;


currentModelDocNumForUnified = "";
if ( containskey( stringsDict, "currentModelDocNumForUnified" ) ){
	currentModelDocNumForUnified = get( stringsDict, "currentModelDocNumForUnified" );
	//CSYS-97908
	if ( currentModelDocNumForUnified <> "" AND containskey(stringsDict, "modelDocNumPO" + currentModelDocNumForUnified) ){
		PODataArr = string[];
		rowKey = string(rowCount) + DELIMITER + currentModelDocNumForUnified;
		append(PODataArr, get(stringsDict, "modelDocNumPO" + currentModelDocNumForUnified));
		append(PODataArr, "NA");
		put(unifiedPricingDataDict, rowKey, PODataArr);
		rowCount = rowCount + 1;	
	}
}


for unifiedPricingDataRes in unifiedPricingDataResSet {
	PODataArr = string[]; //static indices are used. index 1 -> coreProdPO, index 2 -> rollupPO, index 3 -> unifiedPO
	coreProdPO = get(unifiedPricingDataRes, "coreProdPO");
	unifiedPO = get(unifiedPricingDataRes, "unifiedPO");
	append(PODataArr, coreProdPO);
	append(PODataArr, unifiedPO);
	rowKey = string(rowCount);
	if ( currentModelDocNumForUnified <> "" ){
		rowKey = rowKey + DELIMITER + currentModelDocNumForUnified;
	}
	put(unifiedPricingDataDict, rowKey, PODataArr);
	rowCount = rowCount + 1;
}

 
return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5187826</id><bm_lib_func_id>5187824</bm_lib_func_id><param_name><![CDATA[uniquePOList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948715000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getUnifiedPricingData.bm_lib_func_param_uniquePOList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5187827</id><bm_lib_func_id>5187824</bm_lib_func_id><param_name><![CDATA[unifiedPricingDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1626948715000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getUnifiedPricingData.bm_lib_func_param_unifiedPricingDataDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>6134286</id><bm_lib_func_id>5187824</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948715000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getUnifiedPricingData.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5368208</id><name><![CDATA[Get Services UOM]]></name><variable_name><![CDATA[getServicesUOM]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>10</return_type><func_type>1</func_type><function_id>5368207</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getServicesUOM]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5368207</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getServicesUOM_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435928000</date_modified><guid><![CDATA[LEGACY_5368207]]></guid><script_size>593</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util.getServicesUOM

recPOArray - Array sized to number of entries in the attr

*/
retArr = String[];
unitsDict = dict("string");

/* Must replace all nulls with empty strings */
recPoString = join( recPOArray, "***" );
recPoString = replace( recPoString, "null", "" );
newRecPO = split( recPoString, "***" );
// Run through each po in the array and find its UOM
if(sizeofarray(recPOArray)>0)
{
	if(isnull(recPOArray[0]))
	{
		retArr[0]="";
	}
	else
	{
		UOMRecordSet = bmql("select custom_field1, units from _parts where custom_field1 in $newRecPO");
		for uom in UOMRecordSet
		{
			put(unitsDict, get(uom,"custom_field1"), get(uom,"units"));
		}
		for each in newRecPO
		{ 
			if ( containskey (unitsDict, each ) ){
				append(retArr, get(unitsDict,each));
			}
			else{
				append( retArr, "" );
			}
		}
	}	
}

return retArr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5368210</id><bm_lib_func_id>5368208</bm_lib_func_id><param_name><![CDATA[recPOArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getServicesUOM.bm_lib_func_param_recPOArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5369746</id><name><![CDATA[Constrain Array Repeated Values]]></name><variable_name><![CDATA[constrainArrayRepeatedValues]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>10</return_type><func_type>1</func_type><function_id>5369745</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_constrainArrayRepeatedValues]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[a = String[];
b = String[]{"abc", "def" };
c = String[]{"abc", "def", "hig"};
return util.constrainArrayRepeatedValues( a, b, c );]]></main_script_text><_children><bm_function><id>5369745</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_constrainArrayRepeatedValues_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435929000</date_modified><guid><![CDATA[LEGACY_5369745]]></guid><script_size>514</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util.constrainArrayRepeatedValues

String[] sizeArray - Size of config arr
String[] dataArray - array of data we are constraining
String[] availableOptionsArr - array of data available
*/

/*
selectedValues = String[];
resultArray = String[];
mainArray = String[];
*/
// Loop through the whole array based on size
/*
i = 0;
for size in sizeArray
{	
	retArr = string[];
	append(retArr,"|^|");
	previousRange = range(i);
	for eachPreviousValue in previousRange{
		append(selectedValues,dataArray[eachPreviousValue]);
	}
	
	for option in availableOptionsArr{
		if(findinarray(selectedValues,option)==-1)
		{
			append(retArr, option);
		}
	}
	
	returnString = join(retArr,"|^|");

	append(resultArray, returnString);
	
	i=i+1;
}

for res in resultArray
{
	append(mainArray,res);
}
*/

// ASSUMPTION : THE STATE WAS NOT ALLOWED INTO A SITUATION WHERE THE ARRAY CONTAINS ALREADY DUPLICATED DATA

retArr = String[];
finalArray = String[];
DELIMITER = "|^|";
EMPTY_STRING = "";
valuesArr = String[];


valuesArr = availableOptionsArr;
append( valuesArr, EMPTY_STRING );

for data in dataArray{
	append( finalArray, data );
	dataIndex = findinarray( valuesArr, data );
	if ( data <> "" AND dataIndex <> -1 ){
		tempInt = remove( valuesArr, dataIndex );
	}
}

// Loop through the array and find out what data has already been selected


for information in finalArray{
	retVal = join( valuesArr, DELIMITER );
	retVal = retVal + DELIMITER + information;
	append( retArr, retVal );
}
	
	
return retArr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5369748</id><bm_lib_func_id>5369746</bm_lib_func_id><param_name><![CDATA[sizeArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547404000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_constrainArrayRepeatedValues.bm_lib_func_param_sizeArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5369749</id><bm_lib_func_id>5369746</bm_lib_func_id><param_name><![CDATA[dataArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547404000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_constrainArrayRepeatedValues.bm_lib_func_param_dataArray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5369750</id><bm_lib_func_id>5369746</bm_lib_func_id><param_name><![CDATA[availableOptionsArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547404000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_constrainArrayRepeatedValues.bm_lib_func_param_availableOptionsArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722789</id><name><![CDATA[Get Ramp XML String Array Dict]]></name><variable_name><![CDATA[getRampXMLStringArrayDict]]></variable_name><description><![CDATA[Builds out the XML string for each ramp.]]></description><return_type>18</return_type><func_type>1</func_type><function_id>15722788</function_id><date_modified>1687447747000</date_modified><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722788</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRampXMLStringArrayDict_1]]></java_class_name><child_class_names></child_class_names><date_modified>1687447747000</date_modified><guid><![CDATA[testconcur_12988950]]></guid><script_size>19948</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
====================================================================
-----------------------------Change Log----------------------
10/12/2015 - KA CSYS-52578
      --Changed our variable disc to longDiscount_line for more decimal precision when calculating line ramp plan prices

10/2/2013 - Matt Morman Case 170798
      -Changed our variable disc, It originally pulled the discount_line value, now it is always the discountPercent_line
      -We had to remove all of the checks to see what the discount type was, it will always be % so those are no longer necessary
      -Please reference case #170798  for a list of changes
      
10/22/2013 - Heidi Basler PS Promos SOW
      - added promoDiscPercent discounts wherever disc was being applied - promo was applied before disc

11/21/2013 - Krishna Zaveri Case 00176332
      - changed the key in get functions to match the key in the corresponding containskey functions
====================================================================
*/


/* Parameters passed to this util
stringsDict
floatsDict
integersDict
docNum
parentDocNum
howManyRamps
isGrouped
billingCycleNumber
CURRENCY_SYMBOL
*/
// CONSTANTS
 
DELIMITER = "@.@";
RAMP_PLAN_DETAIL = "rampPlanDetails_line";
RAMP_PLAN_DETAIL_SAVE_XML = "rampPlanDetailXMLSave_line";
RAMP_PARENT_NODE = "rampPlanDetail";
RAMP_DELIMITER = "-_**_-";
ROLL_UP = "rollUp_line";
PRIMARY_BASE_FEE = "primaryBaseFee";
//DISCOUNT_PERCENT = "discountPercent_line";
DISCOUNT_PERCENT = "longDiscount_line"; //For CSYS-52578
TRANSACTIONS = "numCommittedTransaction_line";
EXT_NET_PRICE_NON_UNIFIED = "extNetPriceNonUnified_line";
EXT_NET_PRICE_NON_UNIFIED_USD = "extNetPriceNonUnifiedUSD_line";
INC_FEE_NON_UNIFIED_NET = "increFeeNonUnifiedNet";
INC_FEE_NON_UNIFIED_NET_USD = "increFeeNonUnifiedNetUSD";
EXT_LIST_PRICE_NON_UNIFIED = "extListPriceNonUnified_line";
EXT_LIST_PRICE_NON_UNIFIED_USD = "extListPriceNonUnifiedUSD_line";
LIST_PRICE_NON_UNIFIED = "listPriceNonUnified_line";
LIST_PRICE_NON_UNIFIED_USD = "listPriceNonUnifiedUSD_line";
BASE_LIST_PRICE_UNIFIED = "listPriceUnified";
BASE_LIST_PRICE_UNIFIED_USD = "listPriceUnifiedUSD";
EXT_LIST_PRICE_USD = "extListPriceUSD_line";//CSYS-86837


EXT_NET_PRICE = "extendedNetPrice_line";
EXT_NET_PRICE_UNIFIED = "extNetPriceUnified_line";
PROD_BASED_PRICE_USD = "extProductBasedPriceUSD_line";
EXT_NET_PRICE_USD = "extNetPriceUSD_line";
NET_PRICE_USD = "netPriceUSD_line";
NET_PRICE_UNIFIED_USD = "netPriceUnifiedUSD_line";
EXT_NET_PRICE_UNIFIED_USD = "extNetPriceUnifiedUSD_line";
INCREMENTAL_FEE_LIST = "incrementalFeeList";
INCREMENTAL_FEE_LIST_USD = "incrementalFeeListUSD";
INCREMENTAL_FEE_NET_USD = "incrementalFeeNetUSD";
PROD_ROLL = "productBasedPriceRollUp";
// Store the incremental fee for a PO for use with the base fee XML
INCREMENTAL_FEE_FOR_PO = "incrementalFeeForPO";
NUM_DECIMAL_USD = 2;
EXT_PRODUCT_BASED_PRICE = "extProductBasedPrice_line";
DISCOUNT = "discount_line";
DISCOUNT_TYPE = "discountType_line";
PROMO_DISC_PERCENT = "promoDiscPercent_line";

TRUE_STR = "true";
NET_PRICE = "netPriceEach_line";
AMOUNT_DISCOUNT_TYPE = "Amt";
INCREMENTAL_FEE_NET = "incrementalFeeNet";
INC_FEE_LIST_XML = "increFeeList";
INC_FEE_LIST_XML_USD = "increFeeListUSD";
BASE_FEE_LIST_XML = "baseFeeList";
BASE_FEE_LIST_XML_USD = "baseFeeListUSD";
BASE_FEE_NET_XML = "baseFeeNet";
BASE_FEE_NET_XML_USD = "baseFeeNetUSD";
INC_FEE_NET_XML = "increFeeNet";
INC_FEE_NET_XML_USD = "increFeeNetUSD";
BASE_FEE_NET_NON_UNIFIED = "baseFeeNonUnifiedNet";
BASE_FEE_NET_NON_UNIFIED_USD = "baseFeeNonUnifiedNetUSD";
TRANSACTION_XML_NODE_NAME = "transactions";  //This value must match the node name of the "transactions" node on the Ramp Plan XML
BASE_FEE_LIST_NON_UNIFIED_XML = "baseFeeListNonUnified";
BASE_FEE_LIST_NON_UNIFIED_USD_XML = "baseFeeListNonUnifiedUSD";
INC_FEE_LIST_NON_UNIFIED_XML = "incFeeListNonUnified";
INC_FEE_LIST_NON_UNIFIED_USD_XML = "incFeeListNonUnifiedUSD";
// Case 1240022 - Added by Muthu Murugan
INCREMENTAL_FEE_NON_UNIFIED_LIST = "increFeeNonUnifiedList";
INCREMENTAL_FEE_NON_UNIFIED_LIST_USD = "increFeeNonUnifiedListUSD";
// Case 114135 - Added by Muthu Murugan
TRANSACTION_BY_BC = "transactionsBC";
//CSYS-37711 part 4:
BASE_INC_KEY = "baseIncKey";
 
//Constants for part custom field names
PO_ID = "poId_line";
PART_NUM = "_part_number"; 
ASSET_ACTION = "assetAction_line";
TERMINATE_ACTION = "TERMINATE";
NONE_ACTION = "NONE";
CONCUR_FAVR_PO_ID = "4722310";//CSYS-94166 (LN. 1-16-2019) 
pi = ""; 
poID = ""; 
rollup = "";
assetAction = "";
incrementalDocNum = "";
incrementalDiscount = 0.0;
billingCycleNumberFloat = 0.0;
prodBasedPriceSubline = 0.0;
userProdBasedPriceSubline = 0.0; //CSYS-86116
netPriceSubline = 0.0;
prodBasedPriceSublineUSD = 0.0;
netPriceSublineUSD = 0.0;
incBasedPriceSubline = 0.0;
incNetPriceSubline = 0.0;
incBasedPriceSublineUSD = 0.0;
incNetPriceSublineUSD = 0.0;
prodRollup = 0.0;
disc = 0.0;
discType = "";
promoDiscPercent = 0.0;
subTransactions = 0;
systemBaseFeeNet = 0.0; //CSYS-86116
systemIncFeeNet = 0.0; //CSYS-86116
systemIncFeeNetUSD = 0.0; //CSYS-95310
baseFeeNonUnifiedAttr = 0.0;
baseFeeNonUnifiedUSDAttr = 0.0;
incFeeNonUnifiedAttr = 0.0;
incFeeNonUnifiedUSDAttr = 0.0;
baseFeeListNonUnifiedAttr = 0.0;
baseFeeListNonUnifiedUSDAttr = 0.0;
incFeeListNonUnifiedAttr = 0.0;
incFeeListNonUnifiedUSDAttr = 0.0;
incNetNewUniSubline = 0.0;//CSYS-104449
incNetUniUSDSubline = 0.0;//CSYS-104449									
//CSYS-86115 (KA. 10-16-2017):
overrideRampPrice = "false";
overrideCoreRampPrice = "false";
baseCoreDocNum = "";
UQGConcurDistinctExpense = "false";  //IESCNQRCPQ-600(OK. 4-26-2023)

if(containskey(stringsDict, parentDocNum + DELIMITER + PRIMARY_BASE_FEE)){
      baseCoreDocNum = get(stringsDict, parentDocNum + DELIMITER + PRIMARY_BASE_FEE);
}
 
retDict  = dict("string"); //This dictionary is returned to "attrivateValueDict" in Pricing Function
if(containskey(stringsDict, docNum + DELIMITER + ROLL_UP)) {
            rollup = get(stringsDict, docNum + DELIMITER + ROLL_UP);
}
if(containskey(stringsDict, docNum + DELIMITER + PO_ID)) {
            poID = get(stringsDict, docNum + DELIMITER + PO_ID);
}
if(containskey(stringsDict, docNum + DELIMITER + ASSET_ACTION)) {
                  assetAction = get(stringsDict, docNum + DELIMITER + ASSET_ACTION);
}
// TEMP FIX Case CSYS-36746 ATG 9/18/14 (also added variables for pi and PART_NUM)
if(containskey(stringsDict, docNum + DELIMITER + PART_NUM)) {
            pi = get(stringsDict, docNum + DELIMITER + PART_NUM);
}
//CSYS-95701 SN. Remove temp fix and check in new variable
if(findinarray(travelAndExpenseWithTriplinkProductArr, pi) <> -1){
	rollup = "No";
}
if(containskey(stringsDict, parentDocNum + RAMP_DELIMITER + poID + RAMP_DELIMITER + rollup + DELIMITER + INCREMENTAL_FEE_FOR_PO)) {
            incrementalDocNum = get(stringsDict, parentDocNum + RAMP_DELIMITER + poID + RAMP_DELIMITER + rollup + DELIMITER + INCREMENTAL_FEE_FOR_PO);
}
if(containskey(floatsDict, incrementalDocNum + DELIMITER + DISCOUNT_PERCENT)){
            incrementalDiscount = get(floatsDict, incrementalDocNum + DELIMITER + DISCOUNT_PERCENT) / 100;
}

//CSYS-86115 continued:
if(containskey(stringsDict, docNum + DELIMITER + "overrideRampPrice")){
      overrideRampPrice = get(stringsDict, docNum + DELIMITER + "overrideRampPrice");
}
if(containskey(stringsDict, baseCoreDocNum + DELIMITER + "overrideRampPrice")){
      overrideCoreRampPrice = get(stringsDict, baseCoreDocNum + DELIMITER + "overrideRampPrice");
}

//IESCNQRCPQ-600(OK. 4-26-2023)
if(containskey(stringsDict, poID + DELIMITER + "UQGConcurDistinctExpense")){
	UQGConcurDistinctExpense = get(stringsDict, poID + DELIMITER + "UQGConcurDistinctExpense");
}

rampsArr = range( howManyRamps );
index = 0;
baseFeeNet =String[];
baseFeeList = String[]; 
baseFeeListUSD = String[];
baseFeeNetUSD = String[];
baseFeeNonUnified = String[];
baseFeeNonUnifiedUSD = String[];
incFeeNet =String[];
incFeeList = String[];
incFeeListUSD = String[];
incFeeNetUSD = String[];
incFeeNonUnified = String[];
incFeeNonUnifiedUSD = String[];
transactionArr = String[];
transactionBCArr = String[];
baseIncKeyArr = string[]; //CSYS-37711 part 4 continued
baseFeeListNonUnified = String[];
baseFeeListNonUnifiedUSD = String[];
incFeeListNonUnified = String[];
incFeeListNonUnifiedUSD = String[];
baseFeeNetBCArr = String[];

lineItemRampPlanStrArrDict = dict("string[]");

//CSYS-94166 (LN. 1-16-2019) Force a Billing Cycle of 1 for Concur FAVR
/*CSYS-98985, Phil S 04/05/2020, block CSYS-94166
if(poID == CONCUR_FAVR_PO_ID){
      billingCycleNumberFloat = integer(atof("1"));
}
else {
    if (isnumber(billingCycleNumber) ) {
          billingCycleNumberFloat = integer(atof(billingCycleNumber));
    }
}
*/
if (isnumber(billingCycleNumber) ) {
    billingCycleNumberFloat = integer(atof(billingCycleNumber));
}


for ramp in rampsArr{
            rampKey = docNum + RAMP_DELIMITER + string(index);
            parentRampKey = baseCoreDocNum + RAMP_DELIMITER + string(index); //CSYS-86116
           
            if(containskey(integersDict, rampKey + DELIMITER +  TRANSACTIONS)){
                        subTransactions = get(integersDict, rampKey + DELIMITER +  TRANSACTIONS);
            }
		
            if(containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED)){
                        baseFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED);
						
            }
            if(containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED_USD)){
                        baseFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED_USD);
            }

            //CSYS-86116 (retrieve the user entered ramp values from the core ramp):
            if(containskey(floatsDict, parentRampKey + DELIMITER + "systemBaseFeeNet")){
                        systemBaseFeeNet = get(floatsDict, parentRampKey + DELIMITER + "systemBaseFeeNet");
            }
            if(containskey(floatsDict, parentRampKey + DELIMITER + "systemIncFeeNet")){
                        systemIncFeeNet = get(floatsDict, parentRampKey + DELIMITER + "systemIncFeeNet");
            }
            //CSYS-95310
            if(containskey(floatsDict, parentRampKey + DELIMITER + "systemIncFeeNetUSD")){
                        systemIncFeeNetUSD = get(floatsDict, parentRampKey + DELIMITER + "systemIncFeeNetUSD");
            }
            
            //CSYS-86116 (Calculate baseFeeNonUnifiedNet and baseFeeNonUnifiedNetUSD for grouped line items where the core has user entered price):
            if(isGrouped == TRUE_STR){
                  if(systemBaseFeeNet <> 0.0 AND containskey(stringsDict, parentRampKey + DELIMITER + "userEnteredRampPricing")){
                        userBaseFeeNet = get(floatsDict, parentRampKey + DELIMITER + "userBaseFeeNet");
                        baseFeeNonUnifiedAttr = (baseFeeNonUnifiedAttr/systemBaseFeeNet) * userBaseFeeNet;
                        baseFeeNonUnifiedUSDAttr = (baseFeeNonUnifiedUSDAttr/systemBaseFeeNet) * userBaseFeeNet;
                  }
            }
            else{
                  if(systemBaseFeeNet <> 0.0 AND containskey(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing")){ 
                        userBaseFeeNet = get(floatsDict, rampKey + DELIMITER + "userBaseFeeNet");
                        baseFeeNonUnifiedAttr = (baseFeeNonUnifiedAttr/systemBaseFeeNet) * userBaseFeeNet;
                        baseFeeNonUnifiedUSDAttr = (baseFeeNonUnifiedUSDAttr/systemBaseFeeNet) * userBaseFeeNet;
                  }
            }
       
            /*if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET)){
                        incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET);
            }
            if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD)){
                        incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD);                
 
            }*/
            if(containskey(floatsDict, rampKey + DELIMITER +  EXT_LIST_PRICE_NON_UNIFIED)){
                        baseFeeListNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  EXT_LIST_PRICE_NON_UNIFIED);
            }
            if(containskey(floatsDict, rampKey + DELIMITER +  EXT_LIST_PRICE_NON_UNIFIED_USD)){
                        baseFeeListNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  EXT_LIST_PRICE_NON_UNIFIED_USD);
            }
            //Added by Andre per fix from Muthu on 1/22/2013
            if(containskey(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED)){
                        incFeeListNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED);
            }
            if(containskey(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED_USD)){
                        incFeeListNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED_USD);
            }

            //done adding
            baseFeeNetBC = 0.0;
            discType = "";
            if(isGrouped == TRUE_STR) {
                        //baseFeeList node:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  BASE_LIST_PRICE_UNIFIED)){
                              prodBasedPriceSubline = get(floatsDict, rampKey + DELIMITER +  BASE_LIST_PRICE_UNIFIED);

                              
                        }
                        //CSYS-82292 assign the asset base extended list price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetBaseExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){
                              prodBasedPriceSubline = get(floatsDict, poID + DELIMITER + "assetBaseExtListPrice");
                        }

                        //baseFeeNet node:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE)){
                              netPriceSubline = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE);

                              

                        }
                        //CSYS-82292
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, docNum + DELIMITER + EXT_NET_PRICE)){
                              netPriceSubline = get(floatsDict, docNum + DELIMITER + EXT_NET_PRICE);
                        }

                        //baseFeeListUSD node:
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER + BASE_LIST_PRICE_UNIFIED_USD)){
                              //was using PROD_BASED_PRICE_USD
                             prodBasedPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  BASE_LIST_PRICE_UNIFIED_USD);

                             

                        }
                        //CSYS-82292 assign the asset base extended list price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetBaseExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){

                              prodBasedPriceSublineUSD = get(floatsDict, poID + DELIMITER + "assetBaseExtListPrice");
                        }

                        //baseFeeNetUSD node:
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_UNIFIED_USD)){
                              netPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_UNIFIED_USD);
                              
                        }
                        //CSYS-82292:
                        //CSYS-86387 (LN. 11/4/2017) Using "EXT_NET_PRICE_USD" as the previous key value was populating a zero.
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, docNum + DELIMITER + EXT_NET_PRICE_USD)){

                              netPriceSublineUSD = get(floatsDict, docNum + DELIMITER + EXT_NET_PRICE_USD);
                        }

                        //increFeeList node:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST)){

                              incBasedPriceSubline = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST);

                              
                        // Incremental Fee Nets for ramp plans use the PO's incremental line item to determine discount
                        }
                        //CSYS-82292 assign the asset inc extended list price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){

                              incBasedPriceSubline = get(floatsDict, poID + DELIMITER + "assetIncExtListPrice");
                        }

                        //increFeeNet node:
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  NET_PRICE)){

							if(containskey(floatsDict,docNum + DELIMITER +  "increFeeNonUnifiedNet")){
								incNetNewUniSubline = get(floatsDict, docNum + DELIMITER +  "increFeeNonUnifiedNet");
								incNetUniUSDSubline = get(floatsDict, docNum + DELIMITER +  "increFeeNonUnifiedNetUSD");
								incNewNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED );
								incNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  NET_PRICE);								
							  }else{
								  incNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  NET_PRICE);
								  incNetNewUniSubline = get(floatsDict, rampKey + DELIMITER +  NET_PRICE);
								  incNetUniUSDSubline = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED );
								  incNewNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED );
								  incNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  NET_PRICE);								 
							  }
							  //CSYS-104449 - End						
                        }
                        //CSYS-82292 assign the asset inc extended net price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtNetPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){
                              incNetPriceSubline = get(floatsDict, poID + DELIMITER + "assetIncExtNetPrice");							 
                        }

                        //increFeeListUSD node: 
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST_USD)){
                              incBasedPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST_USD);
                        }
                        //CSYS-82292 assign the asset inc extended list price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){
                              incBasedPriceSublineUSD = get(floatsDict, poID + DELIMITER + "assetIncExtListPrice");
                        }

                        //increFeeNetUSD node: 
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  NET_PRICE_UNIFIED_USD)){
                              incNetPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  NET_PRICE_UNIFIED_USD);
                        }
                        //CSYS-82292 assign the asset inc extended net price and only if it's the 1st base line item within the PO:
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtNetPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){
                              incNetPriceSublineUSD = get(floatsDict, poID + DELIMITER + "assetIncExtNetPrice");
                        }


                        if(containskey(floatsDict, rampKey + DELIMITER +  PROD_ROLL)){
                              prodRollup = get(floatsDict, rampKey + DELIMITER +  PROD_ROLL);
                        }                                  
                        //Added by Andre per fix from Muthu on 1/22/2013
                                    /* Matt Morman - Case 170798 - Changing to always get the discount percent 
                        if(containskey(floatsDict, docNum + DELIMITER +  DISCOUNT)){
                                    disc = get(floatsDict, docNum + DELIMITER +  DISCOUNT );
                                                      

                        } */         
                        if(containskey(floatsDict, docNum + DELIMITER +  DISCOUNT_PERCENT)){
                              disc = get(floatsDict, docNum + DELIMITER +  DISCOUNT_PERCENT);
                              

                        }
                        /*if(containskey(stringsDict, rampKey + DELIMITER +  DISCOUNT_TYPE)){
                                    discType = get(stringsDict, rampKey + DELIMITER +  DISCOUNT_TYPE );
                        }*/
                        //Done Adding by Andre
                                    
                                                
                                    //netPriceSublineUSD = netPriceSublineUSD - (disc * netPriceSublineUSD/100);              //Heidi add 01/02/14
                                    

                                    
                        //baseFeeNetBC = netPriceSubline * billingCycleNumberFloat;

                        //incFeeListNonUnified node:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED)){
                              incFeeListNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED);

                              
                              //incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED);
                        }
                        //CSYS-82292:
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER + INCREMENTAL_FEE_NON_UNIFIED_LIST)){
                              incFeeListNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER + INCREMENTAL_FEE_NON_UNIFIED_LIST);
                        }

                        //increFeeNonUnifiedNet node:
                        // CSYS-95956 (LN. 6-10-2019) Commenting out the NONE check, for Enterprise Price Increase
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET)){
                              incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET);

                              //CSYS-86116 (recalculate increFeeNonUnifiedNet based on user entered ramp price):
                              if(systemIncFeeNet <> 0.0 AND containskey(stringsDict, parentRampKey + DELIMITER + "userEnteredRampPricing")){
                                    userIncFeeNet = get(floatsDict, parentRampKey + DELIMITER + "userIncFeeNet");
                                    incFeeNonUnifiedAttr = (incFeeNonUnifiedAttr/systemIncFeeNet) * userIncFeeNet; 
                              }
                        }
                        //CSYS-82292:
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER + INC_FEE_NON_UNIFIED_NET)){
                              incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER + INC_FEE_NON_UNIFIED_NET);
                        }

                        //incFeeListNonUnifiedUSD node:     
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED_USD)){
                              incFeeListNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED_USD);
                              //incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  LIST_PRICE_NON_UNIFIED_USD);
                                           
                        }    
                        //CSYS-82292:
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER + INCREMENTAL_FEE_NON_UNIFIED_LIST_USD)){
                              incFeeListNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER + INCREMENTAL_FEE_NON_UNIFIED_LIST_USD);
                        }    

                        //increFeeNonUnifiedNetUSD node (this is pulling from the base. Need to map inc price to POID then use here):
                        if(/*assetAction <> NONE_ACTION AND*/ containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD)){
                              incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD);      

                              //CSYS-86116 (recalculate increFeeNonUnifiedNetUSD based on user entered ramp price):
                              if(systemIncFeeNetUSD <> 0.0 AND containskey(stringsDict, parentRampKey + DELIMITER + "userEnteredRampPricing")){
                                    userIncFeeNet = get(floatsDict, parentRampKey + DELIMITER + "incrementalFeeNetUSD");//CSYS-95310
                                    incFeeNonUnifiedUSDAttr = (incFeeNonUnifiedUSDAttr/systemIncFeeNetUSD) * userIncFeeNet; 
                              }

                                     
                        }     
                        //CSYS-82292:
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER + INC_FEE_NON_UNIFIED_NET_USD)){
                              incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER + INC_FEE_NON_UNIFIED_NET_USD);
                        }

                        //if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET)){
                                    //incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET );
                                    // Fix for case 121738                                     
                        /*            if(discType == AMOUNT_DISCOUNT_TYPE) {
                                                incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - disc;
                                    } else {
                                                      Matt Morman - Case 170798 - Changing to always get the discount percent*/
                        //                       incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - (disc * incFeeNonUnifiedAttr/100);
                              // Mm end 170798      }
                        //}
                        //if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD)){
                                    //incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD );
                                    // Fix for case 121738                                     
                        //            if(discType == AMOUNT_DISCOUNT_TYPE) {
                        //                        incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - disc;
                        //            } else {
                        //                        incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - (disc * incFeeNonUnifiedUSDAttr/100);
                        //          }
                        //}
            
                        incrementalDiscountValue = round(incBasedPriceSubline * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
                        incNetWithDiscount = incBasedPriceSubline - incrementalDiscountValue; 
                        incrementalDiscountValueUSD = round(incBasedPriceSublineUSD * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
                        incNetWithDiscountUSD = incBasedPriceSublineUSD - incrementalDiscountValueUSD; 
                        append( baseFeeList, trim(replace(formatascurrency(prodBasedPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )) );
                        
                        //CSYS-86113 (KA. 10-16-2017): added the condition to prevent billingCycle from affecting the user entered price:
                        if(overrideCoreRampPrice == TRUE_STR AND containskey(stringsDict, parentRampKey + DELIMITER + "userEnteredRampPricing")){
                              //don't multiply by the billing cycle:
                              append( baseFeeNet, trim(replace(formatascurrency(netPriceSubline), CURRENCY_SYMBOL, "" )));
                              append( baseFeeNetUSD, string(netPriceSublineUSD));
                              baseFeeNetBC = netPriceSubline;
                        } else{ //business as usual:
                              append( baseFeeNet, trim(replace(formatascurrency(netPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" ))); 
                              append( baseFeeNetUSD, string(netPriceSublineUSD * billingCycleNumberFloat));
                              baseFeeNetBC = netPriceSubline * billingCycleNumberFloat;
                        }
                        
						//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
						if (UQGConcurDistinctExpense == TRUE_STR) {	
							append( incFeeList, trim(replace(formatascurrency( incBasedPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )) );
							append( incFeeNet, trim(replace(formatascurrency(incNetPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )) );
							append( incFeeListUSD, string(incBasedPriceSublineUSD * billingCycleNumberFloat));
							append( incFeeNetUSD, string(incNetPriceSublineUSD * billingCycleNumberFloat));
						}
						else {
							append( incFeeList, trim(replace(formatascurrency( incBasedPriceSubline), CURRENCY_SYMBOL, "" )) );
							append( incFeeNet, trim(replace(formatascurrency(incNetPriceSubline), CURRENCY_SYMBOL, "" )) );
							append( incFeeListUSD, string(incBasedPriceSublineUSD));
							append( incFeeNetUSD, string(incNetPriceSublineUSD));
                        }   
                        
                        /*append( baseFeeListUSD, util.fomatPrice(prodBasedPriceSublineUSD, "", NUM_DECIMAL_USD) );
                        append( baseFeeNetUSD, util.fomatPrice(netPriceSublineUSD, "", NUM_DECIMAL_USD) );   
                        append( incFeeListUSD, util.fomatPrice(incBasedPriceSublineUSD, "", NUM_DECIMAL_USD) );
                        append( incFeeNetUSD, util.fomatPrice(incNetPriceSublineUSD, "", numDecimals) );*/ 
                        
                        append( baseFeeListUSD, string(prodBasedPriceSublineUSD * billingCycleNumberFloat));
                        //append( baseFeeNetUSD, string(netPriceSublineUSD * billingCycleNumberFloat)); 

						/*IESCNQRCPQ-600(OK. 4-26-2023) Comment out below 2 lines and added above
                        append( incFeeListUSD, string(incBasedPriceSublineUSD));
                        append( incFeeNetUSD, string(incNetPriceSublineUSD)); 
						*/
						
                        //Added by Andre per fix from Muthu on 1/22/2013 
                        /*if(discType == AMOUNT_DISCOUNT_TYPE) {
                                    baseFeeNonUnifiedAttr = baseFeeNonUnifiedAttr - disc;
                                    baseFeeNonUnifiedUSDAttr = baseFeeNonUnifiedUSDAttr - disc;
                                    incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - disc;
                                    incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - disc;
                        } else {*/
                                    baseFeeNonUnifiedAttr = baseFeeNonUnifiedAttr - round((disc * baseFeeNonUnifiedAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places
                                    
                                    //incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - (disc * incFeeNonUnifiedAttr/100);
                                    baseFeeNonUnifiedUSDAttr = baseFeeNonUnifiedUSDAttr - round((disc * baseFeeNonUnifiedUSDAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places
                                    //incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - (disc * incFeeNonUnifiedUSDAttr/100);
 
                        //} //Done Adding by Andre
            } else {
                        
                        //CSYS-86387 (LN. 11/4/2017) Need to ensure asset pricing is set on the Ramp:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  EXT_PRODUCT_BASED_PRICE)){
                              prodBasedPriceSubline = get(floatsDict, rampKey + DELIMITER +  EXT_PRODUCT_BASED_PRICE );
                             
                        }
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetBaseExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){
                              prodBasedPriceSubline = get(floatsDict, poID + DELIMITER + "assetBaseExtListPrice");
                              baseFeeListNonUnifiedAttr = get(floatsDict, poID + DELIMITER + "assetBaseExtListPrice");
                        }
                        //CSYS-86387: 
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  PROD_BASED_PRICE_USD)){
                              prodBasedPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  PROD_BASED_PRICE_USD );
                              
                        }
                        elif(assetAction == NONE_ACTION AND containskey(floatsDict, docNum + DELIMITER + EXT_LIST_PRICE_USD)){
                              prodBasedPriceSublineUSD = get(floatsDict, docNum + DELIMITER +  EXT_LIST_PRICE_USD );
                              baseFeeListNonUnifiedUSDAttr = get(floatsDict, docNum + DELIMITER +  EXT_LIST_PRICE_USD );
                        }
                        //Changed to use docNum instead of rampKey for cases 00179273 and  00179737 -BI
                        if(containskey(floatsDict, docNum + DELIMITER +  DISCOUNT_PERCENT)){
                              disc = get(floatsDict, docNum + DELIMITER +  DISCOUNT_PERCENT );
                        }           
                        if(containskey(stringsDict, rampKey + DELIMITER +  DISCOUNT_TYPE)){
                              discType = get(stringsDict, rampKey + DELIMITER +  DISCOUNT_TYPE );
                        } 
                                    //Add by Heidi 10/03/13
                        if(containskey(floatsDict, docNum + DELIMITER +  PROMO_DISC_PERCENT)){
                              promoDiscPercent = get(floatsDict, docNum + DELIMITER +  PROMO_DISC_PERCENT );
                        }                 
                     
                                    // End Heidi add
                                    
                       /*if(discType == AMOUNT_DISCOUNT_TYPE) {
                                    netPriceSubline = prodBasedPriceSubline - disc;
                                    // Fix for case 117077 - No discount % or amount is being stored in floatsDict for ramp keys
                                    netPriceSublineUSD = prodBasedPriceSublineUSD - disc;
                        } else {
                                    */
                        //CSYS-86387 (LN. 11/1/2017) Exclude NONE_ACTION codes from undergoing the discount calculation, discounts are off due to asset sync rounding up to a whole number.      
                        if(assetAction <> NONE_ACTION){
                              //CSYS-86115 (KA. 10-16-2017): added the condition to prevent line level discount from affecting user entered price:
                              if(overrideRampPrice == TRUE_STR AND containskey(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing")){
                              //netPriceSubline = prodBasedPriceSubline - newDisc;
                                    netPriceSubline = get(floatsDict, rampKey + DELIMITER + "userExtProductBasedPrice");
                                    netPriceSublineUSD = get(floatsDict, rampKey + DELIMITER + "userExtProductBasedPriceUSD");
                                    baseFeeNetBC = netPriceSubline;//CSYS-94451 (LN. 1-14-2019) 									
                              }
                              else{
									//CSYS-97907
									if (containskey(floatsDict, docNum + DELIMITER + "zeroListOverride" + EXT_NET_PRICE)){
										netPriceSubline = util.getFloatAttribute(floatsDict, docNum, DELIMITER, "zeroListOverride" + EXT_NET_PRICE);
										netPriceSublineUSD = util.getFloatAttribute(floatsDict, docNum, DELIMITER, EXT_NET_PRICE);										
									}
									else{
										netPriceSubline = prodBasedPriceSubline - round((promoDiscPercent * prodBasedPriceSubline/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places          //Heidi modified 10/4/13 to add promo discount to ramp plan
										netPriceSubline = netPriceSubline - round((disc * netPriceSubline/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places                            //and apply promo before user-entered discount
										
										// Fix for case 117077
										netPriceSublineUSD = prodBasedPriceSublineUSD - round((promoDiscPercent * prodBasedPriceSublineUSD/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places
										netPriceSublineUSD = netPriceSublineUSD - round((disc * netPriceSublineUSD/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places
										
                                    }
									baseFeeNetBC = netPriceSubline * billingCycleNumberFloat;//CSYS-94451 (LN. 1-14-2019) 
                              }

                        } else {
                              //CSYS-86387: 
                              if(containskey(floatsDict, docNum + DELIMITER +  EXT_NET_PRICE)){
                                    netPriceSubline = get(floatsDict, docNum + DELIMITER +  EXT_NET_PRICE);									
                                                      //CSYS-95575
                                                      baseFeeNetBC = netPriceSubline * billingCycleNumberFloat;
                              }
                              
                              if(containskey(floatsDict, docNum + DELIMITER + EXT_NET_PRICE_USD)){
                                    netPriceSublineUSD = get(floatsDict, docNum + DELIMITER + EXT_NET_PRICE_USD);
                              }
                        }            

                       // MM end 170798 }
                                    
                        // Fix for case 117077
                        /*if(containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_USD)){
                                    netPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_USD );
                        }*/
                        //increFeeNet node:
                        //CSYS-86387 (LN. 11/1/2017) When dealing with an Add-On NONE_ACTION code use the asset Incremental List and map to IncFeeList
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST)){
                            incBasedPriceSubline = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST );
						}
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){

                                    incBasedPriceSubline = get(floatsDict, poID + DELIMITER + "assetIncExtListPrice");
                        }
                        //CSYS-86387 (LN. 11/1/2017) When dealing with an Add-On NONE_ACTION code use the asset Incremental Net and map to IncFeeNet
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NET)){
                              incNetPriceSubline = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NET );

                        }
                        elif (assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtNetPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId")) {
                                    incNetPriceSubline = get(floatsDict, poID + DELIMITER + "assetIncExtNetPrice");
                        }

                        //CSYS-86387:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST_USD)){
                                    incBasedPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_LIST_USD );
                        }
                        elif (assetAction == NONE_ACTION AND containskey(floatsDict, incrementalDocNum + DELIMITER + EXT_LIST_PRICE_USD)) {
                                    incBasedPriceSublineUSD = get(floatsDict, incrementalDocNum + DELIMITER + EXT_LIST_PRICE_USD);
                        }
                        //CSYS-86387:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NET_USD)){
                                    incNetPriceSublineUSD = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NET_USD );
                        }
                        elif (assetAction == NONE_ACTION AND containskey(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE_USD)) {
                                    incNetPriceSublineUSD = get(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE_USD);
                        }
                                    

                        if(containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED)){
                                   baseFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED );
                                    // Fix for case 117077                                     
                                  /* if(discType == AMOUNT_DISCOUNT_TYPE) {
                                                baseFeeNonUnifiedAttr = baseFeeNonUnifiedAttr - disc;
                                    } else {
                                                      Matt Morman - Case 170798 - Changing to always get the discount percent*/
                                    baseFeeNonUnifiedAttr = baseFeeNonUnifiedAttr - round((promoDiscPercent * baseFeeNonUnifiedAttr/100), 2);   //CSYS-56717 2-8-2016 rounding the price to 2 places  //Heidi modified 10/4/13 to include promo discount
                                    baseFeeNonUnifiedAttr = baseFeeNonUnifiedAttr - round((disc * baseFeeNonUnifiedAttr/100), 2);   //CSYS-56717 2-8-2016 rounding the price to 2 places                    //and apply promo discount before user-entered discount
                                                 // MM end 170798  }
                        }
                        if(containskey(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED_USD)){
                                    baseFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  EXT_NET_PRICE_NON_UNIFIED_USD );
                                    // Fix for case 117077                                     
                                    /*if(discType == AMOUNT_DISCOUNT_TYPE) {
                                                baseFeeNonUnifiedUSDAttr = baseFeeNonUnifiedUSDAttr - disc;
                                    } else {
                                    Matt Morman - Case 170798 - Changing to always get the discount percent*/
                                    baseFeeNonUnifiedUSDAttr = baseFeeNonUnifiedUSDAttr - round((promoDiscPercent * baseFeeNonUnifiedUSDAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places       //Heidi modified 10/4/13 to include promo discount
                                    baseFeeNonUnifiedUSDAttr = baseFeeNonUnifiedUSDAttr - round((disc * baseFeeNonUnifiedUSDAttr/100), 2);             //CSYS-56717 2-8-2016 rounding the price to 2 places                   //and apply promo discount before user-entered discount
                                   // MM end 170798 }
                        } 
                                    
                                    
                                    
                        // Changed by Muthu Murugan Case 124022
                        //if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET)){
                        //incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET );
                        //CSYS-86387:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST)){
                                    incFeeListNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST);
                                    incFeeNonUnifiedAttr = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST);
                        }
                        elif( assetAction == NONE_ACTION AND containskey(floatsDict, poID + DELIMITER + "assetIncExtListPrice")
                        AND containskey(stringsDict, docNum + DELIMITER + "firstBaseofPoId") ){

                                    incFeeListNonUnifiedAttr = get(floatsDict, poID + DELIMITER + "assetIncExtListPrice");
                        }
                        //CSYS-86387:
                        if(assetAction <> NONE_ACTION AND containskey(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST_USD)){
                                    incFeeListNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST_USD);
                                    incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INCREMENTAL_FEE_NON_UNIFIED_LIST_USD);
                        } 
                        elif (assetAction == NONE_ACTION AND containskey(floatsDict, incrementalDocNum + DELIMITER + EXT_LIST_PRICE_USD)) {
                                    incFeeListNonUnifiedUSDAttr = get(floatsDict, incrementalDocNum + DELIMITER + EXT_LIST_PRICE_USD);
                        }         
                                    // Fix for case 121738                                     
                                    /*if(discType == AMOUNT_DISCOUNT_TYPE) {
                                                incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - disc;
                                    } else {
                                                      Matt Morman - Case 170798 - Changing to always get the discount percent*/
                                    incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - round((promoDiscPercent * incFeeNonUnifiedAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places       //Heidi modified 10/4/13 to include promo discount
                                    incFeeNonUnifiedAttr = incFeeNonUnifiedAttr - round((disc * incFeeNonUnifiedAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places                   //and apply promo discount before user-entered discount

                                   // MM end 170798 }
 
                        //}
                        //if(containskey(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD)){
                                    //incFeeNonUnifiedUSDAttr = get(floatsDict, rampKey + DELIMITER +  INC_FEE_NON_UNIFIED_NET_USD );
                                    // Fix for case 121738                                     
                                    /* if(discType == AMOUNT_DISCOUNT_TYPE) {
                                                incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - disc;
                                    } else {
                                                      Matt Morman - Case 170798 - Changing to always get the discount percent */
                                    incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - round((promoDiscPercent * incFeeNonUnifiedUSDAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places          //Heidi modified 10/4/13 to include promo discount
                                    incFeeNonUnifiedUSDAttr = incFeeNonUnifiedUSDAttr - round((disc * incFeeNonUnifiedUSDAttr/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places                            //and apply promo before user-entered discount
 
                        //          }

                        // MM end170798 }
                                    
                        //CSYS-94451 (LN. 1-14-2019) Commenting this out and added it above.  It appears that this is multiplying by Bill Cycle on User Entered Pricing and this is incorrect.
                        //baseFeeNetBC = netPriceSubline * billingCycleNumberFloat;  
                        
                        
                        
                        // Only set the net price to the actual net on the final ramp
                        if ( index == howManyRamps - 1 ){
                                    
							//CSYS-97907
							if (containskey(floatsDict, incrementalDocNum + DELIMITER + "zeroListOverride" + EXT_NET_PRICE)) {
								incNetWithDiscount = get(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE);
								incNetWithDiscountUSD = get(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE_USD);
							}
							else{
								// Apply incremental item discounts
								incNetWithDiscount = incBasedPriceSubline - round((promoDiscPercent * incBasedPriceSubline/100), 2);  //CSYS-56717 2-8-2016 rounding the price to 2 places                    //Heidi modified 10/4/13 to include promo discount
								incrementalDiscountValue = round(incNetWithDiscount * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
								incNetWithDiscount = incNetWithDiscount - incrementalDiscountValue; 
								incNetWithDiscountUSD = incBasedPriceSublineUSD - round((promoDiscPercent * incBasedPriceSublineUSD/100), 2); ///CSYS-56717 2-8-2016 rounding the price to 2 places           //Heidi modified 10/4/13 to include promo discount
								incrementalDiscountValueUSD = round(incNetWithDiscountUSD * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
								incNetWithDiscountUSD = incNetWithDiscountUSD - incrementalDiscountValueUSD; 
							}								
							/*append( incFeeNetUSD, util.fomatPrice(incNetWithDiscountUSD, "", NUM_DECIMAL_USD) );
							append( baseFeeNetUSD, util.fomatPrice(netPriceSublineUSD, "", NUM_DECIMAL_USD) );*/
							
							
							append( baseFeeNetUSD, string(netPriceSublineUSD * billingCycleNumberFloat));
							
							append( baseFeeNet, trim(replace(formatascurrency(baseFeeNetBC), CURRENCY_SYMBOL, "" )));
													
							//CSYS-86387 (LN. 11/1/2017) For Add-on's need to ensure the Inc Net Fee on the asset is set to the IncFeeNet node 
							//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
							if (UQGConcurDistinctExpense == TRUE_STR) {
								if (assetAction == NONE_ACTION) {
									append( incFeeNet, trim(replace(formatascurrency(incNetPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "")));
									append( incFeeNetUSD, string(incNetPriceSublineUSD * billingCycleNumberFloat));
								}
								else{
									append( incFeeNet, trim(replace(formatascurrency(incNetWithDiscount * billingCycleNumberFloat), CURRENCY_SYMBOL, "" ))); 
									append( incFeeNetUSD, string(incNetWithDiscountUSD * billingCycleNumberFloat));
								}
							}
							else {
								if (assetAction == NONE_ACTION) {
									
									append( incFeeNet, trim(replace(formatascurrency(incNetPriceSubline), CURRENCY_SYMBOL, "")));
									append( incFeeNetUSD, string(incNetPriceSublineUSD));
								}
								else{
									append( incFeeNet, trim(replace(formatascurrency(incNetWithDiscount), CURRENCY_SYMBOL, "" ))); 
									append( incFeeNetUSD, string(incNetWithDiscountUSD));
								}
							}
                        }
                        else{
                                    
									//CSYS-97907
									if (containskey(floatsDict, incrementalDocNum + DELIMITER + "zeroListOverride" + EXT_NET_PRICE)) {
										incNetWithDiscount = get(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE);
										incNetWithDiscountUSD = get(floatsDict, incrementalDocNum + DELIMITER + EXT_NET_PRICE_USD);
									}
									else{
										incNetWithDiscount = incBasedPriceSubline - round((promoDiscPercent * incBasedPriceSubline/100), 2);  //CSYS-56717 2-8-2016 rounding the price to 2 places                                            //Heidi modified 10/4/13 to include promo discount
										incrementalDiscountValue = round(incNetWithDiscount * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
										incNetWithDiscount = incNetWithDiscount - incrementalDiscountValue; 
										incNetWithDiscountUSD = incBasedPriceSublineUSD - round((promoDiscPercent * incBasedPriceSublineUSD/100), 2); //CSYS-56717 2-8-2016 rounding the price to 2 places
										incrementalDiscountValueUSD = round(incBasedPriceSublineUSD * incrementalDiscount, 2); //CSYS-56717 2-8-2016 rounding the discount amount to 2 places
										incNetWithDiscountUSD = incBasedPriceSublineUSD - incrementalDiscountValueUSD;                                                                                           
									}	
									//Heidi modified 10/4/13 to include promo discount
                                    
                                    /*append( incFeeNetUSD, util.fomatPrice(incNetWithDiscountUSD, "", NUM_DECIMAL_USD) );
                                    append( baseFeeNetUSD, util.fomatPrice(netPriceSublineUSD, "", NUM_DECIMAL_USD) );*/
                                    
                                    //append( incFeeNetUSD, string(incNetWithDiscountUSD));
                                    //append( baseFeeNetUSD, string(netPriceSublineUSD * billingCycleNumberFloat));
                                    
                                    
                                    
                                    //CSYS-86115:
                                    if(overrideRampPrice == TRUE_STR AND containskey(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing")){ //if user elected to overwrite the baseFeeNet/increFeeNet:
                                          append( baseFeeNet, trim(replace(formatascurrency(netPriceSubline), CURRENCY_SYMBOL, "" )));
                                          append( baseFeeNetUSD, string(netPriceSublineUSD));
                                          append( incFeeNet, trim(replace(formatascurrency(incNetPriceSubline), CURRENCY_SYMBOL, "" )) );
										  
                                          append( incFeeNetUSD, string(incNetPriceSublineUSD));
                                    } else{
                                          append( baseFeeNet, trim(replace(formatascurrency(netPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )));
                                          append( baseFeeNetUSD, string(netPriceSublineUSD * billingCycleNumberFloat));
										  
										  //IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
											if (UQGConcurDistinctExpense == TRUE_STR) {
												append( incFeeNet, trim(replace(formatascurrency(incNetWithDiscount * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )) );
												append( incFeeNetUSD, string(incNetWithDiscountUSD * billingCycleNumberFloat));
											}
											else{
												append( incFeeNet, trim(replace(formatascurrency(incNetWithDiscount), CURRENCY_SYMBOL, "" )) );										
												append( incFeeNetUSD, string(incNetWithDiscountUSD));
											}
                                    }

                        }
                        /*append( incFeeListUSD, util.fomatPrice(incBasedPriceSublineUSD, "", NUM_DECIMAL_USD) );
                        append( baseFeeListUSD, util.fomatPrice(prodBasedPriceSublineUSD, "", NUM_DECIMAL_USD) );*/
                        
						//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
						if (UQGConcurDistinctExpense == TRUE_STR) {
							append( incFeeListUSD, string(incBasedPriceSublineUSD * billingCycleNumberFloat));
							append( incFeeList, trim(replace(formatascurrency( incBasedPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )) );
						}
						else {
							append( incFeeListUSD, string(incBasedPriceSublineUSD));
							append( incFeeList, trim(replace(formatascurrency( incBasedPriceSubline), CURRENCY_SYMBOL, "" )) );
						}
                        
                        append( baseFeeListUSD, string(prodBasedPriceSublineUSD * billingCycleNumberFloat));
                        
                        append( baseFeeList, trim(replace(formatascurrency(prodBasedPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));
						
                        //Heidi added 10/22/13
                        //for non-bundled lines, the non-unified base fee and inc fee should equal the base fee net and inc fee net:
                        baseFeeNonUnifiedAttr = netPriceSubline;
						
                        baseFeeNonUnifiedUSDAttr = netPriceSublineUSD;

                        //CSYS-86116:
                        if(containskey(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing")){
                              userIncFeeNet = get(floatsDict, rampKey + DELIMITER + "userIncFeeNet");
                              userIncFeeNetUSD = get(floatsDict, rampKey + DELIMITER + "incrementalFeeNetUSD");//CSYS-95310
                              
                              incFeeNonUnifiedAttr = userIncFeeNet;
                              incFeeNonUnifiedUSDAttr = userIncFeeNetUSD;//CSYS-95310
                        }
                        else{ //business as usual:
                              incFeeNonUnifiedAttr = incNetWithDiscount;
                              incFeeNonUnifiedUSDAttr = incNetWithDiscountUSD;
                        }
                        
            }


            /*append( incFeeListNonUnifiedUSD, util.fomatPrice(incFeeListNonUnifiedUSDAttr, "", NUM_DECIMAL_USD ));
            append( baseFeeNonUnifiedUSD, util.fomatPrice(baseFeeNonUnifiedUSDAttr, "", NUM_DECIMAL_USD) );
            append( incFeeNonUnifiedUSD, util.fomatPrice(incFeeNonUnifiedUSDAttr, "", NUM_DECIMAL_USD) );
            append( baseFeeListNonUnifiedUSD, util.fomatPrice(baseFeeListNonUnifiedUSDAttr, "", NUM_DECIMAL_USD ));*/
			
			//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
			if (UQGConcurDistinctExpense == TRUE_STR) {
				append( incFeeListNonUnifiedUSD, string(incFeeListNonUnifiedUSDAttr * billingCycleNumberFloat));
			}
			else {
				append( incFeeListNonUnifiedUSD, string(incFeeListNonUnifiedUSDAttr));
			}
			
            //CSYS-88198 (fix baseFeeNonUnifiedNet and baseFeeNonUnifiedNetUSD for non-Monthly quotes. KA. 12-14-2017):
            if( (isGrouped == TRUE_STR AND containskey(stringsDict, parentRampKey + DELIMITER + "userEnteredRampPricing")) 
            OR (isGrouped <> TRUE_STR AND containskey(stringsDict, rampKey + DELIMITER + "userEnteredRampPricing")) ){
                  //do not multiply by billing cycle:
                  append( baseFeeNonUnified, trim(replace(formatascurrency(baseFeeNonUnifiedAttr), CURRENCY_SYMBOL, "") ));        
                  append( baseFeeNonUnifiedUSD, string(baseFeeNonUnifiedUSDAttr));
            } else{
                  //business as usual
                  append( baseFeeNonUnified, trim(replace(formatascurrency(baseFeeNonUnifiedAttr * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));        
                  append( baseFeeNonUnifiedUSD, string(baseFeeNonUnifiedUSDAttr * billingCycleNumberFloat));
            }

            //CSYS-86387 
            if(assetAction <> NONE_ACTION){
				if (UQGConcurDistinctExpense == TRUE_STR) {
					append( incFeeNonUnifiedUSD, string(incFeeNonUnifiedUSDAttr * billingCycleNumberFloat));
					append( incFeeNonUnified, trim(replace(formatascurrency(incFeeNonUnifiedAttr * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));   
				}
				else {
                  append( incFeeNonUnifiedUSD, string(incFeeNonUnifiedUSDAttr));
                  append( incFeeNonUnified, trim(replace(formatascurrency(incFeeNonUnifiedAttr), CURRENCY_SYMBOL, "") ));   
				}				  
            } else {
				
				//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
				if (UQGConcurDistinctExpense == TRUE_STR) {
					if(incNetNewUniSubline <> 0){
						append( incFeeNonUnified, trim(replace(formatascurrency(incNetNewUniSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));
					}
					else{
						append( incFeeNonUnified, trim(replace(formatascurrency(incNetPriceSubline * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));
					}
					  
					if(incNetUniUSDSubline <> 0){
						append( incFeeNonUnifiedUSD, string(incNetUniUSDSubline * billingCycleNumberFloat));
					}
					else{
						append( incFeeNonUnifiedUSD, string(incNetPriceSublineUSD * billingCycleNumberFloat));
					}
				}
				else { //IESCNQRCPQ-600 - End
                  //CSYS-104449 - Start
				  if(incNetNewUniSubline <> 0){
                  append( incFeeNonUnified, trim(replace(formatascurrency(incNetNewUniSubline), CURRENCY_SYMBOL, "") ));
				  }
				  else{
				  append( incFeeNonUnified, trim(replace(formatascurrency(incNetPriceSubline), CURRENCY_SYMBOL, "") ));
				  }
				  
				  if(incNetUniUSDSubline <> 0){
                  append( incFeeNonUnifiedUSD, string(incNetUniUSDSubline));
				  }
				  else{
				  append( incFeeNonUnifiedUSD, string(incNetPriceSublineUSD));
				  }
				  
				  //CSYS-104449 - End
				}				  
            }
            
            append( baseFeeListNonUnifiedUSD, string(baseFeeListNonUnifiedUSDAttr * billingCycleNumberFloat));
            append( transactionArr, string( subTransactions ));
			
			//IESCNQRCPQ-631(OK. 5-5-2023) When the UQG is "ConcurDistinctExpense" we need send transaction count without mutltipling with billing cycle
			if (UQGConcurDistinctExpense == TRUE_STR) {
				append( transactionBCArr , string(subTransactions));
			}
			else {
				append( transactionBCArr , string(subTransactions* billingCycleNumberFloat));
			}
			
            append( baseFeeListNonUnified, trim(replace(formatascurrency(baseFeeListNonUnifiedAttr * billingCycleNumberFloat), CURRENCY_SYMBOL, "") ));
			
			//IESCNQRCPQ-600(OK. 4-26-2023) When the UQG is "ConcurDistinctExpense" we need mutliply the Inc net fee with billing cycle
			if (UQGConcurDistinctExpense == TRUE_STR) {
				append( incFeeListNonUnified, trim(replace(formatascurrency(incFeeListNonUnifiedAttr * billingCycleNumberFloat), CURRENCY_SYMBOL, "" )));
			}
			else {
				append( incFeeListNonUnified, trim(replace(formatascurrency(incFeeListNonUnifiedAttr), CURRENCY_SYMBOL, "" )));
			}
			
            append( baseFeeNetBCArr, trim(replace(formatascurrency(baseFeeNetBC), CURRENCY_SYMBOL, "" )));
                  
                  if (containskey(incToBaseDict, pi) AND assetAction <> TERMINATE_ACTION){ //CSYS-37711 part 4 continued
                        append( baseIncKeyArr, get(incToBaseDict, pi)); //map the incremental PI to its base
                  }
                  else {
                        append( baseIncKeyArr, "");
                  }
                  
            index = index + 1;
}

//CSYS-85637 09/20/2017 - Reverting code to original ramp logic
//CSYS-83099 08/17/17
/*
if (containskey(stringsDict, "firstRampZero")){
      if (get(stringsDict, "firstRampZero") == "Yes"){
            baseFeeListUSD[0] = "0.00";
            baseFeeNetUSD[0] = "0.00";
            incFeeListUSD[0] = "0.00";
            incFeeNetUSD[0] = "0.00";
            baseFeeNonUnifiedUSD[0] = "0.00";
            incFeeNonUnifiedUSD[0] = "0.00";
            baseFeeListNonUnifiedUSD[0] = "0.00";
            incFeeListNonUnifiedUSD[0] = "0.00";
            baseFeeList[0] = "0.00";
            baseFeeNet[0] = "0.00";
            incFeeList[0] = "0.00";
            baseFeeNonUnified[0] = "0.00";
            incFeeNonUnified[0] = "0.00";
            baseFeeListNonUnified[0] = "0.00";
            incFeeListNonUnified[0] = "0.00";
            baseFeeNetBCArr[0] = "0.00";
      }
}
*/ 
put(lineItemRampPlanStrArrDict, BASE_FEE_LIST_XML_USD, baseFeeListUSD);
put(lineItemRampPlanStrArrDict, BASE_FEE_NET_XML_USD, baseFeeNetUSD);
put(lineItemRampPlanStrArrDict, INC_FEE_LIST_XML_USD, incFeeListUSD);
put(lineItemRampPlanStrArrDict, INC_FEE_NET_XML_USD, incFeeNetUSD);
put(lineItemRampPlanStrArrDict, BASE_FEE_NET_NON_UNIFIED_USD, baseFeeNonUnifiedUSD);
put(lineItemRampPlanStrArrDict, INC_FEE_NON_UNIFIED_NET_USD, incFeeNonUnifiedUSD);
put(lineItemRampPlanStrArrDict, BASE_FEE_LIST_NON_UNIFIED_USD_XML, baseFeeListNonUnifiedUSD);
put(lineItemRampPlanStrArrDict, INC_FEE_LIST_NON_UNIFIED_USD_XML, incFeeListNonUnifiedUSD);
put(lineItemRampPlanStrArrDict, BASE_FEE_LIST_XML, baseFeeList);
put(lineItemRampPlanStrArrDict, BASE_FEE_NET_XML, baseFeeNet);
put(lineItemRampPlanStrArrDict, INC_FEE_LIST_XML, incFeeList);
put(lineItemRampPlanStrArrDict, INC_FEE_NET_XML, incFeeNet);
put(lineItemRampPlanStrArrDict, BASE_FEE_NET_NON_UNIFIED, baseFeeNonUnified);
put(lineItemRampPlanStrArrDict, INC_FEE_NON_UNIFIED_NET, incFeeNonUnified);
put(lineItemRampPlanStrArrDict, BASE_FEE_LIST_NON_UNIFIED_XML, baseFeeListNonUnified);
put(lineItemRampPlanStrArrDict, INC_FEE_LIST_NON_UNIFIED_XML, incFeeListNonUnified);
put(lineItemRampPlanStrArrDict, "baseFeeNetBC", baseFeeNetBCArr);
put(lineItemRampPlanStrArrDict, TRANSACTION_XML_NODE_NAME, transactionArr);
// Case 114135 - Added by Muthu Murugan
put(lineItemRampPlanStrArrDict, TRANSACTION_BY_BC, transactionBCArr);
put(lineItemRampPlanStrArrDict, BASE_INC_KEY, baseIncKeyArr); //CSYS-37711 part 4 continued
 
return lineItemRampPlanStrArrDict;]]></script_text><_children><bm_lib_func_assoc><id>899432186</id><caller_func_id>15722788</caller_func_id><called_lib_func_id>4906075</called_lib_func_id><rule_area><![CDATA[Get Ramp XML String Array Dict]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1687447747000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[2b2c8fa0-dcdd-467d-8297-4756fc47abd8]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>15722790</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1687447747000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722791</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1687447747000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722792</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1687447747000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722793</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1687447747000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722794</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[parentDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1687447747000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_parentDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722795</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[howManyRamps]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1687447747000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_howManyRamps_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722796</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[isGrouped]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1687447747000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_isGrouped_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722797</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[billingCycleNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1687447747000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_billingCycleNumber_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722798</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[CURRENCY_SYMBOL]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1687447747000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_CURRENCY_SYMBOL_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>128368731</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[incToBaseDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1687447747000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_incToBaseDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>781705250</id><bm_lib_func_id>15722789</bm_lib_func_id><param_name><![CDATA[travelAndExpenseWithTriplinkProductArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1687447747000</date_modified><order_no>11</order_no><guid><![CDATA[bm_lib_func_util_getRampXMLStringArrayDict.bm_lib_func_param_travelAndExpenseWithTriplinkProductArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>70695906</id><name><![CDATA[evaluate]]></name><variable_name><![CDATA[evaluate]]></variable_name><description><![CDATA[Evaluates {expression} based on the dictionary passed {attrs} for truthiness]]></description><return_type>1</return_type><func_type>1</func_type><function_id>70695904</function_id><date_modified>1626948726000</date_modified><guid><![CDATA[bm_lib_func_util_evaluate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>70695904</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_evaluate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948726000</date_modified><guid><![CDATA[42330ddd-adf3-4d94-9b43-e9defd005b01]]></guid><script_size>2458</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[debug = false;
wildcard = "NA";
null = "";
quote = "\"";
delim = "|^|";
returnVal = -1;
ORop = " || ";
ANDop = " && ";
plusOp = "+";
multOp = "*";
gtOp = ">";
ltOp = "<";
gteOp = ">=";
lteOp = "<=";
eqOp = "=";
neOp = "<>";
tilOp = "~";
findOp = "(contains)";
emptyStr = "''";
boolOps = String[]{gteOp,lteOp,neOp,gtOp,ltOp,eqOp,findOp};

if(expression == null) {
  return expression;
}
if (substring(expression,0,1) == quote and substring(expression,-1) == quote) {
  return substring(expression,1,-1);
}

clauses = split(expression,ANDop);

clauseVals = String[];

i = 0;
for clause in clauses {
  
  clauseTrue = false;
  if(substring(clause,0,1) == quote and substring(clause,-1) == quote) {
    clauseTrue = true;
    clauseVals[i] = substring(clause,1,-1);
    i = i+1;
    continue;
  }
  subClauses = split(clause,ORop);
  subClauseVals = String[];
  j = 0;
  for subClause in subClauses {
    
    if(substring(subclause,0,1) == quote and substring(subclause,-1) == quote) {
      j=j+1;
      continue;
    }
    comps = String[]{subClause};
    thisOp = null;
    for op in boolOps {
      if(find(subClause,op)>0) {
        thisOp = op;
        comps = split(subClause,op);
        break;
      }
    }
    k = 0;
    for comp in comps {
     
      valNum = 0;
      valStr = null;
      if(substring(comp,0,1) == quote and substring(comp,-1) == quote) {
        valStr = substring(comp,1,-1);
      } else {
        summands = split(comp,plusOp);
        

        for summand in summands {
          if(summand == null) {
            continue;
          }
          if(isnumber(summand)) {
            valNum = valNum + atof(summand);
            continue;
          }
          mults = split(summand,multOp);
          mtotal = 1;
          
          for mult in mults {
            mNum = 1;
            if(isnumber(mult)) {
              mtotal = mtotal * atof(mult);
              continue;
            }
            isVariable = containskey(attrs,mult);
            if(isVariable) {
              varVal = get(attrs,mult);
              if(isnumber(varVal)) {
                mNum = atof(varVal);
              }
              else {
                valStr = varVal;
				//mNum = 0;
              }
            }
            if(not(isVariable)) { 
              valStr = comp;
              break;
            }
            mtotal = mtotal * mNum;
          }
          valNum = valNum + mtotal;
        }
      }

      if(valStr == null ) {
        valStr = string(valNum);
      }
	  elif( valStr == emptyStr ){
		valStr = "1";
	}
      
      comps[k] = valStr;
      k = k+1;
    }
    leftSide = 0;
    numbers = false;
    rightSide = 0;
    //rightSideNum = false;
    if(thisOp == null) {
      // no comparator, return value of expression
      clauseTrue = true;
      return comps[0];
    }
    if(isnumber(comps[0])) {
      leftSide = atof(comps[0]);
      numbers = true;
    }
    if(numbers) {
      if(not(isnumber(comps[1]))) {	



        numbers = false;
      } else {
        rightSide = atof(comps[1]);
      }
    }
    
    //clauseTrue = false;
    if(thisOp == gtOp) {
      if(numbers and leftSide > rightSide or
          (not(numbers) and comps[0] > comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == ltOp) {
      
      if(numbers and leftSide < rightSide or
          (not(numbers) and comps[0] < comps[1])) {
        
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == lteOp) {
      if(numbers and leftSide <= rightSide or
          (not(numbers) and comps[0] <= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == gteOp) {
      if(numbers and leftSide >= rightSide or
          (not(numbers) and comps[0] >= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == eqOp) {
      
      if(numbers and leftSide == rightSide or
          (not(numbers) and comps[0] == comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == neOp) {
      if(numbers and leftSide <> rightSide or
          (not(numbers) and comps[0] <> comps[1])) {
        clauseTrue = true;
        break;
      }
      
    }
    elif (thisOp == findOp) {
    	compsSplitArray = split(comps[0],tilOp);
    	if(findinarray(compsSplitArray, comps[1])>=0)
    	{
    		clauseTrue = true;
       		
       		break;
    	}
      /*if(find(comps[0], comps[1])>=0){
       	clauseTrue = true;
       	
       	break;
      }*/
    }
    j = j+1;
  }
  if(not(clauseTrue)) {
    return "FALSE";
  }
}
return "TRUE";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>70695908</id><bm_lib_func_id>70695906</bm_lib_func_id><param_name><![CDATA[expression]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948726000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_evaluate.bm_lib_func_param_expression_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>70695909</id><bm_lib_func_id>70695906</bm_lib_func_id><param_name><![CDATA[attrs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948726000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_evaluate.bm_lib_func_param_attrs_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>998736989</id><name><![CDATA[populatePricingKeyCollections]]></name><variable_name><![CDATA[populatePricingKeyCollections]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>998736988</function_id><date_modified>1678337969000</date_modified><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>998736988</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_populatePricingKeyCollections_1]]></java_class_name><child_class_names></child_class_names><date_modified>1678337969000</date_modified><guid><![CDATA[c12e2423-44ab-46d9-9b83-5c2bf68916ed]]></guid><script_size>982</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> populatePricingKeyCollections
docNumList - string[]
stringsDict - dict("string")
coreTerminateEditionDict - dict("string")
piQtyAndImplementationMethodList - string[]
piQtyAndImplementationMethodToPriceDict - dict("float")
piQtyAndImplementationMethodDict - dict("string")
piDict - dict("string")
integersDict - dict("integer")
*/
DELIMITER = "@.@";
QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
UOM_TYPE = "uomType_line";
IMPLEMENTATION_METHOD = "implementationMethod_line";
CORE_OFFERING = "coreOffering_line";
TERM_OF_COMMITMENT = "termOfCommitment_line";
PO_CATEGORY = "poCategory_line";
TERMINATED_CORE_ASSET_EDITION = "TERMINATED_CORE_ASSET_EDITION";
RAMP_DELIMITER = "-_**_-";
UOM_QTY = "QTY";
INCREMENTAL_PI = "incrementalPi";
PARENT_DOC_NUM = "_parent_doc_number"; //CSYS-106564
BILLING_COUNTER = "BILLING_COUNTER"; //CSYS-106564

for docNum in docNumList {
    //currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    pi = get(piDict, docNum);

    if (pi <> "") {
        //Initialize local variables
        quantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, QTY);
        trxns = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
        //Determine the UOM Type of this product
        uomType = util.getStringAttribute(stringsDict, pi, DELIMITER, UOM_TYPE);
        //Determine the implementionMethod of this line item
        implementationMethod = util.getStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD);
        //Determine the core Offering of this line item
        coreOffering = util.getStringAttribute( stringsDict, docNum, DELIMITER, CORE_OFFERING );
        // Determine the term of commitment of this line item
        termOfCommitment = util.getStringAttribute(stringsDict, docNum, DELIMITER, TERM_OF_COMMITMENT);
        //Determine the pricingKey for this line item.
        pricingKey = pi + DELIMITER;
        poCategory = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_CATEGORY);
		parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM); //CSYS-106564
		billingCounter = util.getStringAttribute( stringsDict, parentDocNum, DELIMITER, BILLING_COUNTER);//CSYS-106564

        if (uomType == UOM_QTY) {
            pricingKey = pricingKey + string(quantity);
        } else {
            pricingKey = pricingKey + string(trxns);
        }

        /* CSYS-95225 (LN. 3-28-2019)
            In the event that there is a CREATE/TERMINATE on an Core Edition Change with a Tier DECREASE,
            We need to retain the original Core's Edition to pass into stdTierPricing, otherwise the pricing retrieved
            is incorrect since the pi on the new Edition doesn't exist.

            CSYS-95591 (LN. 8-16-2019)
            Putting the Implementation Method into the StringsDict to be consumed by calculateTierPricing to set the Edition correctly.
        */
        if(containskey(coreTerminateEditionDict, pi + DELIMITER + TERMINATED_CORE_ASSET_EDITION)){
            implementationMethod = get(coreTerminateEditionDict, pi + DELIMITER + TERMINATED_CORE_ASSET_EDITION);
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD, implementationMethod);
        }

        //pricingKey = pricingKey + DELIMITER + implementationMethod + DELIMITER + coreOffering;
		//CSYS-106564 - Appending billingCounter and commented the above line
		pricingKey = pricingKey + DELIMITER + implementationMethod + DELIMITER + coreOffering + DELIMITER + billingCounter;

        /* RAMP PLAN INCREMENTAL PRICE
            If this is a ramp line item, we are also going to get an associated tier price for the incremental fee line item */
        incFeePricingKey = "";
        incMult = "1";

        if ( find( docNum, RAMP_DELIMITER ) <> -1 ){
            if ( uomType == UOM_QTY ){
                incMult = string(quantity);
            }
            else{
                incMult = string(trxns);
            }

            incPi = util.getStringAttribute( stringsDict, docNum, DELIMITER, INCREMENTAL_PI );
            //incFeePricingKey = incPi + DELIMITER + incMult + DELIMITER + implementationMethod + DELIMITER + coreOffering;
			//CSYS-106564 - Appending billingCounter and commented the above line
			incFeePricingKey = incPi + DELIMITER + incMult + DELIMITER + implementationMethod + DELIMITER + coreOffering + DELIMITER + billingCounter;
            append( piQtyAndImplementationMethodList, incFeePricingKey );
            put( piQtyAndImplementationMethodToPriceDict, incFeePricingKey, 0.0 );
        }

        //Populate pricingKey dictionaries
        put(piQtyAndImplementationMethodDict, docNum, pricingKey);
        append(piQtyAndImplementationMethodList, pricingKey);

        //Populate pricing dictionaries with pricingKeys
        put(piQtyAndImplementationMethodToPriceDict, pricingKey, 0.0);
    }
}
return "";]]></script_text><_children><bm_lib_func_assoc><id>998736998</id><caller_func_id>998736988</caller_func_id><called_lib_func_id>4906069</called_lib_func_id><rule_area><![CDATA[populatePricingKeyCollections]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1678337969000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[4b7e523b-ba77-4d46-b5d3-e8ca0d866d2b]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>998736999</id><caller_func_id>998736988</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[populatePricingKeyCollections]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1678337969000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[5010a1c1-8a28-433c-b1e5-669a02580059]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>998737000</id><caller_func_id>998736988</caller_func_id><called_lib_func_id>4906081</called_lib_func_id><rule_area><![CDATA[populatePricingKeyCollections]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1678337969000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[fa88c4fb-f931-440d-80b5-6e6618e4241a]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>998736990</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[docNumList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1678337969000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_docNumList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736991</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678337969000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736992</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[coreTerminateEditionDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678337969000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_coreTerminateEditionDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736993</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1678337969000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_piQtyAndImplementationMethodList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736994</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodToPriceDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1678337969000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_piQtyAndImplementationMethodToPriceDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736995</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678337969000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_piQtyAndImplementationMethodDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736996</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[piDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678337969000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_piDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998736997</id><bm_lib_func_id>998736989</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1678337969000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_populatePricingKeyCollections.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722802</id><name><![CDATA[Put Promotions Info]]></name><variable_name><![CDATA[putPromotionsInfo]]></variable_name><description><![CDATA[This util is for replacing the utils "getPromoInfo" and "getPromoDetails" and have the entire promotions logic in this one util]]></description><return_type>4</return_type><func_type>1</func_type><function_id>15722801</function_id><date_modified>1706178753000</date_modified><guid><![CDATA[bm_lib_func_util_putPromotionsInfo]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722801</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_putPromotionsInfo_1]]></java_class_name><child_class_names></child_class_names><date_modified>1706178753000</date_modified><guid><![CDATA[testconcur_13020879]]></guid><script_size>12930</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*Parameters to this UTIL
stringsDict
promotionsDataDict
promoResultsDict
promoCodeDescAndDetailsDict
internalPromoDescDictinternalPromoDescDict
externalPromoDescDict
customerFriendlyPromoDescDict
legalPromoDescDict
implementationMethodArr
partNumArr
*/
/* ------------------------- Variables for Promotions	----------------------- */
invalidPromoMessage = "";
promoCodeApplied = "";
promoCodeDetails = "";
//CSYS-98218
promoCodeAppliedArr = string[];

applicablePromotions = "";

// Static variables
PARENT_DOC_NUM = "_parent_doc_number";
ASSET_ACTION = "assetAction_line";
PART_NUM = "_part_number";
PO_CATEGORY = "poCategory_line";
ITEM_TYPE = "piItemType_line";
SERVICE_MODEL = "edition_line";
CORE_OFFERING = "coreOffering_line";
PO_ID = "poId_line";
DOC_NUM_RAMP_PLAN_DELIM = "_**_";
DATE_FORMAT_PREFERENCE_HYPHEN = "yyyy-MM-dd"; 
DATE_FORMAT_PREFERENCE_SLASH = "MM/dd/yyyy";
currentDateFormat= "";
startDateFormat = "";
endDateFormat = "";
DELIMITER = "@.@";
stringsDictDelimiter = "@.@";

promoSecretCodeDelimiter = ",";
externalPromoDelimiter = "~"; // Multi-Select in the buy side
applicablePromoDelimiter = "#^#";

// Get all the data needed from the promoDataDict to query promo information
autoAppliedPromotions = "";
ownerRegion = "";
ownerBU = "";
segment = "";
ownerMarket = "";
ownerRevenueGroup = "";
ownerTheater = "";
ownerTeam = "";
accountVertical = "";
customerType = "";
quoteType = "";
promotionSecretCode = "";
externalPromo = "";
quoteDocNum = "1";
orderedPromoCodeApplied = "";
applicablePromotions = "";
serviceModelArr = string[];
coreOfferingArr = string[];
poIdArr = string[];

// To order the promotions based on the execution order, use this dictionary
promoCodePromoCategoryStr = ""; //promoCode$^$promoCategory#^#promoCode$^$promoCategory...
promoCategoryExecList = string[];


// Promotions to be auto selected in addition to the ones selected by the user
autoAppliedPromos = "";
autoAppliedPromosArr = string[];

if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerRegion_quote")) {
  ownerRegion = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerRegion_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerBU_quote")) {
  ownerBU = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerBU_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "segment_quote")) {
  segment = get(stringsDict, quoteDocNum + stringsDictDelimiter + "segment_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerMarket_quote")) {
  ownerMarket = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerMarket_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerRevenueGroup_quote")) {
  ownerRevenueGroup = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerRevenueGroup_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "customerType_quote")) {
  customerType = get(stringsDict, quoteDocNum + stringsDictDelimiter + "customerType_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "quoteType_quote")) {
  quoteType = get(stringsDict, quoteDocNum + stringsDictDelimiter + "quoteType_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "promotionCode_quote")) {
  promotionSecretCode = get(stringsDict, quoteDocNum + stringsDictDelimiter + "promotionCode_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "externalPromotion_quote")) {
  externalPromo = get(stringsDict, quoteDocNum + stringsDictDelimiter + "externalPromotion_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerTheater_quote")) {
  ownerTheater = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerTheater_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerTeam_quote")) {
  ownerTeam = get(stringsDict, quoteDocNum + stringsDictDelimiter + "ownerTeam_quote");
}
if(containskey(stringsDict, quoteDocNum + stringsDictDelimiter + "accountVertical_quote")) {
  accountVertical = get(stringsDict, quoteDocNum + stringsDictDelimiter + "accountVertical_quote");
}

//  Get the line level paramters to fetch the promotion
for docNum in docNumList {
	if(find(docNum, DOC_NUM_RAMP_PLAN_DELIM) == -1) { // Ignore the keys with ramp plan keys
		serviceModelKey = docNum + stringsDictDelimiter + SERVICE_MODEL;
		if(containskey(stringsDict, serviceModelKey)) {
			append(serviceModelArr, get(stringsDict, serviceModelKey));
		}
		coreOfferingKey = docNum + stringsDictDelimiter + CORE_OFFERING;
		if(containskey(stringsDict, coreOfferingKey)) {
			append(coreOfferingArr, get(stringsDict, coreOfferingKey));		
		}
		piKey = docNum + stringsDictDelimiter + PART_NUM;
		if(containskey(stringsDict, piKey)) {
			pi = get(stringsDict, piKey);
			poIdKey = pi + stringsDictDelimiter + PO_ID;
			if(containskey(stringsDict, poIdKey)) {
				poId = get(stringsDict, poIdKey);
				if(findinarray(poIdArr, poId) == -1) {
					append(poIdArr, poId);
				}
			}
		}
	}
}

//currentDate = get(stringsDict, quoteDocNum + stringsDictDelimiter + "_system_date");
currentDate = datetostr(getDate());
// Select (and to show) only applicable promotions
applicablePromosArr = string[];
allApplicablePromosArr = string[];
uniquePromosArr = string[];
coreApplicablePromoArr = string[]; //for CSYS-53200. KA. 10-21-2015
promoCoreArr = string[]; //for CSYS-53200. KA. 10-21-2015
promoPiArr = string[]; //for CSYS-53200. KA. 10-21-2015
//CSYS-92211
netNewCorePromoArr = string[]; 
netNewCorePiArr = string[]; 
netNewExtServPromoArr = string[]; 
netNewExtServPiArr = string[];
isDigitalCommerceTransARR = string[]; //CSYS-101913
/*IESCNQRCPQ-231
isPremiumImplementationARR = string[]; 
professionalPromotionARR = string[];
isPremPromos = false;
isProfPromos = false;
*/
//IESCNQRCPQ-231

//CSYS-77853 main logic (KA. 3-3-2017):
promoListDict = dict("string[]");
//Query only the records that are dependent on core action code:
actionCodeBasedPromoResSet = bmql("SELECT Distinct promotionCode, coreOffering, coreActionCode FROM PromoCodeDetails WHERE coreActionCode IS NOT NULL");
for actionCodeBasedPromo in actionCodeBasedPromoResSet{
	promotionCode = get(actionCodeBasedPromo, "promotionCode");
	coreOffering = get(actionCodeBasedPromo, "coreOffering");
	coreActionCode = get(actionCodeBasedPromo, "coreActionCode");

	coreBasedPromoList = string[];

	if(containskey(promoListDict, coreOffering + DELIMITER + coreActionCode)){
		coreBasedPromoList = get(promoListDict, coreOffering + DELIMITER + coreActionCode);
	}

	//build 'core with action code' related lists:
	append(coreBasedPromoList, promotionCode);

	//build dictionary of lists:
	put(promoListDict, coreOffering + DELIMITER + coreActionCode, coreBasedPromoList);

}

//Intialize non-empty array to store the core action code based promos to show.
//Array must be non-empty for table query to work:
coreActionCodeBasedPromosToShow = string[]{"~PLACEHOLDERXXX~"};
for docNum in docNumList{
	assetAction = util.getStringAttribute(stringsDict, docNum, DELIMITER, ASSET_ACTION);
	coreOffering = util.getStringAttribute(stringsDict, docNum, DELIMITER, CORE_OFFERING);
	poCat = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_CATEGORY);

	//CSYS-77853: Check the line item Core Service action code and cross reference that to the related list built above:
	if(poCat == "Core Service" AND containskey(promoListDict, coreOffering + DELIMITER + assetAction)){

		promotionCodeList = get(promoListDict, coreOffering + DELIMITER + assetAction);

		//allow the following core action code based promos (these are promos whose availability is dependent on the core's action code):
		if(NOT isempty(promotionCodeList)){
			for promo in promotionCodeList{
				append(coreActionCodeBasedPromosToShow, promo);
			}
		}
	}

}

//END CSYS-77853 main logic

//CSYS-98999
promoCategoryDict = dict("string");

//CSYS-77853: added the following to the query: '(coreActionCode IS NULL OR promotionCode IN $coreActionCodeBasedPromosToShow)'
//CSYS-101913: Add isDigitalCommerce; //IESCNQRCPQ-231 Add isPremImplementation (Commenting as of now)
applicablePromoResSet = bmql("SELECT startDate, endDate, promotionCode, promoSfdcId, promoPI, autoApply, promotionCategory, coreOffering, netNewExtServ, netNewCore, requiredPO, businessUnit, ownerMarket, accountSegment, ownerRevenueGroup, ownerRegion, coreOffering, implementationMethod, customerType, quoteType, serviceModel, promoType, promoValue, addlDiscDisallowed, promoStartPeriod, promoEndPeriod, ownerTheater, ownerTeam, accountVertical, coreActionCode, isDigitalCommerce FROM PromoCodeDetails WHERE (coreActionCode IS NULL OR promotionCode IN $coreActionCodeBasedPromosToShow) AND (ownerRegion IS NULL OR ownerRegion=$ownerRegion) AND (businessUnit IS NULL OR businessUnit=$ownerBU) AND (accountSegment IS NULL OR accountSegment=$segment) AND (ownerMarket IS NULL OR ownerMarket=$ownerMarket) AND (ownerRevenueGroup IS NULL OR ownerRevenueGroup=$ownerRevenueGroup) AND (ownerTheater IS NULL OR ownerTheater=$ownerTheater) AND (ownerTeam IS NULL OR ownerTeam=$ownerTeam) AND (accountVertical IS NULL OR accountVertical=$accountVertical) AND (customerType IS NULL OR customerType=$customerType) AND (quoteType IS NULL OR quoteType=$quoteType) AND (implementationMethod IS NULL OR implementationMethod IN $implementationMethodArr) AND (serviceModel IS NULL OR serviceModel IN $serviceModelArr) AND (coreOffering IS NULL OR coreOffering IN $coreOfferingArr) AND (requiredPO IS NULL OR requiredPO IN $poIdArr) AND promoPI IN $partNumArr");


for applicablePromoRes in applicablePromoResSet {
	tempPromoCode = get(applicablePromoRes, "promotionCode");
	tempPromoCategory = get(applicablePromoRes, "promotionCategory");
	autoApply =  get(applicablePromoRes, "autoApply");
	tempPromoSfdcId = get(applicablePromoRes, "promoSfdcId" );
	startDate = get(applicablePromoRes, "startDate");
    endDate = get(applicablePromoRes, "endDate");
	coreOffering = get(applicablePromoRes, "coreOffering"); //for CSYS-50332. KA. 9-2-2015
	promoPI = get(applicablePromoRes, "promoPI");  //for CSYS-53200. KA. 10-21-2015
	
	//CSYS-101913 (TT. 02/01/2021)
	isDigitalCommerceTrans = get(applicablePromoRes, "isDigitalCommerce"); 
	if (isDigitalCommerceTrans == "TRUE"){
		append(isDigitalCommerceTransARR, tempPromoCode);
	}
	
	/*IESCNQRCPQ-231 (LBN 23/02/2023)
	isPremImplementationColumn = get(applicablePromoRes, "isPremImplementation");
	edition = get(applicablePromoRes, "implementationMethod");
	if(containskey(stringsDict, "premiumEdition") AND isPremImplementationColumn == "TRUE" AND edition == "Professional" AND (startswith(promoCode, "MOVE23")== true)) {   
		append(isPremiumImplementationARR, tempPromoCode);
		isPremPromos = true;
		append(applicablePromosArr, tempPromoCode);
	}
	
	if(containskey(stringsDict, "professionalEdition") AND isPremImplementationColumn == "FALSE" AND edition == "Professional" AND (startswith(promoCode, "MOVE23")== true)) { 
		append(professionalPromotionARR, tempPromoCode);
		isProfPromos = true;
		append(applicablePromosArr, tempPromoCode);
	}*/
	//IESCNQRCPQ-231 END
	
	//CSYS-98999
	if (NOT containskey(promoCategoryDict, tempPromoCode) ){
        	put( promoCategoryDict, tempPromoCode,  tempPromoCategory );    
    	}

	//CSYS-92211
	netNewExtServValue = get(applicablePromoRes, "netNewExtServ");
	netNewCoreValue = get(applicablePromoRes, "netNewCore");
	
	if (netNewCoreValue == "TRUE"){
		append(netNewCorePromoArr, tempPromoCode);
		append(netNewCorePiArr, promoPI);
	}

	if (netNewExtServValue == "TRUE"){
		append(netNewExtServPromoArr, tempPromoCode);
		append(netNewExtServPiArr, promoPI);
	}	

	if(coreOffering <> "" and findinarray(promoPiArr, promoPI) == -1){ //core based promos
		append(coreApplicablePromoArr, tempPromoCode); //CSYS-53200
		append(promoCoreArr, coreOffering); //CSYS-53200
		append(promoPiArr, promoPI); //CSYS-53200
	}
	
	if(find(currentDate, "/") <> -1) {
		currentDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
	} else {
		currentDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
	}
	if(find(startDate, "/") <> -1) {
		startDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
	} else {
		startDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
	}
	if(find(endDate, "/") <> -1) {
		endDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
	} else {
		endDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
	}
	put( stringsDict, "promoCodeSFDC" + stringsDictDelimiter + tempPromoCode, tempPromoSfdcId ); 
	if((comparedates(strtojavadate(currentDate, currentDateFormat), strtojavadate(startDate, startDateFormat)) >= 0) AND (comparedates(strtojavadate(currentDate, currentDateFormat), strtojavadate(endDate, endDateFormat)) <= 0)) {
		if(autoApply == "Yes") {
			append(autoAppliedPromosArr, tempPromoCode);
			if( /*CSYS-98218 find(promoCodeApplied, tempPromoCode) == -1 */ findinarray(promoCodeAppliedArr, tempPromoCode) == -1) {
				append(promoCodeAppliedArr, tempPromoCode); //CSYS-98218
				if(promoCodeApplied <> "") {
					promoCodeApplied = promoCodeApplied + "#^#";
					promoCodePromoCategoryStr = promoCodePromoCategoryStr + "#^#";
				}
				promoCodeApplied = promoCodeApplied  + tempPromoCode; 
				promoCodePromoCategoryStr = promoCodePromoCategoryStr + tempPromoCode + "$^$" + tempPromoCategory;
			}
		} else { 
		// Applicable promotions to include only the applicable promotions which are NOT auto apply - This is being used to dynamically display Available Promotions menu; IESCNQRCPQ-231: Adding isProfPromos(Commenting as of now)
			if(NOT(containskey(stringsDict, promoPI + stringsDictDelimiter + "partNumberNotValidForPromo")) OR tempPromoCode == "RENEWALOFFER90DAYS" /* AND isProfPromos == false */){
				append(allApplicablePromosArr, tempPromoCode);
			}
			//append(allApplicablePromosArr, tempPromoCode);
			if(findinarray(applicablePromosArr, tempPromoCode) == -1 /* AND isProfPromos == false */){ 
			//Detect if the PI on this row is an edition or core change line OR prod family create terminate line on the quote. If yes and NetNew lines are true then exclude the promo
				append(applicablePromosArr, tempPromoCode);

				if(NOT(containskey(stringsDict, promoPI + stringsDictDelimiter + "partNumberNotValidForPromo")) OR tempPromoCode == "RENEWALOFFER90DAYS" /* AND isProfPromos == false */){
					append(applicablePromosArr, tempPromoCode);
				}
			}
		}
	}
}

//CSYS-101913 (TT. 02/01/2021): Remove promocodes from applicable promocodes arr if it is not a Digital Commerce Transaction
if(NOT(isempty(isDigitalCommerceTransARR)) AND _user_login <> "hybris" ){
	i = 0;
	for promo in isDigitalCommerceTransARR{
		promoToRemove = isDigitalCommerceTransARR[i];
		promoToRemoveIndex = findinarray(allApplicablePromosArr, promoToRemove);
		if(findinarray(allApplicablePromosArr, promoToRemove) <> -1){
			remove(allApplicablePromosArr, promoToRemoveIndex);
		}

	i = i + 1;
	}
	promoToRemove = "";
}

//The next loop is for CSYS-53200. We need to remove invalid core specific promos mainly for multi core quotes. 
//This fixes the issue of being able to select a promo that doesn't get applied to anything. KA. 10-21-2015
for docNum in docNumList{
	piKey = docNum + stringsDictDelimiter + PART_NUM;
	itemTypeKey = docNum + stringsDictDelimiter + ITEM_TYPE;
	coreOfferingKey = docNum + stringsDictDelimiter + CORE_OFFERING;
	skipCoreLine = "";
	skipExtSvcLine = "";
	if(containskey(stringsDict, piKey) AND containskey(stringsDict, itemTypeKey) AND containskey(stringsDict, coreOfferingKey)) {
		pi = get(stringsDict, piKey);
		itemType = get(stringsDict, itemTypeKey);
		coreOffering = get(stringsDict, coreOfferingKey);
		if(itemType == "Base" AND findinarray(promoPiArr, pi) <> -1){ //core specific promo found
			loc = findinarray(promoPiArr, pi); //index of partnumber
			if(coreOffering <> promoCoreArr[loc]){
				promoToRemove = coreApplicablePromoArr[loc];
				promoToRemoveIndex = findinarray(applicablePromosArr, promoToRemove);
				if(findinarray(applicablePromosArr, promoToRemove) <> -1){
					remove(applicablePromosArr, promoToRemoveIndex); //remove invalid core specific promos from the applicablePromosArr
				}
			}
		}
	}
	//CSYS-92211
	skipCoreKey = docNum + stringsDictDelimiter + "skipCoreService";
	if(containskey(stringsDict, skipCoreKey)) {
		skipCoreLine = get(stringsDict, skipCoreKey);
	}

	skipExtSvcKey = docNum + stringsDictDelimiter + "skipExtendedService";
	if(containskey(stringsDict, skipExtSvcKey)) {
		skipExtSvcLine = get(stringsDict, skipExtSvcKey);
	}
	piNum = get(stringsDict, piKey);
	promoToRemove = "";
	i = 0;
	if (skipCoreLine <> ""){
		for piNumber in netNewCorePiArr{
			if (piNumber == piNum){
				promoToRemove = netNewCorePromoArr[i];
				promoToRemoveIndex = findinarray(allApplicablePromosArr, promoToRemove);
				if(findinarray(allApplicablePromosArr, promoToRemove) <> -1){
					remove(allApplicablePromosArr, promoToRemoveIndex);
				}
			}
			i = i + 1;
		}
		promoToRemove = "";
	}
	j = 0;
	if (skipExtSvcLine <> ""){
		for piNumber in netNewExtServPiArr{
			if (piNumber == piNum){
				promoToRemove = netNewExtServPromoArr[j];
				promoToRemoveIndex = findinarray(allApplicablePromosArr, promoToRemove);
				if(findinarray(allApplicablePromosArr, promoToRemove) <> -1){
					remove(allApplicablePromosArr, promoToRemoveIndex);
				}
			}
			j = j + 1;
		}
	}
}

for tempPromoCode in allApplicablePromosArr{
	if(findinarray(applicablePromosArr, tempPromoCode) <> -1 AND findinarray(uniquePromosArr, tempPromoCode) == -1){
		append(uniquePromosArr, tempPromoCode);		
	}
}
applicablePromosArr = uniquePromosArr;

//CSYS-99074
//CSYS-99236 If the we are within term, do not display the RENEWALOFFER90DAYS promo - only display when out of term (renewalPromoValidation set in Pricing)
if (NOT(containskey(stringsDict, "renewalPromoValidation")) AND findinarray(applicablePromosArr, "RENEWALOFFER90DAYS") <> -1){
	
	promoToRemoveIndex = findinarray(applicablePromosArr, "RENEWALOFFER90DAYS");
	remove(applicablePromosArr, promoToRemoveIndex);
}

/*CSYS-106955 (OK. 8-19-2022) Comment out the code related to "INVACHMIGRATEWAIVER" promotion
//CSYS-103355 (OK. 7-26-2021) Start: Do not display the INVACHMIGRATEWAIVER promo - only display when the "INVACHMIGRATEWAIVERPromoCheck" flag is true. setting this flag value in pricing function
if (NOT(containskey(stringsDict, "INVACHMIGRATEWAIVERPromoCheck")) AND findinarray(applicablePromosArr, "INVACHMIGRATEWAIVER") <> -1){
	promoIndexToRemove = findinarray(applicablePromosArr, "INVACHMIGRATEWAIVER");
	remove(applicablePromosArr, promoIndexToRemove);
}
//CSYS-103355 - End
*/

//CSYS-107751 (OK. 1-6-2023) Start: When SAP CoE Approved, display the new MOVE23 promotions. otherwise hide the promos. Setting "SAPCoENotApproved" flag value in pricing function
//IESCNQRCPQ-1383 (SV. 4-1-2023) Added MOVEBASE9MOWAIVER
MOVE23PromoArr = string[] {"MOVE23CONINT", "MOVE23EXPIT", "MOVE23MRA", "MOVE23CARE", "MOVE23SCOPE", "MOVE23T&MFEES", "MOVEBASE9MOWAIVER"};
if (containskey(stringsDict, "SAPCoENotApproved")) {
	for promo in MOVE23PromoArr {
		if(findinarray(applicablePromosArr, promo) <> -1) {
			promoIndexToRemove = findinarray(applicablePromosArr, promo);
			remove(applicablePromosArr, promoIndexToRemove);
		}
	}
}
//CSYS-107751- End

if(NOT(isempty(applicablePromosArr))) {
	applicablePromotions = join(applicablePromosArr, "#^#");
}

// Promotion Applied from secret code
if(promotionSecretCode <> "") {
	tempPromoCodeArr = split(promotionSecretCode, ",");
	count = false;
	for promo in tempPromoCodeArr {
		//CSYS-98999
		//tableResSet = bmql("SELECT startDate, endDate, promotionCategory FROM PromoCodeDetails WHERE promotionCode=$promo AND (coreActionCode IS NULL OR promotionCode IN $coreActionCodeBasedPromosToShow) AND (ownerRegion IS NULL OR ownerRegion=$ownerRegion) AND (businessUnit IS NULL OR businessUnit=$ownerBU) AND (accountSegment IS NULL OR accountSegment=$segment)  AND (ownerMarket IS NULL OR ownerMarket=$ownerMarket) AND (ownerRevenueGroup IS NULL OR ownerRevenueGroup=$ownerRevenueGroup) AND (ownerTheater IS NULL OR ownerTheater=$ownerTheater) AND (ownerTeam IS NULL OR ownerTeam=$ownerTeam) AND (accountVertical IS NULL OR accountVertical=$accountVertical) AND (customerType IS NULL OR customerType=$customerType) AND (quoteType IS NULL OR quoteType=$quoteType) AND (implementationMethod IS NULL OR implementationMethod IN $implementationMethodArr) AND (serviceModel IS NULL OR serviceModel IN $serviceModelArr) AND (coreOffering IS NULL OR coreOffering IN $coreOfferingArr) AND (requiredPO IS NULL OR requiredPO IN $poIdArr) AND promoPI IN $partNumArr");
		for item in applicablePromoResSet {
			promoFromTable = get(item, "promotionCode");
			if (promo == promoFromTable){
				count = true;
				startDate = get(item, "startDate");
				endDate = get(item, "endDate");
				tempPromoCategory = get(item, "promotionCategory");
				if(find(currentDate, "/") <> -1) {
				currentDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
				} else {
				currentDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
				}
				if(find(startDate, "/") <> -1) {
				startDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
				} else {
				startDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
				}
				if(find(endDate, "/") <> -1) {
				endDateFormat = DATE_FORMAT_PREFERENCE_SLASH;
				} else {
				endDateFormat = DATE_FORMAT_PREFERENCE_HYPHEN;
				}
				// Do the date comparison here
				if(comparedates(strtojavadate(currentDate, currentDateFormat), strtojavadate(startDate, "yyyy-MM-dd")) >= 0 AND comparedates(strtojavadate(currentDate, currentDateFormat), strtojavadate(endDate, "yyyy-MM-dd")) <= 0) {
				if(promoCodeApplied <> "") {
				  promoCodeApplied = promoCodeApplied + "#^#";
				  promoCodePromoCategoryStr = promoCodePromoCategoryStr + "#^#";
				}
				promoCodeApplied = promoCodeApplied + promo; 
				promoCodePromoCategoryStr = promoCodePromoCategoryStr + promo + "$^$" + tempPromoCategory;
				} else {
				invalidPromoMessage = "Entered Promotion is invalid!";
				}
			}
		}
	}
	if(NOT(count)) {
		invalidPromoMessage = "Entered Promotion is invalid!";
	}
}

// Promotion Applied from Multi-select menu
if(NOT(isnull(externalPromo)) AND len(externalPromo) > 0) {
	externalPromoApplied = split(externalPromo, "~");
	for item in externalPromoApplied {
		if ( findinarray( applicablePromosArr, item ) == -1 ){
			continue;
		}
		tempPromoCategory = "";
		//CSYS-98999
		//promoCategoryResSet = bmql("SELECT promotionCode, promotionCategory FROM PromoCodeDetails WHERE promotionCode=$item"); // under the assumption that each promo code can have only one promotion category, no need to use other conditions in the query
		/*
		for promoCategoryRes in promoCategoryResSet {
			tempPromoCategory = get(promoCategoryRes, "promotionCategory");
		}*/
		if (containskey(promoCategoryDict, item)){
			tempPromoCategory = get(promoCategoryDict, item);
		}
		if( /* CSYS-98218 find(promoCodeApplied, item) == -1 */ findinarray(promoCodeAppliedArr, item) == -1) {
			append(promoCodeAppliedArr, item); //CSYS-98218
			if(promoCodeApplied <> "") {
    			promoCodeApplied = promoCodeApplied + "#^#";
				promoCodePromoCategoryStr = promoCodePromoCategoryStr + "#^#";
			}
			promoCodeApplied = promoCodeApplied  + item; 
			promoCodePromoCategoryStr = promoCodePromoCategoryStr + item + "$^$" + tempPromoCategory + "#^#";
		}
	}
}

//Auto apply promotions
if(NOT(isempty(autoAppliedPromosArr))) {
	autoAppliedPromos = join(autoAppliedPromosArr, ",");
}

// Promotion Execution Order
promoExecOrderResSet = bmql("SELECT promotionCategory FROM PromotionExecOrder ORDER BY orderNum");
for promoExecOrderRes in promoExecOrderResSet {
	append(promoCategoryExecList, get(promoExecOrderRes, "promotionCategory"));
}
promoCodePromoCategoryArr = split(promoCodePromoCategoryStr, "#^#");
for promoCategory in promoCategoryExecList {
	for promoCodePromoCategory in promoCodePromoCategoryArr {
		if(find(promoCodePromoCategory, "$^$" + promoCategory) <> -1) {
			promoCodeArr = split(promoCodePromoCategory, "$^$");
			if(orderedPromoCodeApplied <> "") {
				orderedPromoCodeApplied = orderedPromoCodeApplied + "#^#";
			} 
			orderedPromoCodeApplied = orderedPromoCodeApplied + promoCodeArr[0];
		}
	}	
}
// If orderedPromoCodeApplied is set, promotion execution order exists and applied
if(orderedPromoCodeApplied <> "") {
	promoCodeApplied = orderedPromoCodeApplied;
}
put(promoResultsDict, "promoCodeApplied", promoCodeApplied);
put(promoResultsDict, "applicablePromotions", applicablePromotions);
put(promoResultsDict, "invalidPromoMessage", invalidPromoMessage);
put(promoResultsDict, "autoAppliedPromotions", autoAppliedPromos);

if(containskey(promoResultsDict, "promoCodeApplied")) {
	promoCodeApplied = get(promoResultsDict, "promoCodeApplied");
}

if(containskey(promoResultsDict, "applicablePromotions")) {
	applicablePromotions = get(promoResultsDict, "applicablePromotions");
}
if(containskey(promoResultsDict, "invalidPromoMessage")) {
	invalidPromoMessage = get(promoResultsDict, "invalidPromoMessage");
}
if(containskey(promoResultsDict, "autoAppliedPromotions")) {
	autoAppliedPromotions = get(promoResultsDict, "autoAppliedPromotions");
}
// Get the promotion Code Description (used to display the table at the quote level)  and Promo Code Details  (XML format)
tempPromoCodeAppliedArr = split(promoCodeApplied, "#^#"); 

if(applicablePromotions <> "") {
	applicablePromosArr = split(applicablePromotions, "#^#");
}
autoAppliedPromosArr = split(autoAppliedPromotions, ",");
for item in autoAppliedPromosArr {
	append(applicablePromosArr, item);
}

promoCodeDetails = "<promoDesc>";
//CSYS-98999
promoMessageDict = dict("string");
promoCodeDescResSet = bmql("SELECT promotionCode, description, descriptionType, orderNum FROM PromoMessage WHERE promotionCode IN $applicablePromosArr ORDER BY promotionCode, descriptionType, orderNum");

for promo in applicablePromosArr {
	internalDesc = "";
	externalDesc = "";
	customerFriendlyDesc = "";
	legalDesc = "";
	internalDescOrder = 1;
	externalDescOrder = 1;
	customerFriendlyDescOrder = 1;
	legalDescOrder = 1;
	// Get Promo Code Description
	//CSYS-98999
	//promoCodeDescResSet = bmql("SELECT description, descriptionType, orderNum FROM PromoMessage WHERE promotionCode=$promo");
	for resSet in promoCodeDescResSet {
		//CSYS-98999
		promoNameFromTable = get(resSet, "promotionCode");
		if(promoNameFromTable == promo){
			descType = get(resSet, "descriptionType");
			if(descType == "INTERNAL_NAME" AND get(resSet, "orderNum") == string(internalDescOrder)) {
				internalDesc = internalDesc + get(resSet, "description");
				internalDescOrder = internalDescOrder + 1;
			}
			if(descType == "INTERNAL_DESC" AND get(resSet, "orderNum") == string(externalDescOrder)) {
				externalDesc = externalDesc + get(resSet, "description");
				externalDescOrder = externalDescOrder + 1;
			}
			if(descType == "CUSTOMER_FRIENDLY" AND get(resSet, "orderNum") == string(customerFriendlyDescOrder)) {
				customerFriendlyDesc = customerFriendlyDesc + get(resSet, "description");
				customerFriendlyDescOrder = customerFriendlyDescOrder + 1;
			}
			if(descType == "LEGAL" AND get(resSet, "orderNum") == string(legalDescOrder)) {
				legalDesc = legalDesc + get(resSet, "description");
				legalDescOrder = legalDescOrder + 1;
			}
			if(len(internalDesc) > 0) {
				put(internalPromoDescDict, promo, internalDesc);
			}
			if(len(externalDesc) > 0) {
				put(externalPromoDescDict, promo, externalDesc);
			}
			if(len(customerFriendlyDesc) > 0) {
				put(customerFriendlyPromoDescDict, promo, customerFriendlyDesc);
			}
			if(len(legalDesc) > 0) {
				put(legalPromoDescDict, promo, legalDesc);	
			}
		}
	}
}

for promo in applicablePromosArr {
	internalDesc = "";
	externalDesc = "";
	customerFriendlyDesc = "";
	legalDesc = "";
	startDate = "";
	endDate = "";
	promotionCategory = "";
	if(containskey(internalPromoDescDict, promo))  {
		internalDesc = get(internalPromoDescDict, promo);
	}
	if(containskey(externalPromoDescDict, promo))  {
		externalDesc = get(externalPromoDescDict, promo);
	}
	if(containskey(customerFriendlyPromoDescDict, promo))  {
		customerFriendlyDesc = get(customerFriendlyPromoDescDict, promo);
	}
	if(containskey(legalPromoDescDict, promo))  {
		legalDesc = get(legalPromoDescDict, promo);
	}
	// Get the start and end date for the promo to display in the quote
	//promoDatesResSet = bmql("SELECT promotionCategory, startDate, endDate FROM PromoCodeDetails WHERE promotionCode = $promo");
	/*for promoDatesRes in promoDatesResSet {
		promotionCategory = get(promoDatesRes, "promotionCategory");
		startDate = get(promoDatesRes, "startDate");
		endDate = get(promoDatesRes, "endDate");
	}*/
	//CSYS-98999
	for promoDatesRes in applicablePromoResSet {
		promoFromTable = get(promoDatesRes, "promotionCode");
		if (promo == promoFromTable){
			promotionCategory = get(promoDatesRes, "promotionCategory");
			startDate = get(promoDatesRes, "startDate");
			endDate = get(promoDatesRes, "endDate");
		}
	}
	
	if(len(promo) > 0) {
		promoCodeDetails = promoCodeDetails + "<code>" + "<id>" + promo + "</id>" + "<startDate>" + startDate + "</startDate>" + "<endDate>" + endDate + "</endDate>" + "<applied>";
		if(findinarray(tempPromoCodeAppliedArr, promo)  <> -1) {
			promoCodeDetails = promoCodeDetails + "TRUE";
		} else {
			promoCodeDetails = promoCodeDetails + "FALSE";
		}
		promoCodeDetails = promoCodeDetails + "</applied>" + "<promoCat>" + promotionCategory + "</promoCat>";
		if(len(internalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<INTERNAL_NAME>" + internalDesc + "</INTERNAL_NAME>";
		}
		if(len(externalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<INTERNAL_DESC>" + externalDesc + "</INTERNAL_DESC>";
		}
		if(len(customerFriendlyDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<CUSTOMER_FRIENDLY>" + customerFriendlyDesc + "</CUSTOMER_FRIENDLY>";
		}
		if(len(legalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<LEGAL>" + legalDesc + "</LEGAL>";
		}
		promoCodeDetails = promoCodeDetails + "</code>";
	}
}
promoCodeDetails = promoCodeDetails + "</promoDesc>";
put(promoCodeDescAndDetailsDict, "promoCodeDetails", promoCodeDetails); 
//return promoCodeDescAndDetailsDict;

if(containskey(promoCodeDescAndDetailsDict, "promoCodeDetails")) {
	promoCodeDetails = get(promoCodeDescAndDetailsDict, "promoCodeDetails");
}
// Populate the promotionsDataDict to be used to calculate line level promotions
//promotionsDataResSet = bmql("SELECT promotionCode, requiredPO, businessUnit, ownerMarket, accountSegment, ownerRevenueGroup, ownerRegion, coreOffering, coreActionCode, implementationMethod, customerType, quoteType, serviceModel, autoApply, startDate, endDate, promotionCategory, promoPI, promoType, promoValue, addlDiscDisallowed, promoStartPeriod, promoEndPeriod, ownerTheater, ownerTeam, accountVertical, netNewExtServ, netNewCore from PromoCodeDetails");
//promoArr = string []; // temporary array used to find repeated promo rows
promoArr = dict("string"); //NS Case 144381 had to change the array to a dictionary due to size limitations
//CSYS-98999
//for promotionsDataRes in promotionsDataResSet {
for promotionsDataRes in applicablePromoResSet {
	promoCodeRes = get(promotionsDataRes, "promotionCode");
	requiredPORes = get(promotionsDataRes, "requiredPO");
	businessUnitRes = get(promotionsDataRes, "businessUnit");
	marketRes = get(promotionsDataRes, "ownerMarket");
	segmentRes = get(promotionsDataRes, "accountSegment");
	revenueGroupRes = get(promotionsDataRes, "ownerRevenueGroup");
	regionRes = get(promotionsDataRes, "ownerRegion");
	coreOfferingRes = get(promotionsDataRes, "coreOffering");
	implementationMethodRes = get(promotionsDataRes, "implementationMethod");
	customerTypeRes = get(promotionsDataRes, "customerType");
	quoteTypeRes = get(promotionsDataRes, "quoteType");
	serviceModelRes = get(promotionsDataRes, "serviceModel");
	autoApplyRes = get(promotionsDataRes, "autoApply");
	startDateRes = get(promotionsDataRes, "startDate");
	endDateRes = get(promotionsDataRes, "endDate");
	promotionCategoryRes = get(promotionsDataRes, "promotionCategory");	
	promoPI = get(promotionsDataRes, "promoPI");
	promoType = get(promotionsDataRes, "promoType");
	promoValue = get(promotionsDataRes, "promoValue");
	addlDiscDisAllowed = get(promotionsDataRes, "addlDiscDisallowed");
	promoStartPeriod = get(promotionsDataRes, "promoStartPeriod");
	promoEndPeriod = get(promotionsDataRes, "promoEndPeriod");
	ownerTheaterRes = get(promotionsDataRes, "ownerTheater");
	ownerTeamRes = get(promotionsDataRes, "ownerTeam");
	accountVerticalRes = get(promotionsDataRes, "accountVertical");
	coreActionCode = get(promotionsDataRes, "coreActionCode"); //CSYS-77853
	netNewExtServ = get(promotionsDataRes, "netNewExtServ");//CSYS-88388
	netNewCore = get(promotionsDataRes, "netNewCore");//CSYS-88388	
	
	promoDataKey = promoCodeRes + DELIMITER + promoPI;
	promoDataValue = requiredPORes + DELIMITER + businessUnitRes + DELIMITER + marketRes + DELIMITER + segmentRes + DELIMITER + revenueGroupRes + DELIMITER + regionRes + DELIMITER + coreOfferingRes +DELIMITER + implementationMethodRes +DELIMITER + customerTypeRes + DELIMITER + quoteTypeRes + DELIMITER + serviceModelRes + DELIMITER + autoApplyRes + DELIMITER + startDateRes +DELIMITER + endDateRes + DELIMITER + promotionCategoryRes  + DELIMITER + promoType + DELIMITER + promoValue + DELIMITER + addlDiscDisAllowed + DELIMITER + promoStartPeriod + DELIMITER + promoEndPeriod + DELIMITER + ownerTheater + DELIMITER + ownerTeam + DELIMITER + accountVertical + DELIMITER + coreActionCode + DELIMITER + netNewExtServ + DELIMITER + netNewCore;
	promoValueArr = string[];			
						
	if(containskey(promoArr, promoDataKey) == false) { //This means no such key exists until now in the dictionary
		put(promoArr, promoDataKey, promoDataKey);
		append(promoValueArr, promoDataValue);
		put(promotionsDataDict, promoDataKey, promoValueArr);
	} else  {
		if(containskey(promotionsDataDict, promoDataKey)) {
			promoValueArr = get(promotionsDataDict, promoDataKey);
			append(promoValueArr, promoDataValue);
			put(promotionsDataDict, promoDataKey, promoValueArr);
		}
	}
} 

return true;]]></script_text><_children><bm_lib_func_assoc><id>405584581</id><caller_func_id>15722801</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[Put Promotions Info]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1706178753000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[e7b3bd03-4953-4304-817d-0cc44ea38b4e]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>15722803</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722804</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[promoResultsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_promoResultsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722805</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[promotionsDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1706178753000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_promotionsDataDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722806</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[promoCodeDescAndDetailsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_promoCodeDescAndDetailsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722807</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[internalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_internalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722808</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[externalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_externalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722809</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[customerFriendlyPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_customerFriendlyPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722810</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[legalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1706178753000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_legalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722811</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[docNumList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1706178753000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_docNumList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722812</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[implementationMethodArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1706178753000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_implementationMethodArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722813</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[partNumArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1706178753000</date_modified><order_no>11</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param_partNumArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1074961916</id><bm_lib_func_id>15722802</bm_lib_func_id><param_name><![CDATA[_user_login]]></param_name><ref_id>3</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1706178753000</date_modified><order_no>12</order_no><guid><![CDATA[bm_lib_func_util_putPromotionsInfo.bm_lib_func_param__user_login_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4917908</id><name><![CDATA[printError]]></name><variable_name><![CDATA[printError]]></variable_name><description><![CDATA[Prints the error message from a utilResultDict, if it exists.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4917907</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_printError]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4917907</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_printError_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435921000</date_modified><guid><![CDATA[LEGACY_4917907]]></guid><script_size>251</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> printError

utilResultDict - String Dictionary
tabs - Integer

*/
tabString = "";
tabList = range(tabs);
for t in tabList {
	tabString = tabString + "> > ";
}

result = tabString + "error: ";
if (containskey(utilResultDict, "error")) {
	result = result + get(utilResultDict, "error");
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4917910</id><bm_lib_func_id>4917908</bm_lib_func_id><param_name><![CDATA[utilResultDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_printError.bm_lib_func_param_utilResultDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4917911</id><bm_lib_func_id>4917908</bm_lib_func_id><param_name><![CDATA[tabs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_printError.bm_lib_func_param_tabs_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722767</id><name><![CDATA[Add Months To Date]]></name><variable_name><![CDATA[addMonthsToDate]]></variable_name><description><![CDATA[Adds a specified number of months to a date.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>15722766</function_id><date_modified>1608202537000</date_modified><guid><![CDATA[bm_lib_func_util_addMonthsToDate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722766</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_addMonthsToDate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1608202537000</date_modified><guid><![CDATA[devconcur_9523823]]></guid><script_size>2197</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[newDate = "";
extendedMonths = 0;
dateDelimiter = "";
dateSplit = string[];
dateText = substring((inputDate), 0, 10);
yearVal = "";
dashString = "";

if( find(dateText,"-") <> -1 ){
	dateSplit = split(dateText,"-");
	dateDelimiter = "-";
	yearVal = dateSplit[0];
}
elif( find(dateText,"/") <> -1 ){ //fix validation rules that use this UTIL
	dateSplit = split(dateText,"/");
	dashString = dateSplit[2] + "-" + dateSplit[0] + "-" + dateSplit[1];
	dateDelimiter = "-";
	dateSplit = split(dashString,"-");
	yearVal = dateSplit[0];
}


isLeapYear = false; //for CSYS-40596
if (isnumber(yearVal)){
	isLeapYear = isleap(atoi(yearVal)); 
}

daysDict = dict("integer");
put(daysDict,"00",31);
put(daysDict,"01",31);
if (NOT isLeapYear){put(daysDict,"02",28);}
else {put(daysDict,"02",29);}
put(daysDict,"03",31);
put(daysDict,"04",30);
put(daysDict,"05",31);
put(daysDict,"06",30);
put(daysDict,"07",31);
put(daysDict,"08",31);
put(daysDict,"09",30);
put(daysDict,"10",31);
put(daysDict,"11",30);
put(daysDict,"12",31);

if( sizeofarray(dateSplit) > 0 AND isnumber(dateSplit[1]) ){
	extendedMonths = atoi(dateSplit[1]) + atoi(months) ;
	if( extendedMonths <=0 ){
		
		negExMonth = integer(fabs(extendedMonths));
		if (fmod(negExMonth,12) == 0) { // To avoid adding extra year
			dateSplit[0] = string(atoi(dateSplit[0]) - (Integer(negExMonth/12))-1);
			dateSplit[1] = "12";
		} else {
			dateSplit[0] = string(atoi(dateSplit[0]) - (Integer(negExMonth/12))-1);
			dateSplit[1] = string(12-integer(fmod(negExMonth,12)));
		}		
		if( len(dateSplit[1]) == 1 ){
			dateSplit[1] = "0" + string(12-integer(fmod(negExMonth,12)));
		}
	}
	elif(extendedMonths > 12){
		if (fmod(extendedMonths,12) == 0) { // To avoid adding extra year
			dateSplit[0] = string(atoi(dateSplit[0]) + (Integer(extendedMonths/12))-1);
			dateSplit[1] = "12";
		} else {
			dateSplit[0] = string(atoi(dateSplit[0]) + Integer(extendedMonths/12));
			dateSplit[1] = string(integer(fmod(extendedMonths,12)));
		}		
		if( len(dateSplit[1]) == 1 ){
			dateSplit[1] = "0" + string(integer(fmod(extendedMonths,12)));
		}
	}
	else{
		dateSplit[1] = string(extendedMonths);
		if( len(dateSplit[1]) == 1 ){
			dateSplit[1] = "0" + string(integer(fmod(extendedMonths,12)));
		}
	}
	if (integer(atof(dateSplit[2])) > get(daysDict,dateSplit[1])) {
		dateSplit[2] = string(get(daysDict,dateSplit[1]));
	}
	newDate = join(dateSplit,dateDelimiter);
}
return newDate;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722768</id><bm_lib_func_id>15722767</bm_lib_func_id><param_name><![CDATA[inputDate]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1608202537000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_addMonthsToDate.bm_lib_func_param_inputDate_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722769</id><bm_lib_func_id>15722767</bm_lib_func_id><param_name><![CDATA[months]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1608202537000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_addMonthsToDate.bm_lib_func_param_months_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>1715678883</id><name><![CDATA[Set Properties For CIP Parts for Japan]]></name><variable_name><![CDATA[setPropertiesForCIPPartsforJapan]]></variable_name><description><![CDATA[IESCNQRCPQ-242 (PG 07/03/2023) Copy of "setPropertiesOfCIPParts" util function for Japan]]></description><return_type>15</return_type><func_type>1</func_type><function_id>1715678882</function_id><date_modified>1680773585000</date_modified><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPPartsforJapan]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>1715678882</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_setPropertiesForCIPPartsforJapan_1]]></java_class_name><child_class_names></child_class_names><date_modified>1680773585000</date_modified><guid><![CDATA[f51f2a21-7299-4316-aec6-1b585e9de72a]]></guid><script_size>1588</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-96006
cipPiDict = dict("string");
TILDE_DELIMITER = "~";

//CSYS-100546 (OK. 3-3-2021) Adding logic for CIP Travel Authorized products and removing partnerSpecialty from the below conditions
partnerTypeCIP = get(attributesDict, "accountServicePartnerTypeCIP_quote", "string");
partnerAuthrznsArr = split(partnerAuthrzns, ";");
cipTravelAuthorized = "";
coreValueArray = String[];
firstCipCore = "";
walkMeAuthorized = ""; //CSYS-104401 (OK. 10-11-2021)
cIPForWalkMeONLY = get(attributesDict, "cIPForWalkMeONLY_quote", "boolean"); //IESCNQRCPQ-430 (OK. 3-20-2023)

//IESCNQRCPQ-430 (OK. 3-20-2023) Add new if condition to support the WalkMe SKU CIP. When cIPForWalkMeONLY_quote = true only walkMe SKU will be considered as CIP. cIPForWalkMeONLY_quote <> true means normal query will be used
cipRez = recordset();
if (cIPForWalkMeONLY == true) {
	cipRez = BMQL("SELECT partNumber, coreService, ServPartnerSpecialty, ServPartnerAuthrzns FROM cipSetupFees WHERE partNumber IN $partNumArr AND JapanCIPSpecificSKU = 'YES'");
}
else {
	cipRez = BMQL("SELECT partNumber, coreService, ServPartnerSpecialty, ServPartnerAuthrzns FROM cipSetupFees WHERE partNumber IN $partNumArr AND IncludeJapan = 'YES'");
}

for entry in cipRez {
	cipPi = get(entry, "partNumber");
	cipCore = get(entry, "coreService");
	servicePartnerSpecialty = get(entry, "ServPartnerSpecialty");
	servPartnerAuthrzns = get(entry, "ServPartnerAuthrzns");
	
	//CSYS-100546 (OK. 3-3-2021) check is that cip Travel Authorized or not
	if (partnerTypeCIP == "true" AND (findinarray(partnerAuthrznsArr, "Travel Professional") <> -1 OR findinarray(partnerAuthrznsArr, "Travel Standard") <> -1)) {		
		cipTravelAuthorized = "true";
	}
	
	//CSYS-104401 (OK. 10-11-2021) check is that cip WalkMe Authorized or not
	if (partnerTypeCIP == "true" AND (findinarray(partnerAuthrznsArr, "User Assistant by WalkMe") <> -1)) {		
		walkMeAuthorized = "true";
	}
	
	//if (servicePartnerSpecialty == "" AND servPartnerAuthrzns == ""){ //CSYS-100546 (OK. 3-3-2021) Remove the servicePartnerSpecialty field from cip logic
	if (servPartnerAuthrzns == ""){
		put(cipPiDict, cipPi, "true");
		put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
	}
	else{
		//CSYS-96006
		//if ( find(partnerSpecialty, servicePartnerSpecialty) <> -1 OR find(partnerAuthrzns, servPartnerAuthrzns) <> -1 ){ //CSYS-100546 (OK. 3-3-2021) Remove the servicePartnerSpecialty field from cip logic
		//CSYS-104401 (OK. 10-11-2021) Add WalkMe logic in below condition
		if (find(partnerAuthrzns, servPartnerAuthrzns) <> -1 OR (cipTravelAuthorized == "true" AND (find(servPartnerAuthrzns, "~Travel Professional~") <> -1 OR find(servPartnerAuthrzns, "~Travel Standard~") <> -1)) OR (walkMeAuthorized == "true" AND (find(servPartnerAuthrzns, "~User Assistant by WalkMe~") <> -1))){
			//CSYS-96739 If there dictionary key is not yet populated, continue
			if(NOT(containskey(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore"))){
				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
			}
			//CSYS-96739 If there is already a key in the dictionary, update the key to include Invoice
			else {
			
				if (cipCore == "~Invoice Processing~") { //CSYS-100546 (OK. 3-3-2021) Adding condition for invoice core because we need else condition to support the other core values
					invoiceCore = split(cipCore, TILDE_DELIMITER);
					firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
					firstCipCore = firstCipCore + invoiceCore[1];
				}
				else { //CSYS-100546 (OK. 3-3-2021)
					coreArr = split(cipCore, TILDE_DELIMITER);
					firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
					arraySize = sizeofarray(coreArr);
					if (arraySize > 0) {
						for rec in coreArr{
							index = findinarray(coreArr, rec);
							if (coreArr[index] <> coreArr[0] AND coreArr[index] <> coreArr[arraySize - 1]) {
								append (coreValueArray, rec);
							}														
						}
						cipCoreString = join(coreValueArray, "~");
						firstCipCore = firstCipCore + cipCoreString;					
					}
				}

				put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", firstCipCore + TILDE_DELIMITER);
			}

			put(cipPiDict, cipPi, "true");
		}
	}
}
return cipPiDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>1715682885</id><bm_lib_func_id>1715678883</bm_lib_func_id><param_name><![CDATA[partnerSpecialty]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1680773585000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPPartsforJapan.bm_lib_func_param_partnerSpecialty_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1715682886</id><bm_lib_func_id>1715678883</bm_lib_func_id><param_name><![CDATA[partnerAuthrzns]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1680773585000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPPartsforJapan.bm_lib_func_param_partnerAuthrzns_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1715682887</id><bm_lib_func_id>1715678883</bm_lib_func_id><param_name><![CDATA[partNumArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1680773585000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPPartsforJapan.bm_lib_func_param_partNumArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1715682888</id><bm_lib_func_id>1715678883</bm_lib_func_id><param_name><![CDATA[attributesDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>34</datatype><date_modified>1680773585000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_setPropertiesForCIPPartsforJapan.bm_lib_func_param_attributesDict_34]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>405584588</id><name><![CDATA[Reconcile Current Date]]></name><variable_name><![CDATA[reconcileCurrentDate]]></variable_name><description><![CDATA[Reconciles the current date with timezone parameter. Returns a string dictionary with the following components: current date, current day, current month, current year.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>405584587</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_reconcileCurrentDate]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>405584587</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_reconcileCurrentDate_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435944000</date_modified><guid><![CDATA[70c2850e-c4c0-483b-8875-8e35a32ed3ff]]></guid><script_size>720</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// UTIL reconcileCurrentDate:
// Return a string dictionary with following string components: current date, current day, current month, current year.
// These components will take into account the user timezone.

resultDict = dict("string");

DATE_FORMAT_PREFERENCE_HYPHEN = "yyyy-MM-dd";
DATE_FORMAT_PREFERENCE_SLASH = "MM/dd/yyyy";
CURRENT_DATE = getdate();
CURRENT_DATESTR = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_SLASH, timezone), 0, 10);
CURRENT_MONTH_TZ = "";
CURRENT_DAY_TZ = "";
CURRENT_YEAR_TZ = "";
CURRENT_DATESTR_TZ = "";



//Commenting out timezone check until platform bug is fixed by Oracle. 
//For Now, current date will be based on server time
//if(timezone <> ""){	
	if(find(CURRENT_DATESTR, "/") <> -1) {
		CURRENT_DATE = strtojavadate(CURRENT_DATESTR, DATE_FORMAT_PREFERENCE_SLASH, timezone);
		CURRENT_MONTH_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_SLASH, timezone), 0, 2);
		CURRENT_DAY_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_SLASH, timezone), 3, 5);
		CURRENT_YEAR_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_SLASH, timezone), 6, 10);
		CURRENT_DATESTR_TZ = datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_SLASH, timezone);
	} else {
		CURRENT_DATE = strtojavadate(CURRENT_DATESTR, DATE_FORMAT_PREFERENCE_HYPHEN, timezone);
		CURRENT_MONTH_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_HYPHEN, timezone), 5, 7);
		CURRENT_DAY_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_HYPHEN, timezone), 8, 10);
		CURRENT_YEAR_TZ = substring(datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_HYPHEN, timezone), 0, 4);
		CURRENT_DATESTR_TZ = datetostr(CURRENT_DATE, DATE_FORMAT_PREFERENCE_HYPHEN, timezone);
	}
/*}
else{
	if(find(CURRENT_DATESTR, "/") <> -1) {
		CURRENT_DATE = strtojavadate(CURRENT_DATESTR, DATE_FORMAT_PREFERENCE_SLASH);
		CURRENT_MONTH_TZ = substring(datetostr(CURRENT_DATE), 0, 2);
		CURRENT_DAY_TZ = substring(datetostr(CURRENT_DATE), 3, 5);
		CURRENT_YEAR_TZ = substring(datetostr(CURRENT_DATE), 6, 10);
		CURRENT_DATESTR_TZ = datetostr(CURRENT_DATE);
	} else {
		CURRENT_DATE = strtojavadate(CURRENT_DATESTR, DATE_FORMAT_PREFERENCE_HYPHEN);
		CURRENT_MONTH_TZ = substring(datetostr(CURRENT_DATE), 5, 7);
		CURRENT_DAY_TZ = substring(datetostr(CURRENT_DATE), 8, 10);
		CURRENT_YEAR_TZ = substring(datetostr(CURRENT_DATE), 0, 4);
		CURRENT_DATESTR_TZ = datetostr(CURRENT_DATE);
	}
}*/

put(resultDict, "CURRENT_MONTH_TZ", CURRENT_MONTH_TZ);
put(resultDict, "CURRENT_DAY_TZ", CURRENT_DAY_TZ);
put(resultDict, "CURRENT_YEAR_TZ", CURRENT_YEAR_TZ);
put(resultDict, "CURRENT_DATESTR_TZ", CURRENT_DATESTR_TZ);



return resultDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>405584589</id><bm_lib_func_id>405584588</bm_lib_func_id><param_name><![CDATA[timezone]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_reconcileCurrentDate.bm_lib_func_param_timezone_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>446079863</id><name><![CDATA[Get Ramp Discounts]]></name><variable_name><![CDATA[getRampDiscounts]]></variable_name><description><![CDATA[CSYS-87914 (KA. 12-5-2017): get ramp discounts.]]></description><return_type>18</return_type><func_type>1</func_type><function_id>446079862</function_id><date_modified>1592439028000</date_modified><guid><![CDATA[bm_lib_func_util_getRampDiscounts]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>446079862</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getRampDiscounts_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435943000</date_modified><guid><![CDATA[2736bc33-f0eb-4387-b9e8-5c15bde4652c]]></guid><script_size>1740</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-87914 (KA. 12-5-2017)
//This util returns Ramp Discount info in a Dictionary of string arrays

/*Parameters: 
	lineItemRampPlan (rampPlanDetails_line)
*/

returnDict = dict("string[]");

//Grab the ramp price values from the XML:
rampBaseFeeListArray = util.getXMLNodeValues(lineItemRampPlan, "baseFeeList");
rampBaseFeeNetArray = util.getXMLNodeValues(lineItemRampPlan, "baseFeeNet");
rampIncFeeListArray = util.getXMLNodeValues(lineItemRampPlan, "increFeeList");
rampIncFeeNetArray = util.getXMLNodeValues(lineItemRampPlan, "increFeeNet");

//Arrays to store ramp discounts:
baseFeeRampDiscountArray = string[];
incFeeRampDiscountArray = string[];

cnt = 0;
for val in rampBaseFeeListArray{
	rampBaseFeeList = val;
	if(find(val, " ") <> -1){//SEK Currency fix
		rampBaseFeeList = replace(rampBaseFeeList, " ", "");
	}
	if(find(val, "'") <> -1){//CHF Currency fix
		rampBaseFeeList = replace(rampBaseFeeList, "'", "");
	}

	rampBaseFeeList = replace(rampBaseFeeList, ",", ""); //remove commas so rampBaseFeeList is an actual number in BML

	rampBaseFeeNet = rampBaseFeeNetArray[cnt];
	if(find(rampBaseFeeNetArray[cnt], " ") <> -1){
		rampBaseFeeNet = replace(rampBaseFeeNet, " ", "");
	}
	if(find(rampBaseFeeNetArray[cnt], "'") <> -1){
		rampBaseFeeNet = replace(rampBaseFeeNet, "'", "");
	}

	rampBaseFeeNet = replace(rampBaseFeeNet, ",", ""); //remove commas so rampBaseFeeNet is an actual number in BML
	
	rampBaseFeeDiscount = 0.0;

	
	if(isnumber(rampBaseFeeList) AND isnumber(rampBaseFeeNet) AND atof(rampBaseFeeList) > 0.0 /*AND atof(rampBaseFeeNet) > 0.0*/){
		//CSYS-95876
		//if(atof(rampBaseFeeNet) > 0.0){//CSYS-88429 (LN. 1/11/2018) Moved this piece of logic into it's own if statement so that in the event that a user enters a 0.0 BaseFeeNet the final ramp will still be appended and display in the UI

			//Calculate base ramp discounts:
			rampBaseFeeDiscount = round((1 - (atof(rampBaseFeeNet)/atof(rampBaseFeeList))) * 100, 2);
			rampBaseFeeDiscountStr = string(rampBaseFeeDiscount);

			discSplit = split(rampBaseFeeDiscountStr, ".");
			if(len(discSplit[1]) == 1){
				//add a zero if necessary:
				rampBaseFeeDiscountStr = rampBaseFeeDiscountStr + "0";
			}

			append(baseFeeRampDiscountArray, rampBaseFeeDiscountStr);
			
		//}
		/*
		else {//CSYS-88429 (LN. 1/11/2018)
			append(baseFeeRampDiscountArray, "0.00");
		}*/
		
	}
	
	cnt = cnt + 1;
}

cnt = 0; //reset the counter
for val in rampIncFeeListArray{
	rampIncFeeList = val;
	if(find(rampIncFeeList, " ") <> -1){
		rampIncFeeList = replace(rampIncFeeList, " ", "");
	}
	if(find(rampIncFeeList, "'") <> -1){//CHF Currency fix
		rampIncFeeList = replace(rampIncFeeList, "'", "");
	}

	rampIncFeeList = replace(val, ",", ""); //remove commas so rampIncFeeList is an actual number in BML

	rampIncFeeNet = rampIncFeeNetArray[cnt];
	if(find(rampIncFeeNet, " ") <> -1){
		rampIncFeeNet = replace(rampIncFeeNet, " ", "");
	}
	if(find(rampIncFeeNet, "'") <> -1){
		rampIncFeeNet = replace(rampIncFeeNet, "'", "");
	}

	rampIncFeeNet = replace(rampIncFeeNet, ",", ""); //remove commas so rampIncFeeNet is an actual number in BML
	rampIncFeeDiscount = 0.0;

	if(isnumber(rampIncFeeList) AND isnumber(rampIncFeeNet) /*AND atof(rampIncFeeList) > 0.0 /*AND atof(rampIncFeeNet) > 0.0*/){
		//CSYS-95876
		//if(atof(rampIncFeeNet) > 0.0){//CSYS-88429 (LN. 1/11/2018) Moved this piece of logic into it's own if statement so that in the event that a user enters a 0.0 IncFeeNet the final ramp will still be appended and display in the UI

			//(CSYS-97399 KW. 8/14/19 - Adjusting ramp incremental discount if number equals 0)
			if(atof(rampIncFeeList) > 0.0 ){


				//Calculate incremental ramp discounts:
				rampIncFeeDiscount = round((1 - (atof(rampIncFeeNet)/atof(rampIncFeeList))) * 100, 2);
				rampIncFeeDiscountStr = string(rampIncFeeDiscount);

				discSplit = split(rampIncFeeDiscountStr, ".");
				if(len(discSplit[1]) == 1){
					//add a zero if necessary:
					rampIncFeeDiscountStr = rampIncFeeDiscountStr + "0";
				}

				append(incFeeRampDiscountArray, rampIncFeeDiscountStr);

		        }
		        
		        if(atof(rampIncFeeList) == 0.0 ){
			        rampIncFeeDiscountStr = string(rampIncFeeDiscount);

			        discSplit = split(rampIncFeeDiscountStr, ".");
			        if(len(discSplit[1]) == 1){
				//add a zero if necessary:
				rampIncFeeDiscountStr = rampIncFeeDiscountStr + "0";
			        }
			
			        //append(incFeeRampDiscountArray, "0.00");
			        append(incFeeRampDiscountArray,rampIncFeeDiscountStr);

		        }

	}

	cnt = cnt + 1;
}

//Populate the return dictionary:
put(returnDict, "rampBaseFeeListArray", rampBaseFeeListArray);
put(returnDict, "rampBaseFeeNetArray", rampBaseFeeNetArray);
put(returnDict, "rampIncFeeListArray", rampIncFeeListArray);
put(returnDict, "rampIncFeeNetArray", rampIncFeeNetArray);
put(returnDict, "baseFeeRampDiscountArray", baseFeeRampDiscountArray);
put(returnDict, "incFeeRampDiscountArray", incFeeRampDiscountArray);

return returnDict;]]></script_text><_children><bm_lib_func_assoc><id>446079865</id><caller_func_id>446079862</caller_func_id><called_lib_func_id>4978288</called_lib_func_id><rule_area><![CDATA[Get Ramp Discounts]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1592439028000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[1abd2281-e1fd-4c8e-81b4-2fe0b47d953d]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>446079866</id><bm_lib_func_id>446079863</bm_lib_func_id><param_name><![CDATA[lineItemRampPlan]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1592439028000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getRampDiscounts.bm_lib_func_param_lineItemRampPlan_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>49826842</id><name><![CDATA[Get Default Values Based on BU, Implementation and Market]]></name><variable_name><![CDATA[getDefaultValuesBasedOnBUImplementationAndMarket]]></variable_name><description><![CDATA[The Library accepts ownerBU, Owner Theater, Owner Market, Implementation and Attribute Name as inputs and gives the default value for the attribute name.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>49826841</function_id><date_modified>1626951330000</date_modified><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>49826841</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getDefaultValuesBasedOnBUImplementationAndMarket_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626951331000</date_modified><guid><![CDATA[7e6d8880-72bf-4317-9450-bed072ae7904]]></guid><script_size>551</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getDefaultValuesBasedOnBUImplementationAndMarket
businessUnit (ownerBU)- String
ownerTheater- String
market (ownerMarket)- String
attributeName - String
Implementation - String
ownerDivion - String //CSYS-98001 SN. 01/2020 Add ownerDiviosn condition
*/
retStr = "";                                //Initialize Return String
imp = "";
results =  recordset();
//Query the table using the filter for BU,Implementation Market and Attr Name

if(Implementation == "Concurforce"){
        results = bmql("select DefaultValue from DefaultUsgBUAndMKT where Implementation = 'Concurforce'  and BusinessUnit like $businessUnit and ownerTheater like $ownerTheater and Market like $market and AttributeName like $attributeName");
} elif (Market == ""){
        results = bmql("select DefaultValue from DefaultUsgBUAndMKT where (Market = '' or Market is null)  and BusinessUnit like $businessUnit and ownerTheater like $ownerTheater and AttributeName like $attributeName");
} elif (ownerDivision == "Germany National" OR ownerDivision == "Germany Mid Market"){ //CSYS-98001 SN. 01/2020 
        results = bmql("select DefaultValue from DefaultUsgBUAndMKT where BusinessUnit like $businessUnit and ownerTheater like $ownerTheater and Market like $market and AttributeName like $attributeName and ownerDivision like $ownerDivision");

} else {//CSYS-98001 SN. 01/2020 Add ownerDiviosn condition
        results = bmql("select DefaultValue from DefaultUsgBUAndMKT where (Implementation = '' or Implementation is null) and (ownerDivision = '' or ownerDivision is null) and BusinessUnit like $businessUnit and ownerTheater like $ownerTheater and Market like $market and AttributeName like $attributeName ");
}

for result in results {
        retStr = get(result, "DefaultValue");        // Get the result
}
return retStr;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>49826843</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[businessUnit]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_businessUnit_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49826844</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[ownerTheater]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_ownerTheater_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49826845</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[market]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_market_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49826846</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_attributeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>49826847</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[Implementation]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_Implementation_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>858489140</id><bm_lib_func_id>49826842</bm_lib_func_id><param_name><![CDATA[ownerDivision]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626951330000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getDefaultValuesBasedOnBUImplementationAndMarket.bm_lib_func_param_ownerDivision_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4913065</id><name><![CDATA[makeReturnString]]></name><variable_name><![CDATA[makeReturnString]]></variable_name><description><![CDATA[Assembles a docNum, attributeName and value into the proper return format for Commerce modification scripts.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4913064</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_makeReturnString]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4913064</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_makeReturnString_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435918000</date_modified><guid><![CDATA[LEGACY_4913064]]></guid><script_size>123</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> makeReturnString

docNum - String
attributeName - String
value - String
*/
DELIM = "~";
ITEM_DELIM = "|";

return docNum + DELIM + attributeName + DELIM + value + ITEM_DELIM;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4913067</id><bm_lib_func_id>4913065</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_makeReturnString.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913068</id><bm_lib_func_id>4913065</bm_lib_func_id><param_name><![CDATA[attributeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_makeReturnString.bm_lib_func_param_attributeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913069</id><bm_lib_func_id>4913065</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_makeReturnString.bm_lib_func_param_value_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4913582</id><name><![CDATA[getMultiplier]]></name><variable_name><![CDATA[getMultiplier]]></variable_name><description><![CDATA[Returns the value of the correct multiplier for the given line item.]]></description><return_type>3</return_type><func_type>1</func_type><function_id>4913581</function_id><date_modified>1626948717000</date_modified><guid><![CDATA[bm_lib_func_util_getMultiplier]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4913581</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getMultiplier_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948717000</date_modified><guid><![CDATA[LEGACY_4913581]]></guid><script_size>589</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getMultiplier

docNum - String
piDelimiter - String
stringsDict - String Dictionary
integersDict - Integer Dictionary
floatsDict - Float Dictionary
*/
//Constants
PI = "_part_number";
UOM_TYPE = "uomType_line";
UOM_QTY = "QTY";
QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
UNIT_OR_FIXED = "unitOrFixed_line";
UNIT = "UNIT";
FIXED = "FIXED";
debug = false;
//Get the PI of this line item
piKey = docNum + piDelimiter + PI;
pi = "";
if (containskey(stringsDict, piKey)) {
	pi = get(stringsDict, piKey);
}

//Get the UOM Type of this line item
uomTypeKey = pi + piDelimiter + UOM_TYPE;
uomType = "";
if (containskey(stringsDict, uomTypeKey)) {
	uomType = get(stringsDict, uomTypeKey);
}

//Get the Unit/Fixed field of this line item
unitOrFixedKey = pi + piDelimiter + UNIT_OR_FIXED;
unitOrFixed = "";
if (containskey(stringsDict, unitOrFixedKey)) {
	unitOrFixed = get(stringsDict, unitOrFixedKey);
}

//Get the value of either the Qty or Transactions, depending on what the UOM Type is
multiplierKey = docNum + piDelimiter;
multiplier = 0;
if(unitOrFixed == UNIT) {
	if (uomType == UOM_QTY) {
		multiplierKey = multiplierKey + QTY;
	} else {
		multiplierKey = multiplierKey + TRANSACTIONS;
	}
	if (containskey(integersDict, multiplierKey)) {
		multiplier = get(integersDict, multiplierKey);
	}
} else {
	multiplier = 1;
}


return multiplier;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4913584</id><bm_lib_func_id>4913582</bm_lib_func_id><param_name><![CDATA[docNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948717000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getMultiplier.bm_lib_func_param_docNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913585</id><bm_lib_func_id>4913582</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948717000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getMultiplier.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913586</id><bm_lib_func_id>4913582</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948717000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getMultiplier.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913587</id><bm_lib_func_id>4913582</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1626948717000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getMultiplier.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4913588</id><bm_lib_func_id>4913582</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1626948717000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getMultiplier.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>944268461</id><name><![CDATA[SYSTEM TEST]]></name><variable_name><![CDATA[sYSTEMTEST]]></variable_name><description><![CDATA[This is to systematically test various parts of the system.  This should be performed generally when updates are made and when errors occur to grade the system health in specific areas.  Documentation can be found at "TBD".]]></description><return_type>1</return_type><func_type>1</func_type><function_id>944268459</function_id><date_modified>1601392586000</date_modified><guid><![CDATA[bm_lib_func_util_sYSTEMTEST]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>944268459</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_sYSTEMTEST_1]]></java_class_name><child_class_names></child_class_names><date_modified>1601392586000</date_modified><guid><![CDATA[dbd2ca99-2c2e-4b75-a646-cb92608c7993]]></guid><script_size>1717</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// THIS SCRIPT IS TO TEST VARIOUS PARTS OF THE SYSTEM
sStartTime = getcurrenttimeinmillis();
sResults = "No Errors or Warnings"; //overall message provided at end of script
iCount = 1; //counter set to 0
sTestingLabel = ""; //what is being tested
sTestingType = ""; //what type of testing is being performed
bSectionError = false; //error flag set and flipped for each section to realize issues
bOverallError = false; //error flag set and displayed for the overall testing
sSpacer = "\n////////// ////////// ////////// ////////// ////////// ////////// ////////// \n";
print "---   Testing Started";

/// //////////////////////////////////////
/// Testing PromoCodeDetails table - START
print sSpacer;
sTestingLabel = "PromoCodeDetails"; //set testing current testing label
sTestingType = "data table"; //set testing current testing type
print "---   Testing  '" + sTestingLabel + "'  " + sTestingType;
records = BMQL("SELECT startDate,endDate FROM $sTestingLabel ");
iCount = 1; //counter reset to 0
bSectionError = false; //resetting section error flag;
for rec in records // loop through selected records
{
	//Testing the date format for the columns startDate and endDate to make sure they follow YYYY-MM-DD format
	sStartDate = get(rec,"startDate");
	sEndDate = get(rec,"endDate");
	if(// check for startDate errors
		isnumber(substring(sStartDate,0,4)) == false
		OR len(substring(sStartDate,0,4)) <> 4
		OR substring(sStartDate,4,5) <> "-"
		OR isnumber(substring(sStartDate,5,7)) == false
		OR len(substring(sStartDate,5,7)) <> 2
		OR substring(sStartDate,7,8) <> "-"
		OR isnumber(substring(sStartDate,8,10)) == false
		OR len(substring(sStartDate,8,10)) <> 2
	)
	{// error found in startDate
		print "       Row " + string(iCount) + " and column 'startDate' does not follow the 'YYYY-MM-DD' date format:" + get(rec,"startDate");
		bSectionError = true;
	}
	if(// check for endDate errors
		isnumber(substring(sEndDate ,0,4)) == false
		OR len(substring(sEndDate ,0,4)) <> 4
		OR substring(sEndDate ,4,5) <> "-"
		OR isnumber(substring(sEndDate ,5,7)) == false
		OR len(substring(sEndDate ,5,7)) <> 2
		OR substring(sEndDate ,7,8) <> "-"
		OR isnumber(substring(sEndDate ,8,10)) == false
		OR len(substring(sEndDate ,8,10)) <> 2
	)
	{// error found in endDate
		print "       Row " + string(iCount) + " and column 'endDate' does not follow the 'YYYY-MM-DD' date format:" + get(rec,"endDate");
		bSectionError = true;
	}
	iCount = iCount + 1; // increase counter by 1
	//if(iCount > 20000)
	//{
		//break;
	//}
}
if(bSectionError)
{// section error found
	print "!!!   Errors in  '" + sTestingLabel + "'  " + sTestingType;
	bOverallError = true;
}
else
{// no section error found
	print ":-)  no errors in  '" + sTestingLabel + "'  " + sTestingType;
}
bSectionError = false; //reset the section error flag
/// Testing PromoCodeDetails table - END
/// ////////////////////////////////////
print sSpacer;
/// ////////////////////////////////////
/// Testing SITE HOST NAME - START
sSiteName = split("TestConcur,Test2concur,Concur",",");// site names
print sSpacer;
for sEachSite in sSiteName 
{
	if(sEachSite == _company_name)
	{
		print _company_name + " Site matches   " + sEachSite;
		break;
	}
	elif(upper(sEachSite) == upper(_company_name))
	{
		print _company_name + " Site matches   UPPER CASE VERSION of " + sEachSite;
		print "Site Host Name should be " + sEachSite;
		bOverallError = true;
		break;
	}
	elif(lower(sEachSite) == lower(_company_name))
	{
		print "!!! " + _company_name + " Site matches   LOWER CASE VERSION of " + sEachSite;
		print "!!! Site Host Name should be " + sEachSite;
		bOverallError = true;
		break;
	}
}
/// Testing SITE HOST NAME - END
/// ////////////////////////////////////
print sSpacer;
if(bOverallError)
{// overall error found
	print "!!!   Errors found...review the console";
}
else
{// no orverall error found
	print ":-)  no errors found in current tests";
}
print sSpacer;
print "Elapsed Time = " + string((getcurrenttimeinmillis() - sStartTime)/1000) + " seconds";
return sResults;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>1001932464</id><bm_lib_func_id>944268461</bm_lib_func_id><param_name><![CDATA[_company_name]]></param_name><ref_id>1</ref_id><param_location>1</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1601392586000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_sYSTEMTEST.bm_lib_func_param__company_name_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>309876638</id><name><![CDATA[Sort Model to Line Dictionaries]]></name><variable_name><![CDATA[sortModelToLineDictionaries]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>309876637</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_sortModelToLineDictionaries]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>309876637</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_sortModelToLineDictionaries_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435939000</date_modified><guid><![CDATA[1abef207-2981-4e85-8c93-4147d7589f6a]]></guid><script_size>788</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//This util was added for CSYS-75571 (KA. 1-19-2017):
//It preps 2 new dictionaries to make sure line items are in order for the modelToLineDocNumsDict and the modelToLinePartNumsDict.
DELIMITER = "@.@";
result = "";

if(NOT isempty(seqNumArray)){
	for key in seqNumArray {
		seqNumberCustom = string(key);

		docNum = "";
		parentDocNum = "";

		if(containskey(seqNumAttributeMappingDict, seqNumberCustom + DELIMITER + "DOC_NUM")){
			docNum = get(seqNumAttributeMappingDict, seqNumberCustom + DELIMITER + "DOC_NUM");
		}
		if(containskey(seqNumAttributeMappingDict, seqNumberCustom + DELIMITER + "PARENT_DOC_NUM")){
			parentDocNum = get(seqNumAttributeMappingDict, seqNumberCustom + DELIMITER + "PARENT_DOC_NUM");
		}
		
		//The following block of logic has been moved from the pricing function:
		if (parentDocNum <> "" AND docNum <> "") {
			//Populate the modelToLineDocNumsDictCustom
			lineDocNumsCustom = string[];
			if (containskey(modelToLineDocNumsDictCustom, parentDocNum)) {
				lineDocNumsCustom = get(modelToLineDocNumsDictCustom, parentDocNum);
			} 

			append(lineDocNumsCustom, docNum);
			put(modelToLineDocNumsDictCustom, parentDocNum, lineDocNumsCustom);
			//Populate the modelToLinePartNumsDictCustom
			linePartNumsCustom = string[];
			
			if (containskey(modelToLinePartNumsDictCustom, parentDocNum)) {
				linePartNumsCustom = get(modelToLinePartNumsDictCustom, parentDocNum);
			} 
			append(linePartNumsCustom, docNum);
			put(modelToLinePartNumsDictCustom, parentDocNum, linePartNumsCustom);

			result = "EXECUTED";
		}
	}
}

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>309876639</id><bm_lib_func_id>309876638</bm_lib_func_id><param_name><![CDATA[modelToLineDocNumsDictCustom]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547407000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_sortModelToLineDictionaries.bm_lib_func_param_modelToLineDocNumsDictCustom_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>309876640</id><bm_lib_func_id>309876638</bm_lib_func_id><param_name><![CDATA[modelToLinePartNumsDictCustom]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547407000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_sortModelToLineDictionaries.bm_lib_func_param_modelToLinePartNumsDictCustom_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>309876641</id><bm_lib_func_id>309876638</bm_lib_func_id><param_name><![CDATA[seqNumArray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>7</datatype><date_modified>1508547407000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_sortModelToLineDictionaries.bm_lib_func_param_seqNumArray_7]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>309876642</id><bm_lib_func_id>309876638</bm_lib_func_id><param_name><![CDATA[seqNumAttributeMappingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547407000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_sortModelToLineDictionaries.bm_lib_func_param_seqNumAttributeMappingDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>10017663</id><name><![CDATA[Sort Line Items]]></name><variable_name><![CDATA[sortLineItems]]></variable_name><description></description><return_type>10</return_type><func_type>1</func_type><function_id>10017662</function_id><date_modified>1626948720000</date_modified><guid><![CDATA[bm_lib_func_util_sortLineItems]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>10017662</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_sortLineItems_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948720000</date_modified><guid><![CDATA[concur_10017662]]></guid><script_size>2062</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> sortLineItems
stringsDict
integersDict
floatsDict
docNums

Returns the new state of the doc num array
*/
DELIMITER = "@.@";
SEQUENCE_NUMBER = "_sequence_number";
PARENT_DOC_NUM = "_parent_doc_number";
PART_NUMBER = "_part_number";
PART_ORDER_STRING = "poPriority_concur";

retDocNums = string[];
sortedDocNums = string[];
seqToDocDict = dict("string");
// Create new doc num array, we will be sorting this
sizeOfDocsIndex = 1;
sizeOfDocsArr = Integer[];

for docNum in docNums{
	append( sizeOfDocsArr, sizeOfDocsIndex );
	sizeOfDocsIndex = sizeOfDocsIndex + 1;
	// Get Seq Num
	seqNum = get( integersDict, docNum + DELIMITER + SEQUENCE_NUMBER );

	put( seqToDocDict, seqNum, docNum );
}


// Generate two docs arrs.  One is for returnining, one is for looping over
// Order by sequence number
for docs in sizeOfDocsArr{
	docNum = get( seqToDocDict, docs );	
	append( retDocNums, docNum );
	append( sortedDocNums, docNum );
}
// Loop through all models
for eachModel in sortedDocNums{
	partsOrderString = "";

	existingPartsArr = string[];
	// Get the parent doc num
	parentDocNum = get( stringsDict, eachModel + DELIMITER + PARENT_DOC_NUM );
	if ( containskey( stringsDict, eachModel + DELIMITER + PARENT_DOC_NUM ) == true AND parentDocNum <> "" ){
		continue;
	}
	// Get line item order from the dictionary
	if( containskey ( stringsDict, eachModel + DELIMITER + PART_ORDER_STRING )){
		partsOrderString = get( stringsDict, eachModel + DELIMITER + PART_ORDER_STRING );
	}
	else{
		continue;
	}
	sequenceNumber = get( integersDict, eachModel + DELIMITER + SEQUENCE_NUMBER );
	// Account for the first line item in the sequence
	sequenceNumber = sequenceNumber + 1;
	if(endswith(partsOrderString, "***")) {
		partsOrderString = substring(partsOrderString, 0, len(partsOrderString) - 3); 
	}


	partsOrderArr = split( partsOrderString, "***" );
	// Clean up partsOrderArr which may contain other PIs which don't exist in the quote
	for eachLine in sortedDocNums {
		partNumber = get( stringsDict, eachLine + DELIMITER + PART_NUMBER );
		if(partNumber <> "") {
			append(existingPartsArr, partNumber);
		}
	}



	toRemove = integer[];
	//Need this because as you loop through a remove you must account that the first thing removed will be 
	//replaced by the next item in the array. 
	correctIndexAfterRemove = sizeofarray(toRemove);
	for eachPart in partsOrderArr {
		if(eachPart <> "" AND findinarray(existingPartsArr, eachPart) == -1) {
			append(toRemove, findinarray(partsOrderArr, eachPart) - correctIndexAfterRemove);
		}
		correctIndexAfterRemove = sizeofarray(toRemove);
	}
	

	for index in toRemove {
		remove(partsOrderArr, index);
	}

	
	for eachLine in sortedDocNums{
		lineParentDocNum = get( stringsDict, eachLine + DELIMITER + PARENT_DOC_NUM );
		if ( lineParentDocNum <> eachModel ){
			continue;
		}
		// Get part number
		partNumber = get( stringsDict, eachLine + DELIMITER + PART_NUMBER );
		currentSequenceNumber = get( integersDict, eachLine + DELIMITER + SEQUENCE_NUMBER );
		// Get index from array
		partIndex = findinarray ( partsOrderArr, partNumber );
		if ( partIndex == -1 ){
			continue;
		}
		newSequenceNumber = sequenceNumber + partIndex;
		// Save as sequence number + base
		put( integersDict, eachLine + DELIMITER + SEQUENCE_NUMBER, newSequenceNumber );
		sequenceDif = newSequenceNumber - currentSequenceNumber;
		
		// Overwrite doc number in doc array
		index = findinarray ( retDocNums, eachLine );
		replacedDocNum = "";
		saveDocIndex = index + sequenceDif;
		replacedDocNum = retDocNums[saveDocIndex];
		if(sizeofarray(retDocNums) > saveDocIndex) {
		  retDocNums[saveDocIndex] = eachLine;
		}
		if(NOT(isnull(replacedDocNum))) {
			retDocNums[index] = replacedDocNum;
		}
		put( integersDict, replacedDocNum + DELIMITER + SEQUENCE_NUMBER, currentSequenceNumber );
	}	
}	

// Set doc number array as the overwritten array
return retDocNums;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>10017665</id><bm_lib_func_id>10017663</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948720000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_sortLineItems.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10017666</id><bm_lib_func_id>10017663</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1626948720000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_sortLineItems.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10017667</id><bm_lib_func_id>10017663</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1626948720000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_sortLineItems.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>10017668</id><bm_lib_func_id>10017663</bm_lib_func_id><param_name><![CDATA[docNums]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948720000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_sortLineItems.bm_lib_func_param_docNums_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722759</id><name><![CDATA[Get Intell Constrain Attr]]></name><variable_name><![CDATA[getIntellConstrainAttr]]></variable_name><description><![CDATA[NO LONGER USED in determining if there is an Intelligence constraint scenario with 2 or more cores.]]></description><return_type>4</return_type><func_type>1</func_type><function_id>15722758</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getIntellConstrainAttr]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722758</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getIntellConstrainAttr_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435933000</date_modified><guid><![CDATA[testconcur_13145159]]></guid><script_size>715</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[// CSYS-61858: No longer used
/************** check if intell constrain is required *************
** step 1: locate the models containing BI components
** step 2: check if any model contains a Core With intelligence.
** step 3: if so, for each model see if it contains both a core without intelligence AND a corresponding intelligence part
** Adi Smulian, 26/6/12
******************************************************************/

debugIntel = false;
intelligenceConstaintArrtibute = false;

listOfMissingModels = string[];
listOfModelsContainigBI = string[];

//step 1:
configTrigger = false;
step3 = false;
for parentDN in parentDNarray{
	if(containskey(modelContainsBI,parentDN)){
		currentPOlist = get(poList,parentDN);
		for entry in currentPOlist{
			append(listOfModelsContainigBI,entry);
			configTrigger = true;
			step3 = true;
		}
	}
}
//step 3:
		found = false;
if(step3){
	for parentDN in parentDNarray{
		currentPOlist = get(poList,parentDN);
		//rez = BMQL("SELECT RelatedIntelPO FROM AddCoreWithIntell WHERE RelatedIntelPO IN $currentPOlist AND CoreWithoutIntelPO IN $currentPOlist");
		rez = BMQL("SELECT RelatedIntelPO,CoreWithoutIntelPO FROM AddCoreWithIntell WHERE CoreWithIntelPO IN $listOfModelsContainigBI AND CoreWithoutIntelPO IN $currentPOlist");
		for entry in rez{
			temp = get(entry,"RelatedIntelPO");
			if(temp<>""){//if any result found in the query
				if(findinarray(currentPOlist,temp)<>-1){//if this result contain the required intelligence part
					continue;//move on to the next model
				}else{//if a model did not have the relevant BI part:
					found = true;
					append(listOfMissingModels,parentDN);
				}
			}
		}
	}
}

if(found){//if former loop ended with a model found in it - mark intell flag as true and exit.
	intelligenceConstaintArrtibute = true;
	//break;
}

put(intellConstrainAttrDict, "configTrigger", configTrigger);
put(intellConstrainAttrDict, "intelligenceConstaintArrtibute", intelligenceConstaintArrtibute);

return true;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722760</id><bm_lib_func_id>15722759</bm_lib_func_id><param_name><![CDATA[parentDNarray]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547405000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getIntellConstrainAttr.bm_lib_func_param_parentDNarray_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722761</id><bm_lib_func_id>15722759</bm_lib_func_id><param_name><![CDATA[poList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547405000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getIntellConstrainAttr.bm_lib_func_param_poList_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722762</id><bm_lib_func_id>15722759</bm_lib_func_id><param_name><![CDATA[modelContainsBI]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547405000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getIntellConstrainAttr.bm_lib_func_param_modelContainsBI_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722763</id><bm_lib_func_id>15722759</bm_lib_func_id><param_name><![CDATA[intellConstrainAttrDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>22</datatype><date_modified>1508547405000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getIntellConstrainAttr.bm_lib_func_param_intellConstrainAttrDict_22]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4917922</id><name><![CDATA[printDebug]]></name><variable_name><![CDATA[printDebug]]></variable_name><description><![CDATA[Returns a TITLE and a VALUE in the format "TITLE: VALUE"]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4917921</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_printDebug]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4917921</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_printDebug_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435907000</date_modified><guid><![CDATA[LEGACY_4917921]]></guid><script_size>180</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> printDebug

title - String
value - String
tabs - Integer

*/
tabString = "";
tabList = range(tabs);
for t in tabList {
	tabString = tabString + "> > ";
}

result = tabString + title + ": " + value;

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4917924</id><bm_lib_func_id>4917922</bm_lib_func_id><param_name><![CDATA[title]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_printDebug.bm_lib_func_param_title_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4917925</id><bm_lib_func_id>4917922</bm_lib_func_id><param_name><![CDATA[value]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_printDebug.bm_lib_func_param_value_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4917926</id><bm_lib_func_id>4917922</bm_lib_func_id><param_name><![CDATA[tabs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1508547402000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_printDebug.bm_lib_func_param_tabs_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722755</id><name><![CDATA[Get Attr Value Dict For Line Item Ramp]]></name><variable_name><![CDATA[getAttrValueDictForLineItemRamp]]></variable_name><description><![CDATA[This util is called from Pricing and is one of the two utils used to build XML Ramp]]></description><return_type>15</return_type><func_type>1</func_type><function_id>15722754</function_id><date_modified>1596713541000</date_modified><guid><![CDATA[bm_lib_func_util_getAttrValueDictForLineItemRamp]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722754</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getAttrValueDictForLineItemRamp_1]]></java_class_name><child_class_names></child_class_names><date_modified>1596713663000</date_modified><guid><![CDATA[testconcur_12984910]]></guid><script_size>2788</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*Util - getAttrValueDictForLineItemRamp
No parameters passed to this util.
This is called from Pricing and is one of the 2 libraries used to build Ramp XML
*/

BASE_FEE_LIST_XML_USD = "baseFeeListUSD";
BASE_FEE_NET_XML_USD = "baseFeeNetUSD";
INC_FEE_LIST_XML_USD = "increFeeListUSD";
INC_FEE_NET_XML_USD = "increFeeNetUSD";
BASE_FEE_LIST_XML = "baseFeeList";
BASE_FEE_NET_XML = "baseFeeNet";
INC_FEE_LIST_XML = "increFeeList";
INC_FEE_NET_XML = "increFeeNet";
BASE_FEE_NET_NON_UNIFIED = "baseFeeNonUnifiedNet";
BASE_FEE_NET_NON_UNIFIED_USD = "baseFeeNonUnifiedNetUSD";
INC_FEE_NON_UNIFIED_NET = "increFeeNonUnifiedNet";
INC_FEE_NON_UNIFIED_NET_USD = "increFeeNonUnifiedNetUSD";
BASE_FEE_LIST_NON_UNIFIED_XML = "baseFeeListNonUnified";
BASE_FEE_LIST_NON_UNIFIED_USD_XML = "baseFeeListNonUnifiedUSD";
INC_FEE_LIST_NON_UNIFIED_XML = "incFeeListNonUnified";
INC_FEE_LIST_NON_UNIFIED_USD_XML = "incFeeListNonUnifiedUSD";


/* ****** FORMAT XML FOR PROPER DISPLAY BY JAVASCRIPT ****** */
//CSYS-99936 (NT. 01-08-2020) Added "transactionsBC", "baseIncKey"
elementArr = String[]{BASE_FEE_LIST_XML_USD, BASE_FEE_NET_XML_USD, INC_FEE_LIST_XML_USD, INC_FEE_NET_XML_USD,
						BASE_FEE_LIST_XML, BASE_FEE_NET_XML, INC_FEE_LIST_XML, INC_FEE_NET_XML,BASE_FEE_NET_NON_UNIFIED
							, BASE_FEE_NET_NON_UNIFIED_USD, INC_FEE_NON_UNIFIED_NET, INC_FEE_NON_UNIFIED_NET_USD,
							BASE_FEE_LIST_NON_UNIFIED_XML, BASE_FEE_LIST_NON_UNIFIED_USD_XML, INC_FEE_LIST_NON_UNIFIED_XML,
							INC_FEE_LIST_NON_UNIFIED_USD_XML, "baseFeeNetBC", "transactionsBC", "baseIncKey"};
attributeArr = String[]{ "displayArray", "displayName", "readOnly", "isCurrency" };
DELIMITER = "@.@";
rampFormatDelimiter = DELIMITER;
attributeValueDict = dict("string");

// Determine what XML nodes are displayed in javascript
put( attributeValueDict, BASE_FEE_LIST_XML_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, BASE_FEE_NET_XML_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_LIST_XML_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_NET_XML_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, BASE_FEE_LIST_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, BASE_FEE_NET_XML + rampFormatDelimiter + "displayArray", "inline" );
put( attributeValueDict, INC_FEE_LIST_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_NET_XML + rampFormatDelimiter + "displayArray", "inline" );
//CSYS-99936 (NT. 01-08-2020) - Make baseFeeNonUnifiedNet column visible in UI.
put( attributeValueDict, BASE_FEE_NET_NON_UNIFIED + rampFormatDelimiter + "displayArray", "inline" );
put( attributeValueDict, BASE_FEE_NET_NON_UNIFIED_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_NON_UNIFIED_NET + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_NON_UNIFIED_NET_USD + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, BASE_FEE_LIST_NON_UNIFIED_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, BASE_FEE_LIST_NON_UNIFIED_USD_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_LIST_NON_UNIFIED_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, INC_FEE_LIST_NON_UNIFIED_USD_XML + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, "baseFeeNetBC" + rampFormatDelimiter + "displayArray", "none" );
//CSYS-99936 (NT. 01-08-2020) Added "transactionsBC", "baseIncKey"
put( attributeValueDict, "transactionsBC" + rampFormatDelimiter + "displayArray", "none" );
put( attributeValueDict, "baseIncKey" + rampFormatDelimiter + "displayArray", "none" );
// Determine which fields should display as currency
put( attributeValueDict, BASE_FEE_NET_XML + rampFormatDelimiter + "isCurrency", "true" );
put( attributeValueDict, INC_FEE_NET_XML + rampFormatDelimiter + "isCurrency", "true" );
// Determine the display names of XML nodes
put(attributeValueDict, INC_FEE_LIST_XML + rampFormatDelimiter + "displayName", "Inc Fee List" );
put(attributeValueDict, BASE_FEE_LIST_XML + rampFormatDelimiter + "displayName", "Base Fee List" );
put(attributeValueDict, INC_FEE_NET_XML + rampFormatDelimiter + "displayName", "Inc Fee Net" );
put(attributeValueDict, BASE_FEE_NET_XML + rampFormatDelimiter + "displayName", "Base Fee Net" );
//CSYS-99936 (NT. 01-08-2020) Added
put(attributeValueDict, BASE_FEE_NET_NON_UNIFIED + rampFormatDelimiter + "displayName", "Base Fee NonUnified Net");

// Determine what nodes are read only
put( attributeValueDict, BASE_FEE_LIST_XML_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_NET_XML_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_LIST_XML_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_NET_XML_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_LIST_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_NET_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_LIST_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_NET_XML + rampFormatDelimiter + "readOnly", "true" );
//CSYS-99936 (NT. 01-08-2020) Added
put( attributeValueDict, BASE_FEE_NET_NON_UNIFIED + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_NET_NON_UNIFIED_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_NON_UNIFIED_NET + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_NON_UNIFIED_NET_USD + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_LIST_NON_UNIFIED_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, BASE_FEE_LIST_NON_UNIFIED_USD_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_LIST_NON_UNIFIED_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, INC_FEE_LIST_NON_UNIFIED_USD_XML + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, "baseFeeNetBC" + rampFormatDelimiter + "readOnly", "true" );
//CSYS-99936 (NT. 01-08-2020) Added "transactionsBC", "baseIncKey"
put( attributeValueDict, "transactionsBC" + rampFormatDelimiter + "readOnly", "true" );
put( attributeValueDict, "baseIncKey" + rampFormatDelimiter + "readOnly", "true" );

return attributeValueDict;]]></script_text><_children></_children></bm_function></_children></bm_lib_func><bm_lib_func><id>4906148</id><name><![CDATA[calculateTierPricing]]></name><variable_name><![CDATA[calculateTierPricing]]></variable_name><description><![CDATA[For a given list of PIs and their associated Qtys/NumTransactions as well as their associated Implementation Methods, populate the floatsDict with the values of each line item's tierPrice and extTierPrice.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4906147</function_id><date_modified>1678338130000</date_modified><guid><![CDATA[bm_lib_func_util_calculateTierPricing]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4906147</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_calculateTierPricing_1]]></java_class_name><child_class_names></child_class_names><date_modified>1678338130000</date_modified><guid><![CDATA[LEGACY_4906147]]></guid><script_size>1943</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	calculateTierPricing
	--------------------
	Params:
		FloatDict piQtyAndImplementationMethodToPriceDict
		String piDelimiter
		String currentDocNum
		StringDict stringsDict
		IntegerDict integersDict
		FloatDict floatsDict
	Returns:
		StringDict result
		
	Description:
		This function is meant to be called once per line item. However,
		it reads from and populates dictionaries that are shared across all
		line items.
*/
//Meta variables
debug = true;

//Return variables
result = dict("string");
error = false;
msg = "";

/* ------------------------------------------------------------------------ */
/*							Constants										*/
/* ------------------------------------------------------------------------ */
PART_NUM = "_part_number";
UOM_TYPE = "uomType_line";
UOM_QTY = "QTY";
QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
TIER_PRICE = "tierPrice_line";
EXT_TIER_PRICE = "extTierPrice_line";
IMPLEMENTATION_METHOD = "implementationMethod_line";
CORE_SERVICE = "coreOffering_line";
UNIT_OR_FIXED = "unitOrFixed_line";
UNIT = "UNIT";
FIXED = "FIXED";
RAMP_DELIMITER = "-_**_-";
INCREMENTAL_PI = "incrementalPi";
INCREMENTAL_FEE_LIST = "incrementalFeeList";
// Added by Jim Vey Case 124022
INCREMENTAL_FEE_NON_UNIFIED_LIST = "increFeeNonUnifiedList";
//end Case 124022


/* ------------------------------------------------------------------------ */
/*		First, obtain the PI/part number of the current line item			*/
/* ------------------------------------------------------------------------ */
piKey = currentDocNum + piDelimiter + PART_NUM;
pi = "";
if (containskey(stringsDict, piKey)) {
	pi = get(stringsDict, piKey);
} else {
	error = true;
	msg = msg +  "calculateTierPricing: could not find PI for docNum " + currentDocNum + "\n";
}
PARENT_DOC_NUM = "_parent_doc_number"; //CSYS-106564
BILLING_COUNTER = "BILLING_COUNTER"; //CSYS-106564
DELIMITER = "@.@";//CSYS-106564
parentDocNum = util.getStringAttribute(stringsDict, currentDocNum, DELIMITER, PARENT_DOC_NUM); //CSYS-106564
billingCounter = util.getStringAttribute( stringsDict, parentDocNum, DELIMITER, BILLING_COUNTER);//CSYS-106564

/* If this is a ramp line item, we need to also find the associated incremental fee */
incPi = "";
if ( find( currentDocNum, RAMP_DELIMITER ) <> - 1 ){
	incrementalPiKey = currentDocNum + piDelimiter + INCREMENTAL_PI;
	if ( containskey( stringsDict, incrementalPiKey ) ){
		incPi = get( stringsDict, incrementalPiKey );
	}
}
/* ------------------------------------------------------------------------ */
/*		Second, obtain the UOM type of the current part						*/
/* ------------------------------------------------------------------------ */
uomTypeKey = pi + piDelimiter + UOM_TYPE;
uomType = "";

if (containskey(stringsDict, uomTypeKey)) {
	uomType = get(stringsDict, uomTypeKey);
} else {
	error = true;
	msg = msg + "calculateTierPricing: could not find uomType for docNum " + currentDocNum + "\n";
}

/* ======================================================================== */
/*			Find out if it is a Unit/Fixed PI						*/
/* ======================================================================== */
unitOrFixedKey = pi + piDelimiter + UNIT_OR_FIXED;
unitOrFixed = "";
if (containskey(stringsDict, unitOrFixedKey)) {
	unitOrFixed = get(stringsDict, unitOrFixedKey);
}
/* ------------------------------------------------------------------------ */
/*		Third, obtain the correct multiplier (either Qty or Transactions) 
		depending on the UOM type											*/
/* ------------------------------------------------------------------------ */
multiplier = 0;
key = currentDocNum + piDelimiter + TRANSACTIONS;
trxns = 0;
if ( containskey( integersDict, key ) ){
	trxns = get( integersDict, key );
}
if (uomType == UOM_QTY) {
	key = currentDocNum + piDelimiter + QTY;
}
if (containskey(integersDict, key)) {
	multiplier = get(integersDict, key);
} else {
	error = true;
	msg = msg + "calculateTierPricing: could not find multiplier for docNum " + currentDocNum + " with uomType " + uomType + "\n";
}



/* ------------------------------------------------------------------------ */
/*		Fourth, determine the current line item's implementation method		*/
/* ------------------------------------------------------------------------ */
implementationMethod = "";
implementationMethodKey = currentDocNum + piDelimiter + IMPLEMENTATION_METHOD;
if (containskey(stringsDict, implementationMethodKey)) {
	implementationMethod = get(stringsDict, implementationMethodKey);
} else {
	error = true;
	msg = msg + "calculateTierPricing: could not find implementationMethod for docNum " + currentDocNum + "\n";
}

/* ------------------------------------------------------------------------ */
/*		Fifth, determine the current line item's core service       		*/
/* ------------------------------------------------------------------------ */
coreService = "";
coreServiceMethodKey = currentDocNum + piDelimiter + CORE_SERVICE;
if (containskey(stringsDict, coreServiceMethodKey)) {
	coreService = get(stringsDict, coreServiceMethodKey);
} else {
	error = true;
	msg = msg + "calculateTierPricing: could not find coreService for docNum " + currentDocNum + "\n";
}

/* ------------------------------------------------------------------------ */
/*		Sixth, obtain the tierPrice of the current part from the            
		piQtyAndImplementationMethodToPriceDict that was populated in the pricing script 
		by another util														*/
/* ------------------------------------------------------------------------ */
//CSYS-106564 - commented pricingKey
//pricingKey = pi + piDelimiter + string(multiplier) + piDelimiter + implementationMethod + piDelimiter + coreService;
pricingKey = pi + piDelimiter + string(multiplier) + piDelimiter + implementationMethod + piDelimiter + coreService + piDelimiter + billingCounter;//CSYS-106564
tierPrice = 0.0;

// For the associated incremental fee, use the number of transactions
incPricingKey = "";
if ( incPi <> "" ){
	//CSYS-106564 - commented incPricingKey
	//incPricingKey = incPi + piDelimiter + string(multiplier) + piDelimiter + implementationMethod + piDelimiter + coreService;
	incPricingKey = incPi + piDelimiter + string(multiplier) + piDelimiter + implementationMethod + piDelimiter + coreService + piDelimiter + billingCounter;//CSYS-106564
}
if (containskey(piQtyAndImplementationMethodToPriceDict, pricingKey)) {
	tierPrice = get(piQtyAndImplementationMethodToPriceDict, pricingKey);
} else {
	error = true;
	msg = msg + "calculateTierPricing: could not find tierPrice for docNum " + currentDocNum + "\n";
}
incTierPrice = 0.0;
if ( incPricingKey <> "" ){
	if (containskey(piQtyAndImplementationMethodToPriceDict, pricingKey)) {
		incTierPrice = get(piQtyAndImplementationMethodToPriceDict, incPricingKey);
	}
}

/* ------------------------------------------------------------------------ */
/*							Return variables								*/
/* ------------------------------------------------------------------------ */
//Don't forget to return our calculated variables...
tierPriceKey = currentDocNum + piDelimiter + TIER_PRICE;
incTierPriceKey = currentDocNum + piDelimiter + INCREMENTAL_FEE_LIST;
// Added by Jim Vey Case 124022
incNonUnifiedPriceKey = currentDocNum + piDelimiter + INCREMENTAL_FEE_NON_UNIFIED_LIST;
//end Case 124022
put(floatsDict, tierPriceKey, tierPrice);
put(floatsDict, incTierPriceKey, incTierPrice );
// Added by Jim Vey Case 124022
put(floatsDict, incNonUnifiedPriceKey, incTierPrice );
//end Case 124022
//Finally, calculate the extTierPrice of the current line item, and populate the floatsDict appropriately
if(unitOrFixed == FIXED) {
	multiplier = 1;
}
extTierPrice = multiplier * tierPrice;
extTierPriceKey = currentDocNum + piDelimiter + EXT_TIER_PRICE;
put(floatsDict, extTierPriceKey, extTierPrice);

if (error) {
	put(result, "error", msg);
}

return result;]]></script_text><_children><bm_lib_func_assoc><id>1706356544</id><caller_func_id>4906147</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[calculateTierPricing]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1678338130000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[42a99bfc-4e24-46a2-bd22-939a68c87e61]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>4906150</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[piQtyAndImplementationMethodToPriceDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1678338130000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_piQtyAndImplementationMethodToPriceDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906152</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[piDelimiter]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338130000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_piDelimiter_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906153</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[currentDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1678338130000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_currentDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906154</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1678338130000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906155</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1678338130000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4906156</id><bm_lib_func_id>4906148</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1678338130000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_calculateTierPricing.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5067939</id><name><![CDATA[getNewTransactionValues]]></name><variable_name><![CDATA[getNewTransactionValues]]></variable_name><description><![CDATA[RAMP PLANS: Given the ratio of transaction counts on the Quote level ramp plan, determines the default transaction values for a Line level ramp plan based upon the line item's transaction count. RETURNS: String[]]]></description><return_type>10</return_type><func_type>1</func_type><function_id>5067938</function_id><date_modified>1626948718000</date_modified><guid><![CDATA[bm_lib_func_util_getNewTransactionValues]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[quoteRampPlanTransactionRatios = float[] {
0.15, 0.25, 0.33, 0.5, 0.77, 1.0, 0.98
};

count = 5000;

return util.getNewTransactionValues(quoteRampPlanTransactionRatios, count);]]></main_script_text><_children><bm_function><id>5067938</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getNewTransactionValues_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948718000</date_modified><guid><![CDATA[LEGACY_5067938]]></guid><script_size>221</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> getNewTransactionValues
quoteRampPlanTransactionRatios - Float[]
currentLineItemTransactionCount - Integer

*/
newTransactionValues = string[];

for ratio in quoteRampPlanTransactionRatios {
	newTransactionValue = integer(round(ratio * currentLineItemTransactionCount, 0));
	append(newTransactionValues, string(newTransactionValue));


}
return newTransactionValues;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5067941</id><bm_lib_func_id>5067939</bm_lib_func_id><param_name><![CDATA[quoteRampPlanTransactionRatios]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>8</datatype><date_modified>1626948718000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getNewTransactionValues.bm_lib_func_param_quoteRampPlanTransactionRatios_8]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5067942</id><bm_lib_func_id>5067939</bm_lib_func_id><param_name><![CDATA[currentLineItemTransactionCount]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1626948718000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getNewTransactionValues.bm_lib_func_param_currentLineItemTransactionCount_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4907706</id><name><![CDATA[getProductBasedPricingData]]></name><variable_name><![CDATA[getProductBasedPricingData]]></variable_name><description><![CDATA[Wrapper function that populates the productBasedData String[] Dictionary with results from the BMQL query to the productBasedDisc table.]]></description><return_type>15</return_type><func_type>1</func_type><function_id>4907705</function_id><date_modified>1508547399000</date_modified><guid><![CDATA[bm_lib_func_util_getProductBasedPricingData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4907705</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getProductBasedPricingData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435926000</date_modified><guid><![CDATA[LEGACY_4907705]]></guid><script_size>691</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	getProductBasedPricingData
	--------------------------
	Params:
		String[] partNumList
		String[]Dict productBasedData
	Returns:
		StringDict result
			rowCount => number of records returned
	
	Description:
		For a given list of Part Numbers, return all Product Based Pricing
		conditions within the list of Part Numbers. condPI1, condPI2 and
		discountPI must all exist within the list of part numbers (otherwise
		there is no point!).
*/
count = -1;
result = dict("string");

productBasedDiscountConditions = bmql("select condPI1, condPI2, discountPI, discountVal, discountType, listPricePI from productBasedDisc where condPI1 in $piList and condPI2 in $piList and discountPI in $piList");

for record in productBasedDiscountConditions {
	count = count + 1; //Count should begin at 0, and increment to at most N, where N is the number of records returned in the RecordSet()
	
	data = string[];
	
	append(data, get(record, "condPI1"));
	append(data, get(record, "condPI2"));
	append(data, get(record, "discountPI"));
	append(data, get(record, "discountVal"));
	append(data, get(record, "discountType"));
	append(data, get(record, "listPricePI"));
	
	put(productBasedData, count, data);
}

put(result, "rowCount", string(count));

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4907708</id><bm_lib_func_id>4907706</bm_lib_func_id><param_name><![CDATA[piList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getProductBasedPricingData.bm_lib_func_param_piList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4907709</id><bm_lib_func_id>4907706</bm_lib_func_id><param_name><![CDATA[productBasedData]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getProductBasedPricingData.bm_lib_func_param_productBasedData_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>1065910141</id><name><![CDATA[Get Service Compatible Data Of Products]]></name><variable_name><![CDATA[getServiceCompatibleDataOfProducts]]></variable_name><description><![CDATA[Copy of Get Service Compatible Data for CSYS-101361]]></description><return_type>1</return_type><func_type>1</func_type><function_id>1065910140</function_id><date_modified>1701914802000</date_modified><guid><![CDATA[bm_lib_func_util_getServiceCompatibleDataOfProducts]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>1065910140</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getServiceCompatibleDataOfProducts_1]]></java_class_name><child_class_names></child_class_names><date_modified>1701914802000</date_modified><guid><![CDATA[b14d0610-1aea-404f-9b6f-6d4221466bdb]]></guid><script_size>1518</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = "";
returnArray = String[];
returnFalseArray = String[];
pipe = "|^|";
returnArray[0] = pipe;

//BM_VT. Business unit is required as additional filter. Getting the business unit from the commerce process
ownerBusUnit = "";
ownerTheater = "";
ownerMarket = "";
quoteType = "";
qType = "";
resSet = bmql("SELECT ownerBU_quote, ownerTheater_quote, ownerMarket_quote, quoteType_quote FROM commerce.quote_process");

for res in resSet {
	ownerBusUnit = "%"+get(res, "ownerBU_quote")+"%";
	ownerTheater = "%"+get(res, "ownerTheater_quote")+"%";
	ownerMarket = "%"+get(res, "ownerMarket_quote")+"%";
	quoteType = "%"+get(res, "quoteType_quote")+"%";
	qType = get(res, "quoteType_quote"); //Adding this since quoteType would get stamped as %quoteType% from the above line
}
selectAssetArray = get(configAttribs, "selectAssetArray","string[]");
assetsImport = get(configAttribs, "assetsImport","string");
poID = get(configAttribs, "poID","string[]");
serviceVal = get(configAttribs, "serviceVal","string[]");
assetAccountServiceIDArray = get(configAttribs, "assetAccountServiceIDArray","string[]");
//CSYS-101678 Start
assetImplementationSelectionArray = get(configAttribs, "assetImplementationSelectionArray","string[]");
assetCoreSelectionArray = get(configAttribs, "assetCoreSelectionArray","string[]");
//CSYS-101678 End
hasAsset = false;
// Add Business unit filter
recordSet = bmql("select serviceValue, availability from serviceCompatibility where serviceAttr = $serviceAttr and coreOffering = $coreOffer and implementationMethod = $implementationMethod and (businessUnit like $ownerBusUnit or businessUnit = '' or businessUnit is null) and (ownerTheater like $ownerTheater or ownerTheater = '' or ownerTheater is null) and (ownerMarket like $ownerMarket or ownerMarket = '' or ownerMarket is null) AND (quoteType like $quoteType or quoteType = '' or quoteType is null)");

for rec in recordSet
{
	if((upper(get(rec,"availability"))=="TRUE"))
	{
		append(returnArray, trim(get(rec,"serviceValue")));
	}
	else{ 
		append(returnFalseArray, trim(get(rec,"serviceValue")));
	}		
}
//CSYS-101678 moved the belwo two lines out of the if loop below 
YES = "Yes";
loc = findinarray(selectAssetArray,YES); //current selected core in config		
existingCore = assetCoreSelectionArray[loc];//CSYS-101678
existingEdition = assetImplementationSelectionArray[loc];//CSYS-101678
//CSYS-101678 Modifed the below if condition to add the existingCore == coreOffer AND existingEdition == implementationMethod condition
//IESCNQRCPQ-1318- Commenting the condition for CSYS-101678
//if(NOT(isempty(returnFalseArray)) AND qType == "Add-On Business" AND existingCore == coreOffer AND existingEdition == implementationMethod){ 	
if(NOT(isempty(returnFalseArray)) AND qType == "Add-On Business" AND coreOffer <> "Historical Data Services"){  	
	ASSET_DELIMITER = "@@";
	INTERNAL_DELIMITER = "$$";	
	assetsArray = split(assetsImport,ASSET_DELIMITER);//split the entire assets delimited string		
	size = range(sizeofarray(assetsArray));	
		
	for i in size {
		assetDetail = split(assetsArray[i],INTERNAL_DELIMITER);//split each asset
		if (findinarray(poID, assetDetail[1])> -1 AND assetDetail[16] == assetAccountServiceIDArray[loc]) { 
			pos= findinarray(poID, assetDetail[1]);
			append(returnArray, serviceVal[pos]); // Set to TRUE if any of the above declared PO's are found in the Asset string, relevant to the core we're dealing with in the current config trip
			break;		
		}
	}	
}

result = join(returnArray,pipe);

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>1065910142</id><bm_lib_func_id>1065910141</bm_lib_func_id><param_name><![CDATA[serviceAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701914802000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleDataOfProducts.bm_lib_func_param_serviceAttr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1065910143</id><bm_lib_func_id>1065910141</bm_lib_func_id><param_name><![CDATA[coreOffer]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701914802000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleDataOfProducts.bm_lib_func_param_coreOffer_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1065910144</id><bm_lib_func_id>1065910141</bm_lib_func_id><param_name><![CDATA[implementationMethod]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1701914802000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleDataOfProducts.bm_lib_func_param_implementationMethod_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>1065910145</id><bm_lib_func_id>1065910141</bm_lib_func_id><param_name><![CDATA[configAttribs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>34</datatype><date_modified>1701914802000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getServiceCompatibleDataOfProducts.bm_lib_func_param_configAttribs_34]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>998737010</id><name><![CDATA[manageARROffsetWithinProductFamily]]></name><variable_name><![CDATA[manageARROffsetWithinProductFamily]]></variable_name><description></description><return_type>1</return_type><func_type>1</func_type><function_id>998737009</function_id><date_modified>1698918206000</date_modified><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>998737009</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_manageARROffsetWithinProductFamily_1]]></java_class_name><child_class_names></child_class_names><date_modified>1698918206000</date_modified><guid><![CDATA[389010f4-b20d-47fc-a794-87902919911b]]></guid><script_size>3308</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> manageARROffsetWithinProductFamily
docNumList - string[]
stringsDict - dict("string")
integersDict - dict("integer")
piDict - dict("string")
triggerDict - dict("string")
PRODUCT_FAMILY_DICT - dict("string")
PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT - dict("integer");
PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT - dict("integer");
PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT - dict("integer")
PROD_FAM_TIER_DECREASE_OCCURRED_DICT - dict("string")
*/
PO_ID = "poId_line";
PARENT_DOC_NUM = "_parent_doc_number";
ASSET_ACTION = "assetAction_line";
TERMINATE_ACTION = "TERMINATE";
CREATE_ACTION = "CREATE";
MODIFY_ACTION = "MODIFY";
PI_ITEM_TYPE = "piItemType_line";
TRANSACTIONS = "numCommittedTransaction_line";
PRODUCT_FAMILY_ARR_OFFSET = "PRODUCT_FAMILY_ARR_OFFSET";//CSYS-95591
PRODUCT_FAMILY = "productFamily_line";//CSYS-95591
LINE_COMMENT_ASSET_STRING = "lineItemComment_line";//CSYS-95591
DELIMITER = "@.@";
BASE_FEE = "Base";
INTERNAL_DELIMITER = "$$";
ASSET_DELIMITER = "@@";
ASSET_COMMITED_TRNS = 7;
TRANS_STRING = "transString";
BUSINESS_UNIT = "ownerBU_quote";
SMB_BU = "SMB BU";
QUOTE_DOC_NUM = "1";
TRIG_KEY_VALUE_DELIM = "$,$";
TRUE_STR = "true";
expensePayClassicTerminated = false; //CSYS-103849 SV. 10-08-2021
tranxCountArray = integer[]; //CSYS-104136 (OK. 09-29-2021)  

//IESCNQRCPQ-756 (OK. 10-17-2023) Start
tranxCountDict = dict("string"); 
parentDocNumArray = string[]; 
piArray = string[]; 
coreBasedTransSizeDict = dict("integer");
//IESCNQRCPQ-756 - End

for docNum in docNumList {//CSYS-95500
	pi = get(piDict, docNum);
    poID = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_ID );
    parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM);
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
    numOfTransactions = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
    productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106; CSYS-95591
    lineItemComment = util.getStringAttribute(stringsDict, docNum, DELIMITER, LINE_COMMENT_ASSET_STRING);//CSYS-95591
	
	//CSYS-104136 (OK. 09-29-2021) Append all the transaction count to array
	if (itemType == BASE_FEE AND (findinarray(tranxCountArray,numOfTransactions) == -1) AND currentAction <> TERMINATE_ACTION) {
		append (tranxCountArray, numOfTransactions);
		
		//IESCNQRCPQ-756 (OK. 10-17-2023) Start - store the transaction count based on parentDocNum 
		put(tranxCountDict, "*" + parentDocNum + "*" + pi + "*" , string(numOfTransactions)); 
		append(parentDocNumArray, parentDocNum);
		append(piArray, pi);
		//IESCNQRCPQ-756 - End
	}
	
    if (pi <> "") {
        //CSYS-95591 - Expansion of CSYS-87106 (LN. 1/23/2018) - Track Transaction Count within Product Families
        if( itemType == BASE_FEE AND containskey(PRODUCT_FAMILY_DICT, productFamily + DELIMITER + currentAction + DELIMITER + pi) ){
            //Store the CREATE's number of transacions, to be used later for comparison
            //CSYS-97291 (P.S. 1-8-2020) Updated all Product Family Tier Count Dictionary KEY references to add in scope of the ParentDocNum
            if( currentAction == CREATE_ACTION ){
                put(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, numOfTransactions);
            }
            //Store the TERMINATE's & MODIFY's original number of transactions (# of trans on the asset) to be used for comparison later on
            else {
                 comment = split(lineItemComment,ASSET_DELIMITER);
                if(sizeofarray(comment)>1){
                    assetString = comment[2];
                    if(assetString <> ""){
                        currentAssetString = split(assetString,INTERNAL_DELIMITER);
			//CSYS-101275, BS. 12/01/2020, Added below code to check for blank values before performing string to float conversion
                        if( isnumber(currentAssetString[ASSET_COMMITED_TRNS]) ) {
				originalTrxns = integer(atof(currentAssetString[ASSET_COMMITED_TRNS]));
			}
			else{
				originalTrxns = 0;
			}
			//End CSYS-101275
                        if(currentAction == TERMINATE_ACTION){
                            put(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, originalTrxns);
                        }
                        else {
                            put(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, originalTrxns);
                            if(originalTrxns > numOfTransactions){//Tier Decrease has occurred:
                                put(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + parentDocNum, numOfTransactions);
                            }
                        }
                    }
                }
            }
        }
		//CSYS-103849 SV. 10-08-2021 Start
		expensePayPoidMasterString = "*461*1035*1268803*471*";
		if(find(expensePayPoidMasterString , "*"+poId+"*") <> -1 AND currentAction == "TERMINATE"){
			expensePayClassicTerminated = true;
			break;
		}
		//CSYS-103849 End		
	}	
}

//IESCNQRCPQ-756 (OK. 10-17-2023) Start - find the transacion count based on parentDocNum
for num in parentDocNumArray {
	transArray = string[];
	for piNum in piArray {		
		if (containskey(tranxCountDict, "*" + num + "*" + piNum + "*")) {
			trans = get(tranxCountDict, "*" + num + "*" + piNum + "*") ;
			append(transArray, trans);
		}		
	}
	if (sizeofarray(transArray) > 0) {
		transSize = sizeofarray(transArray);
		put (coreBasedTransSizeDict, num, transSize);
	}
}
//IESCNQRCPQ-756 - End

/* CSYS-95591 (LN. 8-16-2019)
    Moving this logic further down to account for the correct setting of MODIFY actions.  Expanding the original logic of CSYS-87106 to account for
    MODIFY's within the same Product Family to offset the ARR at a reduced Tier Count (effectively reducing the ARR).
*/
ownerBU = util.getStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, BUSINESS_UNIT );

for docNum in docNumList {
    pi = get(piDict, docNum);
    productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106; CSYS-95591
    parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM);//CSYS-97291 (P.S. 1-8-2020)
    itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    numOfTransactions = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
    tierDecrease = false;
	
	if( itemType == BASE_FEE AND containskey(PRODUCT_FAMILY_DICT, productFamily + DELIMITER + currentAction + DELIMITER + pi) ){
        // 1. This accounts for Tier Decrease Scenarios..
//        if( containskey(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum) ){//CSYS-101072 DWC
        if( containskey(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) ){//CSYS-101072 DWC
//            createTierCnt = get(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum);//CSYS-101072 DWC
            createTierCnt = get(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);//CSYS-101072 DWC
//			if( currentAction == TERMINATE_ACTION AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum) ){//CSYS-100370 //CSYS-101072 DWC
			if( currentAction == TERMINATE_ACTION AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) ){//CSYS-100370 //CSYS-101072 DWC
//                terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum);//CSYS-100370 //CSYS-101072 DWC
                terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);//CSYS-100370 //CSYS-101072 DWC
				//If the original Termiante Trxn number is > than the Create, a tier decrease has occured,
                if(terminateTierCnt > createTierCnt  AND createTierCnt <> 0){
                    //CSYS-95591
                    //Store the decreased number of transactions from the create at the terminate line level
					
					//CSYS-104136 (OK. 09-29-2021) When all the base lines in a quote have the same transaction count then only change the transaction count for Terminate line when we have Terminate / Create in same product family
					//IESCNQRCPQ-756 (OK. 10-17-2023) Comment out the below if condition and add Dict based if condition to check the transaction count based on core service to support 2 core scenario
					//if (sizeofarray(tranxCountArray) < 2) {
					if (containskey(coreBasedTransSizeDict, parentDocNum)){
						transSize = get(coreBasedTransSizeDict, parentDocNum);
						if (transSize < 2) {
							utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, createTierCnt);
							//Update the Ramp transaction string with the updated TRXN count:
							utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TRANS_STRING, string(createTierCnt));
						}
					}
					tierDecrease = true;
                }
            }
//            if( currentAction == MODIFY_ACTION AND containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum) ){//CSYS-100370 //CSYS-101072 DWC
            if( currentAction == MODIFY_ACTION AND containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) ){//CSYS-100370 //CSYS-101072 DWC
//                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum);//CSYS-100370 //CSYS-101072 DWC
                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);//CSYS-100370 //CSYS-101072 DWC
                if(modifyOriginalTierCnt > numOfTransactions){
                    tierDecrease = true;
                }
            }
        }
        // 2. This accounts for the Tier Increase Scenario.
        else {
//            if( containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum) AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum) ){//CSYS-100370 //CSYS-101072 DWC
            if( containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) ){//CSYS-100370 //CSYS-101072 DWC
//                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum);//CSYS-100370 //CSYS-101072 DWC
                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);//CSYS-100370 //CSYS-101072 DWC
//                if(containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + docNum)){//CSYS-100370 //CSYS-101072 DWC
                if(containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + parentDocNum)){//CSYS-100370 //CSYS-101072 DWC
//                    terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + docNum);//CSYS-100370 //CSYS-101072 DWC
                    terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);//CSYS-100370 //CSYS-101072 DWC
//                    modifyTierDecreaseTrxnCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + docNum);//CSYS-100370 //CSYS-101072 DWC
                    modifyTierDecreaseTrxnCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + parentDocNum);//CSYS-100370 //CSYS-101072 DWC
                    if(terminateTierCnt > modifyTierDecreaseTrxnCnt){
                        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, modifyTierDecreaseTrxnCnt);
                        tierDecrease = true;
                    }
                }
            }
            //CSYS-98152 SN. 01/2020
			//CSYS-103849 SV. 10-08-2021 Modified the below if condition
            if (ownerBU == SMB_BU AND currentAction == TERMINATE_ACTION AND expensePayClassicTerminated == false){
                put(triggerDict, docNum + "~" + "terminateOutsideProductFamily", docNum + "~" + "terminateOutsideProductFamily" + TRIG_KEY_VALUE_DELIM + TRUE_STR);
            }
        }
    }
    //CSYS-95591
    put(PROD_FAM_TIER_DECREASE_OCCURRED_DICT, currentAction + DELIMITER + pi, string(tierDecrease));
}
return "";]]></script_text><_children><bm_lib_func_assoc><id>998737021</id><caller_func_id>998737009</caller_func_id><called_lib_func_id>4906063</called_lib_func_id><rule_area><![CDATA[manageARROffsetWithinProductFamily]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1698918206000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[0eaf35ea-4598-4036-b1d4-118ddb9877c0]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>998737022</id><caller_func_id>998737009</caller_func_id><called_lib_func_id>4906069</called_lib_func_id><rule_area><![CDATA[manageARROffsetWithinProductFamily]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1698918206000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[2d3676de-5b0b-4416-a59b-56b2887809b4]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>998737023</id><caller_func_id>998737009</caller_func_id><called_lib_func_id>4906088</called_lib_func_id><rule_area><![CDATA[manageARROffsetWithinProductFamily]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1698918206000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[019fedb4-a356-4431-9774-f33827faefb6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc><bm_lib_func_assoc><id>998737024</id><caller_func_id>998737009</caller_func_id><called_lib_func_id>4906081</called_lib_func_id><rule_area><![CDATA[manageARROffsetWithinProductFamily]]></rule_area><area_num>-1</area_num><ref_id>-1</ref_id><ref_location>5</ref_location><date_modified>1698918206000</date_modified><called_lib_func_type>1</called_lib_func_type><guid><![CDATA[f1621345-2970-4c7d-92dc-dd4fd705d7ff]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_assoc></_children></bm_function><bm_lib_func_param><id>998737011</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[docNumList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1698918206000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_docNumList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737012</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1698918206000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737013</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1698918206000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737014</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[piDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1698918206000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_piDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737015</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[triggerDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1698918206000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_triggerDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737016</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[PRODUCT_FAMILY_DICT]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1698918206000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_PRODUCT_FAMILY_DICT_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737017</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1698918206000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737018</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1698918206000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737019</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1698918206000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>998737020</id><bm_lib_func_id>998737010</bm_lib_func_id><param_name><![CDATA[PROD_FAM_TIER_DECREASE_OCCURRED_DICT]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1698918206000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_manageARROffsetWithinProductFamily.bm_lib_func_param_PROD_FAM_TIER_DECREASE_OCCURRED_DICT_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5067957</id><name><![CDATA[spliceXMLNodeValues]]></name><variable_name><![CDATA[spliceXMLNodeValues]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>5067956</function_id><date_modified>1626948719000</date_modified><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValues]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text><![CDATA[xmlString = "<rampPlanDetails className='rampPlanDetails' rowCounterDisplayName='Ramp Plans' parentNodeName='rampPlanDetails' childNodeName='rampPlanDetail'><rampPlanDetail><from displayName='From' readOnly='false'>1</from><to displayName='To' readOnly='true'>4</to><transactions displayName='Transactions' readOnly='false'>1000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>5</from><to displayName='To' readOnly='true'>14</to><transactions displayName='Transactions' readOnly='false'>2000</transactions></rampPlanDetail><rampPlanDetail><from displayName='From' readOnly='false'>15</from><to displayName='To' readOnly='true'>and beyond</to><transactions displayName='Transactions' readOnly='false'>3000</transactions></rampPlanDetail></rampPlanDetails>";

spliceNodeName = "transactions";

newNodeValues = string[]{"1", "2", "3"};

return util.spliceXMLNodeValues(xmlString, spliceNodeName, newNodeValues);]]></main_script_text><_children><bm_function><id>5067956</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_spliceXMLNodeValues_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948719000</date_modified><guid><![CDATA[LEGACY_5067956]]></guid><script_size>350</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[result = "";

openingTag = "<" + spliceNodeName;
spliceNodeIndex = -1;
spliceStartIndex = -1;
spliceEndIndex = -1;

remaining = originalXmlString;

for newValue in newNodeValues {
	spliceNodeIndex = find(remaining, openingTag);
	spliceStartIndex = find(remaining, ">", spliceNodeIndex) + 1;	//Add 1, because otherwise this returns the index of the ">" in e.g. <transactions class="transactions">, and actually we want the index of where the value starts
	spliceEndIndex = find(remaining, "</", spliceStartIndex);
	
	soFar = substring(remaining, 0, spliceStartIndex);

	remaining = substring(remaining, spliceEndIndex);
	
	result = result + soFar + newValue;
}

result = result + remaining;

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5067959</id><bm_lib_func_id>5067957</bm_lib_func_id><param_name><![CDATA[originalXMLString]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948719000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValues.bm_lib_func_param_originalXMLString_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5067960</id><bm_lib_func_id>5067957</bm_lib_func_id><param_name><![CDATA[spliceNodeName]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948719000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValues.bm_lib_func_param_spliceNodeName_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5067961</id><bm_lib_func_id>5067957</bm_lib_func_id><param_name><![CDATA[newNodeValues]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948719000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_spliceXMLNodeValues.bm_lib_func_param_newNodeValues_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>5019573</id><name><![CDATA[getPromoCodeDetails]]></name><variable_name><![CDATA[getPromoCodeDetails]]></variable_name><description><![CDATA[Gets Promo Description]]></description><return_type>15</return_type><func_type>1</func_type><function_id>5019572</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>5019572</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPromoCodeDetails_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435909000</date_modified><guid><![CDATA[LEGACY_5019572]]></guid><script_size>2177</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* Util -> getPromoCodeDetails

promoCodeAppliedArr - String[]
applicablePromosArr - String[]
internalPromoDescDict - String Dictionary
externalPromoDescDict - String Dictionary
customerFriendlyPromoDescDict - String Dictionary
legalPromoDescDict - String Dictionary

*/
promoCodeDescAndDetailsDict = dict("string");
promoCodeDetails = "<promoDesc>";
for promo in applicablePromosArr {
	internalDesc = "";
	externalDesc = "";
	customerFriendlyDesc = "";
	legalDesc = "";
	internalDescOrder = 1;
	externalDescOrder = 1;
	customerFriendlyDescOrder = 1;
	legalDescOrder = 1;
	// Get Promo Code Description
	promoCodeDescResSet = bmql("SELECT description, descriptionType, orderNum FROM PromoMessage WHERE promotionCode=$promo");
	for resSet in promoCodeDescResSet {
		descType = get(resSet, "descriptionType");
		if(descType == "INTERNAL_NAME" AND get(resSet, "orderNum") == string(internalDescOrder)) {
			internalDesc = internalDesc + get(resSet, "description");
			internalDescOrder = internalDescOrder + 1;
		}
		if(descType == "INTERNAL_DESC" AND get(resSet, "orderNum") == string(externalDescOrder)) {
			externalDesc = externalDesc + get(resSet, "description");
			externalDescOrder = externalDescOrder + 1;
		}
		if(descType == "CUSTOMER_FRIENDLY" AND get(resSet, "orderNum") == string(customerFriendlyDescOrder)) {
			customerFriendlyDesc = customerFriendlyDesc + get(resSet, "description");
			customerFriendlyDescOrder = customerFriendlyDescOrder + 1;
		}
		if(descType == "LEGAL" AND get(resSet, "orderNum") == string(legalDescOrder)) {
			legalDesc = legalDesc + get(resSet, "description");
			legalDescOrder = legalDescOrder + 1;
		}
		if(len(internalDesc) > 0) {
			put(internalPromoDescDict, promo, internalDesc);
		}
		if(len(externalDesc) > 0) {
			put(externalPromoDescDict, promo, externalDesc);
		}
		if(len(customerFriendlyDesc) > 0) {
			put(customerFriendlyPromoDescDict, promo, customerFriendlyDesc);
		}
		if(len(legalDesc) > 0) {
			put(legalPromoDescDict, promo, legalDesc);	
		}
	}
}
for promo in applicablePromosArr {
	internalDesc = "";
	externalDesc = "";
	customerFriendlyDesc = "";
	legalDesc = "";
	startDate = "";
	endDate = "";
	promotionCategory = "";
	if(containskey(internalPromoDescDict, promo))  {
		internalDesc = get(internalPromoDescDict, promo);
	}
	if(containskey(externalPromoDescDict, promo))  {
		externalDesc = get(externalPromoDescDict, promo);
	}
	if(containskey(customerFriendlyPromoDescDict, promo))  {
		customerFriendlyDesc = get(customerFriendlyPromoDescDict, promo);
	}
	if(containskey(legalPromoDescDict, promo))  {
		legalDesc = get(legalPromoDescDict, promo);
	}
	// Get the start and end date for the promo to display in the quote
	promoDatesResSet = bmql("SELECT promotionCategory, startDate, endDate FROM PromoCodeDetails WHERE promotionCode = $promo");
	for promoDatesRes in promoDatesResSet {
	  promotionCategory = get(promoDatesRes, "promotionCategory");
	  startDate = get(promoDatesRes, "startDate");
	  endDate = get(promoDatesRes, "endDate");
	}
	
	if(len(promo) > 0) {
		promoCodeDetails = promoCodeDetails + "<code>" + "<id>" + promo + "</id>" + "<startDate>" + startDate + "</startDate>" + "<endDate>" + endDate + "</endDate>" + "<applied>";
		if(findinarray(promoCodeAppliedArr, promo)  <> -1) {
			promoCodeDetails = promoCodeDetails + "TRUE";
		} else {
			promoCodeDetails = promoCodeDetails + "FALSE";
		}
		promoCodeDetails = promoCodeDetails + "</applied>" + "<promoCat>" + promotionCategory + "</promoCat>";
		if(len(internalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<INTERNAL_NAME>" + internalDesc + "</INTERNAL_NAME>";
		}
		if(len(externalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<INTERNAL_DESC>" + externalDesc + "</INTERNAL_DESC>";
		}
		if(len(customerFriendlyDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<CUSTOMER_FRIENDLY>" + customerFriendlyDesc + "</CUSTOMER_FRIENDLY>";
		}
		if(len(legalDesc) > 0) {
			promoCodeDetails = promoCodeDetails + "<LEGAL>" + legalDesc + "</LEGAL>";
		}
		promoCodeDetails = promoCodeDetails + "</code>";
	}
}
promoCodeDetails = promoCodeDetails + "</promoDesc>";
put(promoCodeDescAndDetailsDict, "promoCodeDetails", promoCodeDetails); 
return promoCodeDescAndDetailsDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>5019575</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[promoCodeAppliedArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547403000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_promoCodeAppliedArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5147119</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[applicablePromosArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547403000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_applicablePromosArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5147120</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[internalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547403000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_internalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5147121</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[externalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547403000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_externalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5147122</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[customerFriendlyPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547403000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_customerFriendlyPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>5147123</id><bm_lib_func_id>5019573</bm_lib_func_id><param_name><![CDATA[legalPromoDescDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547403000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_getPromoCodeDetails.bm_lib_func_param_legalPromoDescDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>853096224</id><name><![CDATA[Get Unified Pricing Info For Model]]></name><variable_name><![CDATA[getUnifiedPricingInfoForModel]]></variable_name><description><![CDATA[CSYS-97908]]></description><return_type>18</return_type><func_type>1</func_type><function_id>853096223</function_id><date_modified>1626948726000</date_modified><guid><![CDATA[bm_lib_func_util_getUnifiedPricingInfoForModel]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>853096223</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getUnifiedPricingInfoForModel_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948727000</date_modified><guid><![CDATA[8842539e-6177-408a-ada9-026a6d0ed292]]></guid><script_size>343</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[//CSYS-97908
rowCount = sizeofarray(values(unifiedPricingDataDict));
iterArr = range(rowCount);
rowCount = 0;
unifiedPricingForModelDict = dict("string[]");
DELIMITER = "@.@";

for item in iterArr {
	rowKey = string(rowCount) + DELIMITER + modelDocNum;
	if (containskey(unifiedPricingDataDict, rowKey)){
		poDataArr = get(unifiedPricingDataDict, rowKey);
		put(unifiedPricingForModelDict, rowKey, PODataArr);	
	}
	rowCount = rowCount + 1;
}

return unifiedPricingForModelDict;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>853096226</id><bm_lib_func_id>853096224</bm_lib_func_id><param_name><![CDATA[unifiedPricingDataDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1626948726000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getUnifiedPricingInfoForModel.bm_lib_func_param_unifiedPricingDataDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>853096227</id><bm_lib_func_id>853096224</bm_lib_func_id><param_name><![CDATA[modelDocNum]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948726000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getUnifiedPricingInfoForModel.bm_lib_func_param_modelDocNum_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>15722773</id><name><![CDATA[Update Transactions After Attribute Gathering]]></name><variable_name><![CDATA[updateTransactionsAfterAttributeGathering]]></variable_name><description><![CDATA[Moved from pricing script.
Changes transactions based on informtion obtained during the info gathering step.]]></description><return_type>1</return_type><func_type>1</func_type><function_id>15722772</function_id><date_modified>1626948721000</date_modified><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>15722772</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_updateTransactionsAfterAttributeGathering_1]]></java_class_name><child_class_names></child_class_names><date_modified>1626948721000</date_modified><guid><![CDATA[testconcur_12847332]]></guid><script_size>1719</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util.updateTransactionsAfterAttributeGathering

This is used to update the transactions of all line items after the initial information gathering process.

This is used becauuse line items later in the grid can affect line items previously in the grid

transactionArr = String[]; 
stringsDict
integersDict
floatsDict  
triggerDict// Dictionaries used for holding quote state information
*/
TRIG_KEY_VALUE_DELIM = "$,$";
DELIMITER = "@.@";
PART_NUM = "_part_number";
DESCRIPTION = "lineDescription_line";
SEQ_NUM = "_sequence_number";
DOC_NUM = "_document_number";
PARENT_DOC_NUM = "_parent_doc_number";
IMPLEMENTATION_METHOD = "implementationMethod_line";
CORE_OFFERING = "coreOffering_line";
EDITION_LINE = "edition_line";
ADV_LEARNING_SERVICES_REQUIRED = "advLearningSvcsReqd_line";
APPROVAL_LINE_TRIGGER = "approval_line";
ADDL_DISC_DISALLOWED = "addlDiscDisallowed_line";

QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
TRANSACTION_BY_BC = "transactionsBC";
PREV_TRANSACTIONS = "prevNumCommittedTransaction_line";
PREV_DISCOUNT = "prevDiscount_line";
IS_TRANS_OVERRIDDEN = "numTransOverride_line";
IS_GROUPED = "isPartOfPackage_line"; //This form field is checked if the user wishes to DYNAMICALLY GROUP this line item
IS_UNITBASED = "unitBasedTransaction";
DISCOUNT = "discount_line";
DISCOUNTHIDDEN = "discountHidden_line";
DISCOUNT_TYPE = "discountType_line";
PERCENTAGE_DISCOUNT_TYPE = "%";
AMOUNT_DISCOUNT_TYPE = "Amt";
DISCOUNT_AMOUNT = "discountAmt_line";
DISCOUNT_PERCENT = "discountPercent_line";
TERM_BASED_DISC = "termBasedDiscount_line";
//add on related
ASSETS_NUM_OF_TRANSACTIONS = "assetOriginalOfCommittedMonthlyTransactions_line";
ASSETS_ORIGINAL_DISCOUNT = "assetsOriginalDiscount_line";
ASSETS_ADJUSTED_ARR = "assetAdjustedArr_line";
ASSETS_ORIGINAL_PI = "assetOriginalPI_line";
ASSETS_ORIGINAL_PO = "assetOriginalPO_line";
ASSETS_ORIGINAL_NET_PRICE = "assetOriginalNetPrice_list";
ASSETS_ORIGINAL_LIST_PRICE = "assetOriginalListPrice_list";
ASSETS_ORIGINAL_BUNDLE_ID = "originalBundleID_line";
ASSETS_ORIGINAL_IS_GROUPED = "assetOriginalGroupCheck_line";


CORE_ASSET_SERVICEID = "coreAssetServiceId";
INCREMENTAL_FEE_LIST = "incrementalFeeList";
INCREMENTAL_FEE_LIST_USD = "incrementalFeeListUSD";
INCREMENTAL_FEE_NET = "incrementalFeeNet";
INCREMENTAL_FEE_NET_USD = "incrementalFeeNetUSD";
INC_FEE_NON_UNIFIED_NET = "increFeeNonUnifiedNet";
BASE_FEE_NET_NON_UNIFIED = "baseFeeNonUnifiedNet";
INC_FEE_NON_UNIFIED_NET_USD = "increFeeNonUnifiedNetUSD";
BASE_FEE_NET_NON_UNIFIED_USD = "baseFeeNonUnifiedNetUSD";

MODEL_FORCE_GROUPING = "modelForceGrouping";
//Ramp plan attribute variable names
RAMP_PLAN_OVERRIDE = "overrideDefaultRampPlan_line";
RAMP_PLAN_DETAIL = "rampPlanDetails_line";
RAMP_PLAN_DETAIL_SAVE_XML = "rampPlanDetailXMLSave_line";
RAMP_DELIMITER = "-_**_-";
PO_DELIMITER = "***";
PO_GROUPS_TRANS = "poGroupsInModelTrans";
PO_GROUPS_DYNAMIC_GROUPING = "poGroupsDynamicGrouping";
PO_RAMP_OVERRIDE = "poRampOverride";
PRIMARY_BASE_FEE = "primaryBaseFee";
ROLLUP_DOC_NUM = "rollupDocNum";
TRANS_STRING = "transString";
FROM = "from";
TO = "to";
RAMP_MESSAGE = "rampValidationMessage_quote";
//Pricing Attribute Variable Names
TIER_PRICE = "tierPrice_line";
EXT_TIER_PRICE = "extTierPrice_line";
PROD_BASED_PRICE = "productBasedPrice_line";
PROD_BASED_PRICE_USD = "extProductBasedPriceUSD_line";
EXT_PROD_BASED_PRICE = "extProductBasedPrice_line";
TERM_BASED_PRICE = "termBasedListPrice_line";
EXT_TERM_BASED_PRICE = "extTermBasedListPrice_line";
BASE_LIST_PRICE_UNIFIED = "listPriceUnified";
LIST_PRICE = "listPrice_line";
EXT_LIST_PRICE = "extendedList_line";
LIST_PRICE_USD = "listPriceUSD_line";
EXT_LIST_PRICE_USD = "extListPriceUSD_line";
CUSTOM_LIST_PRICE = "customListPrice_line";
ARR_LINE = "arr_line";
ARR_NET = "arrNet_line";
PROD_ROLL = "productBasedPriceRollUp";
NET_PRICE = "netPriceEach_line";
ORIG_NET_PRICE = "origNetPriceEa_line";
NET_PRICE_USD = "netPriceUSD_line";
EXT_NET_PRICE_USD = "extNetPriceUSD_line";
EXT_NET_PRICE = "extendedNetPrice_line";
NET_PRICE_NON_UNIFIED = "netPriceNonUnified_line";
EXT_NET_PRICE_NON_UNIFIED = "extNetPriceNonUnified_line";
NET_PRICE_UNIFIED = "netPriceUnified_line";
EXT_NET_PRICE_UNIFIED = "extNetPriceUnified_line";
NET_PRICE_NON_UNIFIED_USD = "netPriceNonUnifiedUSD_line";
EXT_NET_PRICE_NON_UNIFIED_USD = "extNetPriceNonUnifiedUSD_line";
NET_PRICE_UNIFIED_USD = "netPriceUnifiedUSD_line";
EXT_NET_PRICE_UNIFIED_USD = "extNetPriceUnifiedUSD_line";
LIST_PRICE_NON_UNIFIED = "listPriceNonUnified_line";
EXT_LIST_PRICE_NON_UNIFIED = "extListPriceNonUnified_line";
LIST_PRICE_NON_UNIFIED_USD = "listPriceNonUnifiedUSD_line";
EXT_LIST_PRICE_NON_UNIFIED_USD = "extListPriceNonUnifiedUSD_line";
PACKAGE_ID = "package_line";
BUNDLE_ID = "bundleID_line";
EXT_NET_PER_BILLING_PERIOD = "extNetPricePerBillingPeriod_line";
NUM_TRANSACTIONS_PER_BILLING_PERIOD = "numTransPerBillingPeriod_line";
RAMP_PLAN_MESSAGE = "rampPlanMessageText_line";

// Used for Base Fee that are not rampable to unify
RAMP_PRICE_FOR_NON_RAMPABLE_BASE = "rampPriceForNonRampableBase";
PI_ITEM_TYPE = "piItemType_line"; 
MODEL_PO_PRIORITY = "poPriority_concur";
EXT_NET_UNGROUPED = "extNetPriceUngrouped_line";
NET_UNGROUPED = "netPriceUngrouped_line";
NUMBER_RAMP_ENTRIES = "numRampEntries";
MODEL_HAS_GROUPING = "modelHasGrouping_line";
CORE_TRANSACTIONS = "coreTransactions";
TRANSACTION_RATIO = "transactionRatio";
INCREMENTAL_FEE_RATIO_VALUE = "incrementalFeeRatioValue";
MODEL_TRANSACTION_OVERRIDE = "modelTransactionOverride";
LINE_TRANSACTION_OVERRIDE = "lineTransactionOverride";
CUSTOM_SEQ_NUM = "lineOrderCustom_line";
PO_ID = "poId_line";
PO_NAME = "poName_line";
PO_START_DATE = "poStartDate_line";
PO_END_DATE = "poEndDate_line";
PI_ITEM_TYPE = "piItemType_line"; 
USAGE_QUALIFCATION_GROUP = "usageQualificationGroup_line";
TERM_OF_COMMITMENT = "termOfCommitment_line";
EDITION = "edition_line";
PARAMETER_ID = "parameterId_line";
RAMP_FLAG = "rampFlag_line";
SPECIAL_WORKFLOW_FLAG = "specialWorkflowFlag_line";
UOM_TYPE = "uomType_line";
ROLL_UP = "rollUp_line";
UOM_BLOCK = "uomBlock_line";
BUNDLE_FLAG = "bundleFlag_line";
PO_CATEGORY = "poCategory_line";
UNIT_OR_FIXED = "unitOrFixed_line";
MODEL_TRANSACTIONS = "modelTransactions";
MODEL_NEW_TRANSACTIONS = "modelNewTransactions";
TRUE_STR = "true";
ASSET_ACTION = "assetAction_line";
MODIFY_ACTION = "MODIFY";
NONE_ACTION = "NONE";
TERMINATE_ACTION = "TERMINATE";
CREATE_ACTION = "CREATE";
ADD_ON = "Add-On Business";


for docNum in transactionArr {
	pi = get(piDict, docNum);
	trxns = 0;
	if ( pi <> "" ){
		itemType = get( stringsDict, docNum+DELIMITER+ PI_ITEM_TYPE );
		parentDocNum = get(stringsDict, docNum+DELIMITER+ PARENT_DOC_NUM );
		poGroupTrans = get(stringsDict, docNum /*parentdocNum*/ +DELIMITER+ PO_GROUPS_TRANS );
		poGroupArr = split( poGroupTrans, PO_DELIMITER );
		poID = get(stringsDict, docNum+DELIMITER+ PO_ID );

		// This will activate if the user has changed the line transactions for this item before update
		if ( containskey( integersDict, docNum /*parentDocNum*/ + DELIMITER + MODEL_NEW_TRANSACTIONS ) AND findinarray( poGroupArr, poID ) <> -1 ){
			trxns = get( integersDict, docNum /*parentDocNum*/ +DELIMITER+ MODEL_NEW_TRANSACTIONS );

			
			
			put( integersDict, docNum+DELIMITER+ TRANSACTIONS, trxns );
			put( stringsDict, docNum+DELIMITER+ IS_TRANS_OVERRIDDEN, TRUE_STR );
		}
		else{
			if( itemType == "Incremental" ){
				if ( containskey( incrementalFeeTransactionDict, parentDocNum + DELIMITER + poID ) ){

					trxns = get( incrementalFeeTransactionDict, parentDocNum + DELIMITER + poID );
					

					put( integersDict, docNum+DELIMITER+ TRANSACTIONS, trxns );
					// Set the approval triggers for incremental line items to use their new transactions 
					if ( billingCycleNumber == "12" ) {
						//put(lineTriggersDict, docNum + "~" + "annualTransaction", docNum + "~" + "annualTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 12));
						put(triggerDict, docNum + "~" + "annualTransaction", docNum + "~" + "annualTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 12));
					} elif ( billingCycleNumber == "3" ) {
						//put(lineTriggersDict, docNum + "~" + "quarterlyTransaction", docNum + "~" + "quarterlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 3));
						put(triggerDict, docNum + "~" + "quarterlyTransaction", docNum + "~" + "quarterlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 3));
					} else {
						//put(lineTriggersDict, docNum + "~" + "monthlyTransaction", docNum + "~" + "monthlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns));
						put(triggerDict, docNum + "~" + "monthlyTransaction", docNum + "~" + "monthlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns));
					}
					
					continue;
				}
			}
			//assetAction = get( stringsDict, docNum+DELIMITER+ ASSET_ACTION );
		
			/*if ( get( stringsDict, docNum+DELIMITER+ IS_TRANS_OVERRIDDEN ) <> TRUE_STR AND assetAction <> TERMINATE_ACTION){
								
				trxns = quoteTransactions;
				
				//addon related By Sai Krishna Case 108831: Double Save Action
			//if( quoteType == ADD_ON  AND assetAction == NONE_ACTION and (quoteTransactions <> oRGNumberOfComittedTransactions AND oRGNumberOfComittedTransactions > 1 AND quoteTransactions > 1) and get(stringsDict, docNum+DELIMITER+ "isFirstIteration_line") <> "true"){
			if( quoteType == ADD_ON  AND assetAction == NONE_ACTION and (quoteTransactions <> get(integersDict, docNum+DELIMITER+ "originalNumCommittedTransaction_line") AND get(integersDict, docNum+DELIMITER+ "originalNumCommittedTransaction_line") > 1 AND quoteTransactions > 1) and get(stringsDict, docNum+DELIMITER+ "isFirstIteration_line") <> "true"){
					
					assetAction = MODIFY_ACTION;
					put( stringsDict, docNum+DELIMITER+ ASSET_ACTION, assetAction );
				}	
				put( integersDict, docNum+DELIMITER+ TRANSACTIONS, trxns );
			}	*/
		}
		
	}
}

return "true";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>15722774</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[stringsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948721000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_stringsDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722775</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[integersDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1626948721000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_integersDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722776</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[floatsDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>15</datatype><date_modified>1626948721000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_floatsDict_15]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722777</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[transactionArr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1626948721000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_transactionArr_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722778</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[piDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948721000</date_modified><order_no>5</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_piDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722779</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[incrementalFeeTransactionDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>14</datatype><date_modified>1626948721000</date_modified><order_no>6</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_incrementalFeeTransactionDict_14]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722780</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[billingCycleNumber]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948721000</date_modified><order_no>7</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_billingCycleNumber_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722781</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[quoteTransactions]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1626948721000</date_modified><order_no>8</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_quoteTransactions_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722782</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[quoteType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1626948721000</date_modified><order_no>9</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_quoteType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722783</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[oRGNumberOfComittedTransactions]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>6</datatype><date_modified>1626948721000</date_modified><order_no>10</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_oRGNumberOfComittedTransactions_6]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>15722784</id><bm_lib_func_id>15722773</bm_lib_func_id><param_name><![CDATA[triggerDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1626948721000</date_modified><order_no>11</order_no><guid><![CDATA[bm_lib_func_util_updateTransactionsAfterAttributeGathering.bm_lib_func_param_triggerDict_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4958903</id><name><![CDATA[evalNoMath]]></name><variable_name><![CDATA[evalNoMath]]></variable_name><description><![CDATA[NOT USED]]></description><return_type>1</return_type><func_type>1</func_type><function_id>4958902</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_evalNoMath]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4958902</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_evalNoMath_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435908000</date_modified><guid><![CDATA[LEGACY_4958902]]></guid><script_size>3328</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util -> evalNoMath

expression - String
attrs - String Dictionary
*/
debug = false;
wildcard = "NA";
null = "";
quote = "\"";
delim = "|^|";
returnVal = -1;
ORop = " || ";
ANDop = " && ";
plusOp = "+";
multOp = "*";
gtOp = ">";
ltOp = "<";
gteOp = ">=";
lteOp = "<=";
eqOp = "=";
neOp = "<>";
containOp = "contains";
containStrOp = "containsStr";
notContainOp = "notContains";
boolOps = String[]{gteOp,lteOp,neOp,gtOp,ltOp,eqOp,containOp,containStrOp,notContainOp};

if(expression == null) {
  return expression;
}
if (substring(expression,0,1) == quote and substring(expression,-1) == quote) {
  return substring(expression,1,-1);
}

clauses = split(expression,ANDop);
clauseVals = String[];

i = 0;
for clause in clauses {
  if(debug){print("AND-CLAUSE:" + clause);}
  clauseTrue = false;
  if(substring(clause,0,1) == quote and substring(clause,-1) == quote) {
    clauseTrue = true;
    clauseVals[i] = substring(clause,1,-1);
    i = i+1;
    continue;
  }
  subClauses = split(clause,ORop);
  subClauseVals = String[];
  j = 0;
  for subClause in subClauses {
    if(debug){print("   OR-CLAUSE: " + subClause);}
    if(substring(subclause,0,1) == quote and substring(subclause,-1) == quote) {
      j=j+1;
      continue;
    }
    comps = String[]{subClause};
    thisOp = null;
    for op in boolOps {
      if(find(subClause,op)>0) {
        thisOp = op;
        comps = split(subClause,op);
        break;
      }
    }
    k = 0;
    for comp in comps {
      if(debug){print("      Comp:"+comp);}
      valNum = 0;
      valStr = null;
      if(substring(comp,0,1) == quote and substring(comp,-1) == quote) {
        valStr = substring(comp,1,-1);
      } else {
        summands = split(comp,plusOp);
        if(debug){print "            SUMMANDS:" + join(summands,", ");}

        for summand in summands {
          if(summand == null) {
            continue;
          }
          if(isnumber(summand)) {
            valNum = valNum + atof(summand);
            continue;
          }
          mults = split(summand,multOp);
          mtotal = 1;
          if(debug){print "              MULTS:" + join(mults,",");}
          for mult in mults {
            mNum = 1;
            if(isnumber(mult)) {
              mtotal = mtotal * atof(mult);
              continue;
            }
            isVariable = containskey(attrs,mult);
            if(isVariable) {
              varVal = get(attrs,mult);
              if(isnumber(varVal)) {
                mNum = atof(varVal);
              }
              else {
                valStr = varVal;
              }
            }
            if(not(isVariable)) { 
              valStr = comp;
              break;
            }
            mtotal = mtotal * mNum;
          }
          valNum = valNum + mtotal;
        }
      }

      if(valStr == null ) {
        valStr = string(valNum);
      }
      if(debug){print("                VAL: " + valStr);}
      comps[k] = valStr;
      k = k+1;
    }
    leftSide = 0;
    numbers = false;
    rightSide = 0;
    //rightSideNum = false;
    
    if(thisOp == null) {
      // no comparator, return value of expression
      clauseTrue = true;
      return comps[0];
    }
    if(isnumber(comps[0])) {
      leftSide = atof(comps[0]);
      numbers = true;
    }
    if(numbers) {
      if(not(isnumber(comps[1]))) {	
        numbers = false;
      } else {
        rightSide = atof(comps[1]);
      }
    }
    //if(debug){print(comps[0] + thisOp + comps[1] + "?");}
    //clauseTrue = false;
    if(thisOp == gtOp) {
      if(numbers and leftSide > rightSide or
          (not(numbers) and comps[0] > comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == ltOp) {
      //if(debug){print("ltOp");}
      if(numbers and leftSide < rightSide or
          (not(numbers) and comps[0] < comps[1])) {
        
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == lteOp) {
      if(numbers and leftSide <= rightSide or
          (not(numbers) and comps[0] <= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == gteOp) {
      if(numbers and leftSide >= rightSide or
          (not(numbers) and comps[0] >= comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == eqOp) {
      //if(debug){print(comps[0] + thisOp + comps[1]);}
      if(numbers and leftSide == rightSide or
          (not(numbers) and comps[0] == comps[1])) {
        clauseTrue = true;
        break;
      }
      
    } elif (thisOp == neOp) {
      
      if(numbers and leftSide <> rightSide or
          (not(numbers) and comps[0] <> comps[1])) {
        clauseTrue = true;
        break;
      }
      
    }
    elif ( thisOp == containOp ) {
      comps0 = comps[0];
      comps0 = replace(comps0, ",", "~");
      
      list = split(comps0 , "~");
      list2 = split(comps[1], ",");
      /*
      print "###";
      print list[0];
      compVal = comps[0];
      print compVal;
      print len(compVal);
      print findinarray(list, compVal);
      print "###";
      // comment out here so that we can have multiple values in both side.
      if ( not(numbers) and findinarray(list, item) <> -1 ) {
          clauseTrue = true;
          break;
        }
      */
      for item in list2 {
        if ( not(numbers) and findinarray(list, item) <> -1 ) {
          clauseTrue = true;
          break;
        }
      }
      if ( clauseTrue ) {
        break;
      } 
    }
    elif ( thisOp == notContainOp ) {     // Newly added: not contains 
     if ( debug ) { print thisOp; }
      comps0 = comps[0];
      comps0 = replace(comps0, ",", "~");
      
      list = split(comps0 , "~");
      list2 = split(comps[1], "~");

     if ( debug ) { print list; }
     if ( debug ) { print list2; }
     if ( debug ) { print clauseTrue; }
	 
	 clauseTrue = false;
      for item in list2 {
        if ( not(numbers) and findinarray(list, item) == -1 ) {
          clauseTrue = true;
          if ( debug) {print numbers;}
          if (debug) {print clauseTrue ;}
        }
      }
      
    } 
    if(debug){print("current truth: " + string(clauseTrue));}
    j = j+1;
  }
  if(not(clauseTrue)) {
    return "FALSE";
  }
}
return "TRUE";]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4958905</id><bm_lib_func_id>4958903</bm_lib_func_id><param_name><![CDATA[expression]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_evalNoMath.bm_lib_func_param_expression_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4958906</id><bm_lib_func_id>4958903</bm_lib_func_id><param_name><![CDATA[attrs]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>13</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_evalNoMath.bm_lib_func_param_attrs_13]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>405584593</id><name><![CDATA[Get Hiding Status For Service Partner Type]]></name><variable_name><![CDATA[getHidingStatusForServicePartnerType]]></variable_name><description><![CDATA[CSYS-82704]]></description><return_type>4</return_type><func_type>1</func_type><function_id>405584592</function_id><date_modified>1665163107000</date_modified><guid><![CDATA[bm_lib_func_util_getHidingStatusForServicePartnerType]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>405584592</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getHidingStatusForServicePartnerType_1]]></java_class_name><child_class_names></child_class_names><date_modified>1665163107000</date_modified><guid><![CDATA[659609c2-da00-43ac-88ce-cc2afd54d1e4]]></guid><script_size>392</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/* util - Get Hiding Status

coreOffering - String
implementationMethod - String
serviceAttr - String
*/
availibilityArray = String[];
//ownerBusUnit = "%"+ ownerBusinessUnit +"%";
//theater = "%"+ ownerTheater +"%";
//market = "%"+ ownerMarket +"%";
type = "%"+ quoteType +"%";
partnerType = "";

//(AP 22-09-2022) CSYS-107019 BMI:  Update util.getHidingStatusForServicePartnerType to use ServicePartnerTypeCIP
if(accntSvcPartnerType == ""){
	partnerType = "FALSE";
}
else{
	partnerType = "TRUE";
}

recordSet = bmql("select availability from serviceCompatibility where coreOffering = $coreOffering and serviceAttr = $serviceAttr and accntServPrtnrTypCIP = $partnerType and (quoteType like $type or quoteType = '' or quoteType is null)");


for rec in recordSet
{
	append(availibilityArray, get(rec,"availability"));
}

if((findinarray(availibilityArray,"TRUE")>-1)) //or(isempty(availibilityArray)==True))
{
	return false;
}
else
{
	return true;
}]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>405584594</id><bm_lib_func_id>405584593</bm_lib_func_id><param_name><![CDATA[coreOffering]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1665163107000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusForServicePartnerType.bm_lib_func_param_coreOffering_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>405584595</id><bm_lib_func_id>405584593</bm_lib_func_id><param_name><![CDATA[serviceAttr]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1665163107000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusForServicePartnerType.bm_lib_func_param_serviceAttr_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>405584596</id><bm_lib_func_id>405584593</bm_lib_func_id><param_name><![CDATA[quoteType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1665163107000</date_modified><order_no>3</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusForServicePartnerType.bm_lib_func_param_quoteType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>405584597</id><bm_lib_func_id>405584593</bm_lib_func_id><param_name><![CDATA[accntSvcPartnerType]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>2</datatype><date_modified>1665163107000</date_modified><order_no>4</order_no><guid><![CDATA[bm_lib_func_util_getHidingStatusForServicePartnerType.bm_lib_func_param_accntSvcPartnerType_2]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func><bm_lib_func><id>4963253</id><name><![CDATA[getPIBasedProductPricingData]]></name><variable_name><![CDATA[getPIBasedProductPricingData]]></variable_name><description></description><return_type>15</return_type><func_type>1</func_type><function_id>4963252</function_id><date_modified>1508547400000</date_modified><guid><![CDATA[bm_lib_func_util_getPIBasedProductPricingData]]></guid><folder_id>4133367</folder_id><namespace></namespace><func_override_id>-1</func_override_id><namespace_permissions>0</namespace_permissions><std_sys_obj>0</std_sys_obj><std_function>0</std_function><main_script_text></main_script_text><_children><bm_function><id>4963252</id><ref_type>16</ref_type><java_class_name><![CDATA[com.bm.xchange.bmscript.bmllib.util.LibFunction_getPIBasedProductPricingData_1]]></java_class_name><child_class_names></child_class_names><date_modified>1594435908000</date_modified><guid><![CDATA[LEGACY_4963252]]></guid><script_size>698</script_size><std_sys_obj>0</std_sys_obj><script_text><![CDATA[/*
	BML Utility Library
	getPIBasedProductPricingData
	----------------------------
	Params:
		String[] partNumList
		String[]Dict piBasedProductPricingDict
	Returns:
		StringDict result
			rowCount => number of records returned
	
	Description:
		For a given list of Part Numbers, return all Product Based Pricing
		conditions within the list of Part Numbers. condPI1, condPI2 and
		discountPI must all exist within the list of part numbers (otherwise
		there is no point!).
*/
result = dict("string");

productBasedDiscountConditions = bmql("select condPI1, condPI2, discountPI, discountVal, discountType, listPricePI from productBasedDisc where condPI1 in $piList and condPI2 in $piList and discountPI in $piList and listPricePI in $piList");

index = 0;
for record in productBasedDiscountConditions {
	
	row = string[];
	
	append(row, get(record, "condPI1"));
	append(row, get(record, "condPI2"));
	append(row, get(record, "discountPI"));
	append(row, get(record, "discountVal"));
	append(row, get(record, "discountType"));
	append(row, get(record, "listPricePI"));
	
	put(piBasedProductPricingDict, index, row);
	
	index = index + 1;
}

put(result, "rowCount", string(index));

return result;]]></script_text><_children></_children></bm_function><bm_lib_func_param><id>4963255</id><bm_lib_func_id>4963253</bm_lib_func_id><param_name><![CDATA[piList]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>9</datatype><date_modified>1508547402000</date_modified><order_no>1</order_no><guid><![CDATA[bm_lib_func_util_getPIBasedProductPricingData.bm_lib_func_param_piList_9]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param><bm_lib_func_param><id>4963256</id><bm_lib_func_id>4963253</bm_lib_func_id><param_name><![CDATA[piBasedProductPricingDict]]></param_name><ref_id>-1</ref_id><param_location>0</param_location><param_type>-1</param_type><datatype>16</datatype><date_modified>1508547402000</date_modified><order_no>2</order_no><guid><![CDATA[bm_lib_func_util_getPIBasedProductPricingData.bm_lib_func_param_piBasedProductPricingDict_16]]></guid><std_sys_obj>0</std_sys_obj></bm_lib_func_param></_children></bm_lib_func></_children></bm_lib_func_zip_deploy>