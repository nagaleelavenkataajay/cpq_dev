/* // PROD SITE.
        ==========================================================================
        | COMMERCE BML LIBRARY                                                   |
        +------------------------------------------------------------------------+
        | Pricing                                                                |
        ==========================================================================


        TERMINOLOGY
        ==========================================================================
        This section explains any non-standard variable naming conventions used
        in this script.

        +------------------------------------------------------------------------+
        | pi (PI)                                                                |
        +------------------------------------------------------------------------+
        | Abbrev. for "Priceable Item". For the purposes of BigMachines, this    |
        | is analagous to the Part Number.                                       |
        |                                                                        |
        +------------------------------------------------------------------------+
        | lineItemKey, <commerce_field_name>key                                  |
        +------------------------------------------------------------------------+
        | A term used to describe a dictionary key used for identifying          |
        | individual attributes. It is always in this format:                    |
        |   <document_number><DELIMITER><commerce_field_name>                    |
        | E.g. 3[@.@]tierPrice                                                   |
        |                                                                        |
        | In the case where a specific commerce field is mentioned, e.g.         |
        | tierPrice_line, this will be called "tierPriceKey"                     |
        |                                                                        |
        +------------------------------------------------------------------------+
        | pricingKey                                                             |
        +------------------------------------------------------------------------+
        | A term used to describe a dictionary key used for pricing util         |
        | functions. It is always in this format:                                |
        |   <pi><DELIMITER><qty_or_transactions>                                 |
        | E.g. 51840095[@.@]300                                                  |
        |                                                                        |
        +------------------------------------------------------------------------+
        | isGrouped                                                              |
        +------------------------------------------------------------------------+
        | In this script, this flag denotes the "isPartOfPackage_line" property  |
        | used by the end-user to indicate whether they wish to Dynamically      |
        | Group the line item. "isPartOfPackage" is just too verbose.            |
        |                                                                        |
        +------------------------------------------------------------------------+

        TABLE OF CONTENTS
        ==========================================================================
        i.  CONSTANTS -------------------------------------------- [CONSTANTS]
        ii. GLOBAL VARIABLES ------------------------------------- [VARIABLES]
        iii.GLOBAL CONTAINERS ----------------------------------- [CONTAINERS]

    */


/* Parameters to this function
actionName
triggerDict -  structure is (dict, key, key+TRIG_KEY_VALUE_DELIM+value)
                -   This is built in pricing and used in Approval library.
                - This structure is required so that the keys can be used later in Approval Library function

attributesDict - This dictionary contanis all the Quote and Line level attributes and their values
               - This is built in pricing and approval libraries and is passed to setAttributes library to form the final return string.
*/

stringsDict = dict("string");
floatsDict = dict("float");
integersDict = dict("integer");
result = "";
debug = false;
//add on related
assetsRet = "";
debugAssets = false;
debugActionChange = false;
keyDelim = "~";
delim = "|";

/* ======================================================================== */
/*                              CONSTANTS [CONSTANTS]                       */
/* ======================================================================== */
NUM_DECIMAL_USD = 2;
// HUNDRED_PERCENT = 100.0;

DATE_FORMAT_PREFERENCE_HYPHEN = "yyyy-MM-dd"; //substring(_system_user_date_pref, 0, 10);
DATE_FORMAT_PREFERENCE_SLASH = "MM/dd/yyyy";
NUM_CUSTOM_GROUPS = 6;
TILDE_DELIMITER = "~";
DELIMITER = "@.@";
ACTION_DELIMITER = "*@*";
TRUE_STR = "true";
FALSE_STR = "false";
TRIG_KEY_VALUE_DELIM = "$,$";

RAMP_FLAG_MULTIPLIER = 12;
PRICELIST = "";
TRANSACTION_XML_NODE_NAME = "transactions"; //This value must match the node name of the "transactions" node on the Ramp Plan XML
QUOTE_NUMBER = "quoteNumber_quote";

//add on related
INTERNAL_DELIMITER = "$$";
ASSET_DELIMITER = "@@";

INCREMENTAL_TRANSACTION_DEFAULT = 1;
//APPROVAL_STEP = "underManagerReview_process";

/* ------------------------- Constants for Promotions   ----------------------- */
// PROMO_CODES_LINE = "promotionCode_line";
// PROMO_DETAILS = "promotionDetails_line";
// PROMO_DETAILS_STR = "promotionDetailsStr_line";
PROMO_DISC_PERCENT = "promoDiscPercent_line";
PROMO_PRICE = "promoPrice_line";


/* -------------------- Constants for quote level Attributes ---------------- */
REGION = "ownerRegion_quote";
BUSINESS_UNIT = "ownerBU_quote";
THEATER = "ownerTheater_quote";
OWNER_TEAM = "ownerTeam_quote";
SEGMENT = "segment_quote";
PROMOTION_CODE = "promotionCode_quote";
MARKET = "ownerMarket_quote";
REVENUE_GROUP = "ownerRevenueGroup_quote";
ACCOUNT_VERTICAL = "accountVertical_quote";
CUSTOMER_TYPE = "customerType_quote";
QUOTE_TYPE = "quoteType_quote";
EXTERNAL_PROMOTION = "externalPromotion_quote";
QUOTE_DOC_NUM = "1";
SYSTEM_DATE = "_system_date";
CONVERSION_RATE = "conversionRate_quote";
NUM_DECIMALS = "numDecimals_quote";
BILLING_EXT_NET_PRICE  = "billingExtNetPrice_line";
RAMP_PLAN_QUOTE_DETAILS = "rampPlanDetails_quote";
TOTAL_CIP_SETUP_FEE = "totalCIPSetupFee_quote";//CSYS-96801 (LN. 8-23-2019)

RAMP_PARENT_NODE = "rampPlanDetail";
QUOTE_HAS_PREPROD_FEE = "quoteHasPreProductionFees_quote";
oRGNumCommittedTrans = 0;
// QUOTE_CURRENCY = "quoteCurrency_quote";
// COUNTRY_ISO_CODE = "billTo_countryISOCode_quote";


/* -------------------- Constants for Line Item Attributes ---------------- */
PART_NUM = "_part_number";
// DESCRIPTION = "lineDescription_line";
SEQ_NUM = "_sequence_number";
// DOC_NUM = "_document_number";
PARENT_DOC_NUM = "_parent_doc_number";
IMPLEMENTATION_METHOD = "implementationMethod_line";
CORE_OFFERING = "coreOffering_line";
EDITION_LINE = "edition_line";
ADV_LEARNING_SERVICES_REQUIRED = "advLearningSvcsReqd_line";
// APPROVAL_LINE_TRIGGER = "approval_line";//Nov 6- Move this to Approval Lib
// ADDL_DISC_DISALLOWED = "addlDiscDisallowed_line";

QTY = "_price_quantity";
TRANSACTIONS = "numCommittedTransaction_line";
// TRANSACTION_BY_BC = "transactionsBC";
// BASE_INC_KEY = "baseIncKey";
// PREV_TRANSACTIONS = "prevNumCommittedTransaction_line";
// PREV_TRANSACTIONS_AUTO = "prevTransactionsAuto_line";
// PREV_DISCOUNT = "prevDiscount_line";
ORIGINAL_TRANSACTIONS = "originalNumCommittedTransaction_line";
IS_TRANS_OVERRIDDEN = "numTransOverride_line";
IS_GROUPED = "isPartOfPackage_line"; //This form field is checked if the user wishes to DYNAMICALLY GROUP this line item
IS_UNITBASED = "unitBasedTransaction";
TRANS_VALIDATION_APPLIES = "transValidationApplies"; //CSYS-70683
DISCOUNT = "discount_line";
// DISCOUNTHIDDEN = "discountHidden_line";
DISCOUNT_TYPE = "discountType_line";
PERCENTAGE_DISCOUNT_TYPE = "%";
AMOUNT_DISCOUNT_TYPE = "Amt";
DISCOUNT_AMOUNT = "discountAmt_line";
DISCOUNT_PERCENT = "discountPercent_line";
LONG_DISCOUNT = "longDiscount_line";
CIP_SETUP_FEE = "cIPSetupFee_line";//CSYS-96801 (LN. 8-23-2019)
CIP_PRODUCT = "cipProduct_line";//CSYS-96801 (LN. 8-23-2019)

TERM_BASED_DISC = "termBasedDiscount_line";
//add on related
// ASSETS_NUM_OF_TRANSACTIONS = "assetOriginalOfCommittedMonthlyTransactions_line";
ASSETS_ORIGINAL_DISCOUNT = "assetsOriginalDiscount_line";
ASSETS_ADJUSTED_ARR = "assetAdjustedArr_line";
ASSETS_ORIGINAL_PI = "assetOriginalPI_line";
ASSETS_ORIGINAL_PO = "assetOriginalPO_line";
ASSETS_ORIGINAL_NET_PRICE = "assetOriginalNetPrice_list";
ASSETS_ORIGINAL_LIST_PRICE = "assetOriginalListPrice_list";
ASSETS_ORIGINAL_EXT_NET_PRICE = "assetOriginalExtendedNetPrice_list";
ASSETS_ORIGINAL_EXT_LIST_PRICE = "assetOriginalExtendedListPrice_list";
ASSETS_ORIGINAL_BUNDLE_ID = "originalBundleID_line";
ASSETS_ORIGINAL_IS_GROUPED = "assetOriginalGroupCheck_line";
ASSETS_ORIGINAL_TIER_PRICE = "assetOriginalTierPrice_line";//CSYS-95251
CORE_ASSET_SERVICEID = "coreAssetServiceId";
INCREMENTAL_FEE_LIST = "incrementalFeeList";
INCREMENTAL_FEE_LIST_USD = "incrementalFeeListUSD";
// Added by Jim Vey Case 124022
INCREMENTAL_FEE_NON_UNIFIED_LIST = "increFeeNonUnifiedList";
INCREMENTAL_FEE_NON_UNIFIED_LIST_USD = "increFeeNonUnifiedListUSD";
//End Case 124022
INCREMENTAL_FEE_NET = "incrementalFeeNet";
INCREMENTAL_FEE_NET_USD = "incrementalFeeNetUSD";
INC_FEE_NON_UNIFIED_NET = "increFeeNonUnifiedNet";
// BASE_FEE_NET_NON_UNIFIED = "baseFeeNonUnifiedNet";
INC_FEE_NON_UNIFIED_NET_USD = "increFeeNonUnifiedNetUSD";
// BASE_FEE_NET_NON_UNIFIED_USD = "baseFeeNonUnifiedNetUSD";

MODEL_FORCE_GROUPING = "modelForceGrouping";
//Ramp plan attribute variable names
RAMP_PLAN_OVERRIDE = "overrideDefaultRampPlan_line";
RAMP_PLAN_DETAIL = "rampPlanDetails_line";

RAMP_PLAN_DETAIL_SAVE_XML = "rampPlanDetailXMLSave_line";
RAMP_DELIMITER = "-_**_-";
PO_DELIMITER = "***";
PO_GROUPS_TRANS = "poGroupsInModelTrans";
PO_GROUPS_DYNAMIC_GROUPING = "poGroupsDynamicGrouping";
PO_RAMP_OVERRIDE = "poRampOverride";
PRIMARY_BASE_FEE = "primaryBaseFee";
ROLLUP_DOC_NUM = "rollupDocNum";
TRANS_STRING = "transString";
FROM = "from";
TO = "to";

//Pricing Attribute Variable Names
TIER_PRICE = "tierPrice_line";
EXT_TIER_PRICE = "extTierPrice_line";
PROD_BASED_PRICE = "productBasedPrice_line";
// PROD_BASED_PRICE_USD = "extProductBasedPriceUSD_line";
EXT_PROD_BASED_PRICE = "extProductBasedPrice_line";
TERM_BASED_PRICE = "termBasedListPrice_line";
EXT_TERM_BASED_PRICE = "extTermBasedListPrice_line";
// BASE_LIST_PRICE_UNIFIED = "listPriceUnified";
// BASE_LIST_PRICE_UNIFIED_USD = "listPriceUnifiedUSD";    //Heidi add 1/7/2014
LIST_PRICE = "listPrice_line";
EXT_LIST_PRICE = "extendedList_line";
LIST_PRICE_USD = "listPriceUSD_line";
EXT_LIST_PRICE_USD = "extListPriceUSD_line";
CUSTOM_LIST_PRICE = "customListPrice_line";
ARR_LINE = "arr_line";
// ARR_NET = "arrNet_line";
// PROD_ROLL = "productBasedPriceRollUp";
NET_PRICE = "netPriceEach_line";
ORIG_NET_PRICE = "origNetPriceEa_line";
NET_PRICE_USD = "netPriceUSD_line";
EXT_NET_PRICE_USD = "extNetPriceUSD_line";
EXT_NET_PRICE = "extendedNetPrice_line";
NET_PRICE_NON_UNIFIED = "netPriceNonUnified_line";
EXT_NET_PRICE_NON_UNIFIED = "extNetPriceNonUnified_line";
NET_PRICE_UNIFIED = "netPriceUnified_line";
EXT_NET_PRICE_UNIFIED = "extNetPriceUnified_line";
NET_PRICE_NON_UNIFIED_USD = "netPriceNonUnifiedUSD_line";
EXT_NET_PRICE_NON_UNIFIED_USD = "extNetPriceNonUnifiedUSD_line";
NET_PRICE_UNIFIED_USD = "netPriceUnifiedUSD_line";
EXT_NET_PRICE_UNIFIED_USD = "extNetPriceUnifiedUSD_line";
LIST_PRICE_NON_UNIFIED = "listPriceNonUnified_line";
EXT_LIST_PRICE_NON_UNIFIED = "extListPriceNonUnified_line";
LIST_PRICE_NON_UNIFIED_USD = "listPriceNonUnifiedUSD_line";
EXT_LIST_PRICE_NON_UNIFIED_USD = "extListPriceNonUnifiedUSD_line";
PACKAGE_ID = "package_line";
SUBSCRIP_ID = "subscriptionID_line";
BUNDLE_ID = "bundleID_line";
EXT_NET_PER_BILLING_PERIOD = "extNetPricePerBillingPeriod_line";
NUM_TRANSACTIONS_PER_BILLING_PERIOD = "numTransPerBillingPeriod_line";
// RAMP_PLAN_MESSAGE = "rampPlanMessageText_line";
TIER_CHANGE = "tierChange_line";
CUSTOM_PRICING_HAS_OCCURED = "customPricingHasOccured_line";//CSYS-85811 (LN. 9/27/2017)

// Used for Base Fee that are not rampable to unify
RAMP_PRICE_FOR_NON_RAMPABLE_BASE = "rampPriceForNonRampableBase";

MODEL_PO_PRIORITY = "poPriority_concur";
// EXT_NET_UNGROUPED = "extNetPriceUngrouped_line";
// NET_UNGROUPED = "netPriceUngrouped_line";
// NUMBER_RAMP_ENTRIES = "numRampEntries";
MODEL_HAS_GROUPING = "modelHasGrouping_line";
// CORE_TRANSACTIONS = "coreTransactions";
TRANSACTION_RATIO = "transactionRatio";
INCREMENTAL_FEE_RATIO_VALUE = "incrementalFeeRatioValue";
// MODEL_TRANSACTION_OVERRIDE = "modelTransactionOverride";
// LINE_TRANSACTION_OVERRIDE = "lineTransactionOverride";
// CUSTOM_SEQ_NUM = "lineOrderCustom_line";
// TANDM_FLAG = "tandmFlag_line";
AUDIT_TRANSACTION_DEFAULTED = "auditTransactionsDefaulted_line";

/* ------------------------ Constants for XML ----------------------------- */
// BASE_FEE_LIST_XML = "baseFeeList";
// BASE_FEE_NET_XML = "baseFeeNet";
// INC_FEE_LIST_XML = "increFeeList";
// INC_FEE_NET_XML = "increFeeNet";
// BASE_FEE_LIST_XML_USD = "baseFeeListUSD";
// BASE_FEE_NET_XML_USD = "baseFeeNetUSD";
// INC_FEE_LIST_XML_USD = "increFeeListUSD";
// INC_FEE_NET_XML_USD = "increFeeNetUSD";
// BASE_FEE_LIST_NON_UNIFIED_XML = "baseFeeListNonUnified";
// BASE_FEE_LIST_NON_UNIFIED_USD_XML = "baseFeeListNonUnifiedUSD";
// INC_FEE_LIST_NON_UNIFIED_XML = "incFeeListNonUnified";
// INC_FEE_LIST_NON_UNIFIED_USD_XML = "incFeeListNonUnifiedUSD";
INCREMENTAL_PI = "incrementalPi";
// INCREMENTAL_UOM = "incrementalUOM";
IS_RAMPABLE = "isRampable";
// Store the incremental fee for a PO for use with the base fee XML
INCREMENTAL_FEE_FOR_PO = "incrementalFeeForPO";
/* ------------------------ Constants for Part Fields --------------------- */
// PART_DESC = "description";

//Constants for part custom field names
PO_ID = "poId_line";
PO_NAME = "poName_line";
PO_START_DATE = "poStartDate_line";
PO_END_DATE = "poEndDate_line";
PI_ITEM_TYPE = "piItemType_line";
USAGE_QUALIFCATION_GROUP = "usageQualificationGroup_line";
TERM_OF_COMMITMENT = "termOfCommitment_line";
EDITION = "edition_line";
PARAMETER_ID = "parameterId_line";
RAMP_FLAG = "rampFlag_line";
SPECIAL_WORKFLOW_FLAG = "specialWorkflowFlag_line";
UOM_TYPE = "uomType_line";
ROLL_UP = "rollUp_line";
UOM_BLOCK = "uomBlock_line";
BUNDLE_FLAG = "bundleFlag_line";
PO_CATEGORY = "poCategory_line";
UNIT_OR_FIXED = "unitOrFixed_line";
ONE_DAY_SUB = "oneDaySub_line";//CSYS-83106 LN. 7/20/2017
//Constants for part custom field values
UOM_QTY = "QTY";
UOM_TRXN = "TRXN";
PCF_YES = "Y";
PCF_NO = "N";
CORE_SERVICE = "Core Service";
EXT_SERVICE = "Extended Service";
INCREMENTAL_FEE = "Incremental";
BASE_FEE = "Base";
SETUP_FEE = "Setup";
PRE_PRODUCTION = "Pre Prod";
USE_CUSTOM_PRICE = "useCustomPrice_line";
NON_RAMPABLE_BASE_INCREMENTAL_STRING = "nonRampableBaseIncrementalString";
//Mapping of Part Custom Field variable to display name
CUSTOM_FIELD_DICT = dict("string");
put(CUSTOM_FIELD_DICT, "custom_field1", PO_ID);
put(CUSTOM_FIELD_DICT, "custom_field2", PO_NAME);
put(CUSTOM_FIELD_DICT, "custom_field3", PO_START_DATE);
put(CUSTOM_FIELD_DICT, "custom_field4", PO_END_DATE);
put(CUSTOM_FIELD_DICT, "custom_field8", PI_ITEM_TYPE);
put(CUSTOM_FIELD_DICT, "custom_field9", USAGE_QUALIFCATION_GROUP);
put(CUSTOM_FIELD_DICT, "custom_field10", TERM_OF_COMMITMENT);
put(CUSTOM_FIELD_DICT, "custom_field11", EDITION);
put(CUSTOM_FIELD_DICT, "custom_field12", PARAMETER_ID);
put(CUSTOM_FIELD_DICT, "custom_field13", RAMP_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field14", SPECIAL_WORKFLOW_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field15", UOM_TYPE);
put(CUSTOM_FIELD_DICT, "custom_field21", ROLL_UP);
put(CUSTOM_FIELD_DICT, "custom_field18", UOM_BLOCK);
put(CUSTOM_FIELD_DICT, "custom_field19", BUNDLE_FLAG);
put(CUSTOM_FIELD_DICT, "custom_field20", PO_CATEGORY);
put(CUSTOM_FIELD_DICT, "custom_field22", UNIT_OR_FIXED);
put(CUSTOM_FIELD_DICT, "custom_field26", ONE_DAY_SUB);//CSYS-83106 LN. 7/20/2017

//CSYS-88632 (LN. 2/19/2018) New dictionaries and arrays used to indicate whether there has been a tier increase/decrease at each core
CORE_TIER_INCREASE = dict("string");
CORE_TIER_DECREASE = dict("string");
tierIncreaseArray = string[];
tierDecreaseArray = string[];

/* CSYS-87106 (LN. 1/23/2018) New dictionaries used to leverage the calculation of ARR when their is a CREATE/TERMINATE in the same Product Family AND a Tier Decrease */
PRODUCT_FAMILY_ARR_OFFSET = "PRODUCT_FAMILY_ARR_OFFSET";//CSYS-95591
TERMINATED_CORE_ASSET_EDITION = "TERMINATED_CORE_ASSET_EDITION";//CSYS-95591
PRODUCT_FAMILY = "productFamily_line";//CSYS-95591
LINE_COMMENT_ASSET_STRING = "lineItemComment_line";//CSYS-95591
EXISTING_ARR_CURRENCY_LINE = "existingARRCurrency_line";
PRODUCT_FAMILY_DICT = dict("string");
PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT = dict("integer");
PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT = dict("integer");
PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT = dict("integer");//CSYS-95591
PRODUCT_FAMILY_TRXN_DICT = dict("integer");
PROD_FAM_TIER_DECREASE_OCCURRED_DICT = dict("string");
//@@@@@@@@@@
productFamilyCreateArray = string[];//CSYS-98152
productFamilyTerminateArray = string[];//CSYS-98152

//CSYS-93247 (LN. 9-11-2018) Establishing constants for work related to defaulting transactions for Audit products when sold with Detect
POLICY_AUDIT_PO = "644";
CONCUR_DETECT_PO = "3780125";
AUDIT_ELITE_PO = "34954";
//CSYS-93972 (LN. 12-5-2018)
AUDIT_48_HOUR_POLICY_AUDIT_PO = "4388629";
AUDIT_48_HOUR_RECEIPT_AUDIT_PO = "4388615";
POLICY_RECEIPT_AUDIT_TRXN_COUNT = "POLICY_RECEIPT_AUDIT_TRXN_COUNT";
RECEIPT_AUDIT_PO = "997";
PRIME_PACKAGE_PRESENT = "primePackagePresent";//CSYS-94167 & CSYS-94755 & CSYS-97827 & CSYS-97864
PARTNER_EXPANSION_SKU_PI = "4459125";//CSYS-97924 (MJ 1/13/2020)
PARTNER_IMPLEMENTATION_PI = "6845718"; //CSYS-98798 (MJ 5/19/2020)
policyAuditExists = false;
detectExists = false;
auditEliteExists = false;
triggerAuditDefaultTrxn = false;
auditTrxnDefaulted = false;


/* ------------------------- Constants for Parameters --------------------- */
// USER_GROUPS = _system_user_groups;
// USER_GROUPS_LIST = split(USER_GROUPS, "+");
// DOCUMENT_CURRENCY_PREF = _system_current_document_currency_pref;
QUOTE_TRANSACTIONS = numCommittedTransaction_quote;
PAST_QUOTE_TRANSACTIONS = previousOfMonthlyTransactions_quote;
QUOTE_LEVEL_RAMP_PLAN = rampPlanDetails_quote;
//DC CSYS-93150
if (util.isDigitalCommerceTransaction(_system_user_login) /* AND numCommittedTransaction_quote <> 0 */ AND NOT isnull(numCommittedTransaction_quote) AND QUOTE_LEVEL_RAMP_PLAN == ""){
    QUOTE_LEVEL_RAMP_PLAN = "<rampPlanDetails className='rampPlanDetails' rowCounterDisplayName='Ramp Plans' parentNodeName='rampPlanDetails' childNodeName='rampPlanDetail'>" + "\n" +
    "<rampPlanDetail rampPlanID ='1'>" + "\n" +
    "<from displayArray='undefined' displayName='From Months' readOnly='false'>1</from>" + "\n" +
    "<to displayArray='undefined' displayName='To Months' readOnly='true'>and beyond</to>" + "\n" +
    "<transactions displayArray='undefined' displayName='Transactions / Units' readOnly='false'>NUMOFTRXNS</transactions>" + "\n" +
    "</rampPlanDetail>" + "\n" +
    "</rampPlanDetails>";
    QUOTE_LEVEL_RAMP_PLAN = replace(QUOTE_LEVEL_RAMP_PLAN, "NUMOFTRXNS", string(QUOTE_TRANSACTIONS), 1);
}
// RAMP_PLAN_DETAILS_QUOTE = "rampPlanDetails_quote";
// QUOTE_RAMP_FROM_MONTHS = "quoteRampFromMonths_quote";
LINE_RAMP_FROM_MONTHS = "lineRampFromMonths_line";
QUOTE_RAMP_PLAN_TRANSACTION_RATIOS = float[];   //This is initialized in a later section
BASE_GROUPING_REQUIRED = "baseGroupedRequired"; //Flag used to designate that the base in a configuration must have its add to group flag checked.
CORE_HAS_SETUP = "coreHasSetup_line"; //@RC. Flag used to determine if a model's core offering has a setup fee, as additions with setup fees can only be grouped when true. CSYS-7458
/* --------------------- Constants for Config Attributes ------------------ */
CONFIG_IMPLEMENTATION_METHODS = "implementationMethods_concur";
CONFIG_CORE_OFFERING = "coreOfferings_concur";
NON_CORE_HAS_SETUP = "nonCoreHasSetup_line"; //CSYS-80655 LN 4/26/17 Flag used to determine whether an extended service or Professional Service has a Setup
UNIT_BASED_CAN_HAVE_INDEPENDENT_RAMP_PLAN = "unitBasedCanHaveIndependentRampPlan";//CSYS-95500

/* ======================================================================== */
/*                      GLOBAL VARIABLES [VARIABLES]                        */
/* ======================================================================== */
/* ------------------------------ Meta-Variables -------------------------- */
utilResultDict = dict("string");
utilResultFlag = false;
utilResultString = "";
utilResultInt = 0;
//utilResultFloat = 0;
unifiedExists = false;

/* ------------------------- Variables for Quote Totals ------------------- */
// totalArrNet = 0.0;            //Sum of all Rampable parts (Ext. Net Price * 12)
// totalArrList = 0.0;         //Sum of all Rampable parts (Ext. List Price * 12)
// totalOneTimeFeeNet = 0.0;   //Sum of all non-Ramp parts (Ext. Net Price)
// totalOneTimeFeeList = 0.0;  //Sum of all non-Ramp parts (Ext. List Price)
// totalExtendedListPrice = 0.0;
totalPromoDiscounts = 0.0;
// totalLineItemDiscounts = 0.0;
// totalExtendedNetPrice = 0.0;
// totalSetupFeeList = 0.0;
// totalSetupFeeNet = 0.0;
// totalBaseFeeList = 0.0;
// totalBaseFeeNet = 0.0;
// totalPreProductionFeeList = 0.0;
// totalPreProductionFeeNet = 0.0;
// totalIncrFeeList = 0.0;
// totalIncrFeeNet = 0.0;
totalCIPSetupFee = 0.0;//CSYS-96801 (LN. 8-23-2019)
QUOTE_TOTAL_EXISTING_ARR = 0.0;

greatestLineDisc = 0.0;

numOfTransactionsChangeDict = dict("float");//key - parent doc number; value - number of transactions of the of the core product.

/* ------------------------- Variables for assets management (add on) -------------------- */
MODIFY_ACTION = "MODIFY";
NONE_ACTION = "NONE";
TERMINATE_ACTION = "TERMINATE";
CREATE_ACTION = "CREATE";
ASSETS_LIST_PRICE = "ASSETS_LIST_PRICE";
configuredAssetsService = "";//a !^! delimited list of all ceonfigured service IDs
ASSET_ACTION = "assetAction_line";
ASSET_STRING = "assetString_line";

//add on initializations
poList = dict("string[]");// a dictionary containing an array of all participating POs for intelligence sorted by model (parent doc num)
fullPOlist = string[];// a full list of participating POs
//parentDNarray = string[];//an array containing all parent DocNums
addOnNumOfTrans = "-1";
ASSET_PID = 0;
ASSET_IS_BUNDLE = 2;
ASSET_EDITION = 3;
ASSET_SUBSCRIP_ID = 5; //CASE 121961 - 1/4/13
ASSET_COMMITED_TRNS = 7;
ASSET_EXT_NET_PRICE = 8;
ASSET_NET_PRICE = 9;
ASSET_CUSTOMER_CURRENCY_REV_REC = 10;
ASSET_EXT_LIST_PRICE = 11;
ASSET_LIST_PRICE = 12;
ASSET_DISCOUNT = 13;
ASSET_ORG_BUNDLE_ID = 14;
ASSET_NEXT_BILLING_DATE = 15;
ASSET_ADJUSTED_ARR = 17;
ASSET_SERVICE_ACCT_ID = 16;
ASSET_BILLING_ID = 19;
ASSET_TIER_PRICE = 20;//CSYS-95251
ASSET_LAST_TIER_DEC_DATE = 21;//CSYS-97861

displayARRCommissionsAlert = false;//CSYS-97861
isAddOnQuote = false;

NEW_BIZ = "New Business";
ADD_ON = "Add-On Business";
SMB_BU = "SMB BU";//CSYS-94167
PARENT_PRODUCT_POID_INDEX = "parentProductPOIDIndex";//CSYS-94381
PARENT_INDEX_DOC_NUM = "parentIndexDocNum";//CSYS-94381
IS_PRODUCTBASED = "productBasedTransaction_line";//CSYS-94381

acctPartnerDiscount = partnerDiscount_quote; //CSYS-68345

assetGroupMappingDict = dict("string");//key: model doc num
listOfCore = string[];//an array containing all the core products for competibility contraint
listOfIM = string[];//an array containing all implementation methods.

modelNumOfTransDict = dict("integer");//key: parentDocNum for num of trans constraint.
/* ------------------------- Variables to Recategorize -------------------- */
/* ------------------------- Variables to Recategorize -------------------- */
selectAccessLevel1Fee = 0.0;
selectAccessLevel2Fee = 0.0;
selectAccessLevel3Fee = 0.0;
selectAccessLevel4Fee = 0.0;
conversionRate = 0.0;
highestDiscountItemType = "";

groups = range(NUM_CUSTOM_GROUPS);
//groupNum = 0;

currentDateText = substring(datetostr(getdate()), 0, 10);
updateDateText = currentDateText;
createdDate = getdate();
if(createdDate_quote <> ""){
  updateDateText = substring(createdDate_quote, 0, 10);
}
currentDate = getdate();
if(find(currentDateText, "/") <> -1) {
    currentDate = strtojavadate(currentDateText, DATE_FORMAT_PREFERENCE_SLASH);
} else {
    currentDate = strtojavadate(currentDateText, DATE_FORMAT_PREFERENCE_HYPHEN);
}
if(find(updateDateText, "/") <> -1) {
    //updateDate = strtojavadate(updateDateText, DATE_FORMAT_PREFERENCE_SLASH);
    createdDate = strtojavadate(updateDateText, DATE_FORMAT_PREFERENCE_SLASH); //For ramp deletion upgrade
    //updateDate = adddays(updateDate, adminNumDayRefreshPartDB_quote);
} else {
    //updateDate = strtojavadate(updateDateText, DATE_FORMAT_PREFERENCE_HYPHEN);
    createdDate = strtojavadate(updateDateText, DATE_FORMAT_PREFERENCE_HYPHEN); //For ramp deletion upgrade
    //updateDate = adddays(updateDate, adminNumDayRefreshPartDB_quote);
}

/* ======================================================================== */
/*                      GLOBAL CONTAINERS [CONTAINERS]                      */
/* ======================================================================== */
/* ------------------------- Variables for Quote State -------------------- */
piList = string[];
docNumList = string[];

//Line Item Attribute Containers - these dictionaries are all keyed by docNum
piDict = dict("string");

//Pricing Containers - these dictionares are all keyed by the pricingKey: <pi><DELIMITER><qty_or_num_transactions>
piQtyAndImplementationMethodToPriceDict = dict("float");

//Containers for mapping Models to associated data
modelToLineDocNumsDict = dict("string[]");
modelToLinePartNumsDict = dict("string[]");

//Special Containers
piQtyAndImplementationMethodDict = dict("string"); //A dictionary used for decomposed computations performed in util functions
piQtyAndImplementationMethodList = string[];
unifiedPricingDataDict = dict("string[]"); // Key: integer (Row Count), so that the application will be able to get all the rows from the dictionary.  Value: Each row data in the data table.
incrementalFeeTransactionDict = dict("integer"); // Key: String ( modelDocNum + DELIMITER + PO )
//maxItemType = dict("string[]");  // Key: Item Type

//Next billing Date and Asset Adjustment to ARR
quoteAssetArr = split(assetsString_quote, ASSET_DELIMITER );
assetBillingDict = dict("string");
assetAdjArrDict = dict("string");

for quoteAsset in quoteAssetArr{
    splitAsset = split( quoteAsset, INTERNAL_DELIMITER );
    assetPID = splitAsset[ASSET_PID];
    assetBillingDate = splitAsset[ASSET_NEXT_BILLING_DATE];
    put( assetBillingDict, assetPID, assetBillingDate );

    //CSYS-70966 part 1: parse the correct value for assetOriginalGroupCheck_line off the asset string:
    assetIsGrouped = splitAsset[ASSET_IS_BUNDLE];
    put( assetBillingDict, assetPID + "assetIsBundleKey", assetIsGrouped );

    assetAdjArr = splitAsset[ASSET_ADJUSTED_ARR]; //CSYS-46906 Part 1
    if(assetAdjArr <> ""){
        put( assetAdjArrDict, assetPID, assetAdjArr );
    }
}

/* ------------------------------------------------------------------------ */
/*                  Populate Error messages                                 */
/* ------------------------------------------------------------------------ */
errorDict = dict("string");
language = "en";
errorMsgs = bmql("SELECT messageCode, message FROM messageTable WHERE language = $language" );
for error in errorMsgs{
    put( errorDict, get( error, "messageCode" ), get( error, "message" ) );
}

/* ------------------------- Variables for Promotions   ----------------------- */
implementationMethodArr = string[];
partNumArr = string[];
invalidPromoMessage = "";
internalPromoDescDict = dict("string"); // key: promotion
externalPromoDescDict = dict("string"); // key: promotion
customerFriendlyPromoDescDict = dict("string"); // key: promotion
legalPromoDescDict = dict("string"); // key: promotion
promoCodeDescAndDetailsDict = dict("string");
promoResultsDict = dict("string");
promotionsDataDict = dict("string[]");
promoCodeApplied = "";
promoCodeDetails = "";

applicablePromotions = "";
autoAppliedPromotions = "";

/* ------------ Variables for PO that need to be grouped automatically  -------- */
/* ------------ Variables for POs that need to be Diff SOF Tempplate    -------- */
/* BM_VT. 07/05/2012. Added for Systematized Contracts Project */
/* Kevin Z. 052113. Updated to add Consulting Session, Site Review & Site Review Elite */
concurforceKey = "Concurforce";
premierTravelKey = "PremierTravel";
clientWebServiceKey = "ClientWebService";
meetingMgtKey = "meetingMgt";
intelRptKey = "IntelRpt";
singleCountryKey = "singleCountryExpReq";
multiCountryKey = "multiCountryExpReq";
consultingSessionKey = "consultingSessionReq";
siteReviewKey = "siteReviewReq";
siteReviewEliteKey = "siteReviewEliteReq";

posToBeGrouped = util.isPOGrouped();
// ~944~893~914~4906~
posRequiringDiffSOFTemplate = dict("string");
concurforcePOs = "";
premierTravelPOs = "";
clientWebServicePOs = "";
intelRptPOs = "";
meetingMgtPOs = "";
singleCountryExpPOs = "";
multiCountryExpPOs = "";
consultingSessionPOs = "";
siteReviewPOs = "";
siteReviewElitePOs = "";

posRequiringDiffSOFTemplate = util.getPOsforConcurForceAndPremierTravelSOF();
if (containskey(posRequiringDiffSOFTemplate,concurforceKey)) {
    concurforcePOs = get(posRequiringDiffSOFTemplate,concurforceKey);
}
if (containskey(posRequiringDiffSOFTemplate,premierTravelKey)) {
    premierTravelPOs = get(posRequiringDiffSOFTemplate,premierTravelKey);
}
if (containskey(posRequiringDiffSOFTemplate,clientWebServiceKey)) {
    clientWebServicePOs = get(posRequiringDiffSOFTemplate,clientWebServiceKey);
}
if (containskey(posRequiringDiffSOFTemplate,meetingMgtKey)) {
    meetingMgtPOs = get(posRequiringDiffSOFTemplate,meetingMgtKey);
}
if (containskey(posRequiringDiffSOFTemplate,intelRptKey)) {
    intelRptPOs = get(posRequiringDiffSOFTemplate,intelRptKey);
}
if (containskey(posRequiringDiffSOFTemplate,singleCountryKey)) {
    singleCountryExpPOs = get(posRequiringDiffSOFTemplate,singleCountryKey);
}
if (containskey(posRequiringDiffSOFTemplate,multiCountryKey)) {
    multiCountryExpPOs = get(posRequiringDiffSOFTemplate,multiCountryKey);
}
if (containskey(posRequiringDiffSOFTemplate,consultingSessionKey)) {
    consultingSessionPOs = get(posRequiringDiffSOFTemplate,consultingSessionKey);
}
if (containskey(posRequiringDiffSOFTemplate,siteReviewKey)) {
    siteReviewPOs = get(posRequiringDiffSOFTemplate,siteReviewKey);
}
if (containskey(posRequiringDiffSOFTemplate,siteReviewEliteKey)) {
    siteReviewElitePOs = get(posRequiringDiffSOFTemplate,siteReviewEliteKey);
}

concurforceExistInQuote = FALSE_STR;
premierTravelExistInQuote = FALSE_STR;
clientWebServiceInQuote = FALSE_STR;
intelligenceReportInQuote = FALSE_STR;
concurFAVRExistInQuote = false;//CSYS-93973 (LN. 11-9-2018)

//@DS: 10/29/2012 Support single and multi country language on SOF
//Kevin Z: updated for Consulting Session, Site Review & Site Review Elite 05.21.13
singleCountryExpExistInQuote = FALSE_STR;
multiCountryExpExistInQuote = FALSE_STR;
consultingSessionExistInQuote = FALSE_STR;
siteReviewExistInQuote = FALSE_STR;
siteReviewEliteExistInQuote = FALSE_STR;

meetMgtInQuote = FALSE_STR;
unitBasedPOs = util.getUnitBasedRecurringServicesPI();
/*
###### CSYS-94381 (LN. 1-3-2018) ######

New logic for those FIXED priced Extended Services that need to match the Ramp Plan of their designated 'Parent' Extended Service

Example:
    1. The Audit 48 Hour SLA for Policy Audit Ramps MUST match Policy Audit's Ramp Plan
    2. The 'Parent/Child Product' relationship is stored in the ProductBasedRecServs table in BMI.
    3. This table is called via the utility library getProductBasedRecurringServicesPO() & returns a delimited String[]
        a. Example Return Statement: [977~4388615, ...] - [parentPoID~childPoID, ...]
*/
parentProductPOArr = String[];//Initialize a new array to store the Parent PO ID
childProductPOArr = String[];//Initialize a new array to store the Child PO ID

productBasedPOArr = util.getProductBasedRecurringServicesPO();

for eachEntry in productBasedPOArr {
    productBasedPO = split(eachEntry, TILDE_DELIMITER);
    //Append the Parent PO ID's to its corresponding array - the relationship between the data in the two arrays is associated with their matching index number
    append(parentProductPOArr, productBasedPO[0]);
    //Append the Child PO ID's to its corresponding array
    append(childProductPOArr, productBasedPO[1]);
}


/* End BM_VT 07/05/2012 */

/* ======================================================================== */
/*                      Initialize quote level constants                    */
/* ======================================================================== */

/* ------------- Initialize QUOTE_RAMP_PLAN_TRANSACTION_RATIOS ------------ */
quoteRampTransactionStrings = util.getXMLNodeValues(QUOTE_LEVEL_RAMP_PLAN, "transactions"); //This will be a string array, e.g. ["100", "200", "300", "400", "500"]
transactionValues = integer[];
maxValue = -1;

for transactionString in quoteRampTransactionStrings {
    if (isnumber(transactionString)) {
        transactionValue = integer(atof(transactionString));    //Immediately casting something like 100.23 with atoi() will throw an error. Casting a float will truncate the decimal.

        if (transactionValue > maxValue) {
            maxValue = transactionValue;
        }
        append(transactionValues, transactionValue);    //This will be an integer array, e.g. [100, 200, 300, 400, 500]
    }
}

index = 1;
for transactionVal in transactionValues {

    ratio = index / sizeofarray(transactionValues) * 1.0;   //If maxValue is not greater than zero, just default this to be proportional to the ramp level
    if (maxValue > 0 AND numCommittedTransaction_quote > 0) {
        ratio = transactionVal / (numCommittedTransaction_quote * 1.0);
    }
    else{
        ratio = 1.0;
    }

    append(QUOTE_RAMP_PLAN_TRANSACTION_RATIOS, ratio);
    index = index + 1;
}

// If the header level ramp plan is blank, we will use a ratio of 1.
// This is an exception to properly populate line level ramp values with an untouched header level ramp
if ( QUOTE_LEVEL_RAMP_PLAN == "" AND isempty( QUOTE_RAMP_PLAN_TRANSACTION_RATIOS )){
    append( QUOTE_RAMP_PLAN_TRANSACTION_RATIOS, 1.0 );
}

//Commenting out setting the final ramp to the number of committed transactions

outputDisplayRamp = FALSE_STR;
if( sizeofarray( quoteRampTransactionStrings) <> 0 ){
    if ( sizeofarray( quoteRampTransactionStrings ) > 1 ){
        outputDisplayRamp = TRUE_STR;
    }
    //CSYS-82292 (KA. 6-14-2017): populate quote ramp transactions on the first iteration:
    elif( sizeofarray( quoteRampTransactionStrings ) == 1 ){
        if(quoteType_quote == ADD_ON AND NOT firstIterationExecuted_quote){

            //Logic borrowed from addOnPopulation script to grab the first core base transactions from the asset string
            corePis = string[];
            corePIset = bmql("SELECT PI FROM PiToCoreOfferingMap");
            for entry in corePIset {
                tablePi = get(entry, "PI");
                append(corePis, tablePi);
            }

            //capture correct transactions to assign to quote ramp transactions:
            firstCoreBaseAssetTrans = 0;
            comment = split(assetsString_quote, ASSET_DELIMITER);
            count = 0;
            for eachindex in comment {
                assetArray = split(comment[count],INTERNAL_DELIMITER);
                if(NOT isnull(assetArray[7]) AND assetArray[4] == BASE_FEE AND findinarray(corePis, assetArray[0]) <> -1){
                    firstCoreBaseAssetTrans = util.customAtof(assetArray[7], 0.0);
                    orgQuoteTransactions = string(integer(firstCoreBaseAssetTrans));
                    quoteRampTransactionStrings = string[]{orgQuoteTransactions};
                    break;
                }
                count = count + 1;
            }

        }
    }
}

orgRampPlanDetails = "";
orgTerm = "";
QUOTE_LEVEL_RAMP_PLAN = util.spliceXMLNodeValuesExtended(QUOTE_LEVEL_RAMP_PLAN, TRANSACTION_XML_NODE_NAME, quoteRampTransactionStrings, RAMP_PARENT_NODE);

//CSYS-85637 09/20/2017 - Reverting code to original ramp logic
//CSYS-83099 08/17/17
/*
if (find(accountServicePartnerType_quote, "Certified Implementation Partner") <> -1 OR find(accountServicePartnerType_quote, "Customer Success Partner") <> -1){
    QUOTE_LEVEL_RAMP_PLAN = commerce.getRampXmlForServicePartnerQuote();
    if (waiveInitialCalendarYearFee_quote == true){
        put(stringsDict, "firstRampZero", "Yes");
    }
}
*/
utilResultFlag = util.putStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, RAMP_PLAN_QUOTE_DETAILS, QUOTE_LEVEL_RAMP_PLAN );

//CSYS-83099 08/17/17


/* ------------------------ Get Billing Cycle Number ---------------------- */
miscDataSet = bmql("SELECT miscDataKey FROM miscCommerceData WHERE miscDataVal = $billingCycle_quote" );
billingCycleNumber = "";
for dataValue in miscDataSet{
    billingCycleNumber = get( dataValue, "miscDataKey" );
}

/* ------------------------ Pricelist Selection --------------------------- */
businessUnit = ownerBU_quote;
companyName = _system_supplier_company_name;
currencyCode = quoteCurrency_quote;

currencyInformationDict = util.getCurrencyData( currencyCode );
numDecimals = 2;
CURRENCY_SYMBOL = "$";

countryIsoCode = "";
billingCountryCodeResSet = bmql("SELECT metraNetCountry FROM countryCodeMapping WHERE bmiCountry = $_quote_process_billing_country");
for billingCountryCodeRes in billingCountryCodeResSet {
  countryIsoCode = get(billingCountryCodeRes, "metraNetCountry");
}

/* ----------------------- Variables for correctly setting transactions of line items */
MODEL_TRANSACTIONS = "modelTransactions";
MODEL_NEW_TRANSACTIONS = "modelNewTransactions";
overwriteTransactionArr = String[];
// Incremental Fee transactions will be set to lineGlobalTransactions, then returned to 1 at the end.

/* ------------------------ END TRANSACTION VARS ----------------------------- */
if ( containskey( currencyInformationDict, "error" ) <> true ){
    numDecimals = util.customAtoi(get( currencyInformationDict, "numDecimals" ), 0);
    utilResultValue = util.putFloatAttribute( floatsDict, QUOTE_DOC_NUM, DELIMITER, CONVERSION_RATE, atof(get( currencyInformationDict, "conversionRate" ) ));
    utilResultValue= util.putIntegerAttribute( integersDict, QUOTE_DOC_NUM, DELIMITER, NUM_DECIMALS, util.customAtoi(get( currencyInformationDict, "numDecimals" ),0 ));
    CURRENCY_SYMBOL = get( currencyInformationDict, "currencySymbol" );
}

/*
    CSYS-95956 (LN. 6-5-2019) Moved this further up in Pricing, we need to evaluate the conversion rate sooner,
    to support the Pricebook increase for non-USD currency quotes.
*/
conversionRate = util.getFloatAttribute( floatsDict, QUOTE_DOC_NUM, DELIMITER, CONVERSION_RATE );

if ( conversionRate == 0.0 ){
    conversionRate = 1.0;
}

/* ======================================================================== */
/*                      Get Price List                                      */
/* ======================================================================== */
utilResultDict = util.getPriceList(companyName, businessUnit, currencyCode);

PRICELIST = get(utilResultDict, "pricelist");
//ownerTheater = ownerTheater_quote;
//ownerMarket = ownerMarket_quote;
quoteType = quoteType_quote;

//CSYS-83094 (KA. 8-7-2017):
quoteTheater = ownerTheater_quote;
quoteMarket = ownerMarket_quote;
//quoteVertical = accountVertical_quote;//CSYS-88979.  UPDATE:  OC 9.30.19 - Removing per CSYS-97295

if(partnerBillingQuote_quote){//CSYS-95097
    quoteTheater = accountArea_quote;
    quoteMarket = market_quote;
    PRICELIST = businessUnit_quote;
}

utilResultFlag = util.putStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, "priceList", PRICELIST );
utilResultFlag = util.putStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, "currencyCode", currencyCode );
utilResultFlag = util.putStringAttribute( stringsDict, QUOTE_DOC_NUM, DELIMITER, QUOTE_NUMBER, quoteNumber_quote );
/*if (debug) {
    printTempVal = util.printDebugHeader("Quote level attributes");
    printTempVal = util.printDebug("PRICELIST", PRICELIST, 0);
    printTempVal = util.printError(utilResultDict, 0);
    printTempVal = util.printDebug("quote level ramp plan", QUOTE_LEVEL_RAMP_PLAN, 0);
    printTempVal = util.printDebug("QUOTE_RAMP_PLAN_TRANSACTION_RATIOS", "", 0);
    print(QUOTE_RAMP_PLAN_TRANSACTION_RATIOS);
}*/

/* ======================================================================== */
/*                      Read all Line Item information                      */
/* ======================================================================== */

baseDiscountVal = 0.0;
incrementalDiscountVal = 0.0;
setupDiscountVal = 0.0;
preProdDiscountVal = 0.0;
baseDiscountFlag = true;
incrementalDiscountFlag = true;
setupDiscountFlag = true;
preProdDiscountFlag = true;

/* CSYS-6723: Bundle Core Service if other items are bundled
 * This loop: added flags to store true/false value on parent for whether the core service needs to be bundled.
 */
//Add the parent doc nums of each service
parentDocNumDict = dict("string");
baseDiscountValDict = dict("float");
baseDiscountTypeDict = dict("string");
incrementalDiscountValDict = dict("float");
incrementalDiscountTypeDict = dict("string");
setupDiscountValDict = dict("float");
setupDiscountTypeDict = dict("string");
preProdDiscountValDict = dict("float");
preProdDiscountTypeDict = dict("string");
assetCoreServiceTerminatedOrModified = false;
//Case 00180017 - Add temp dictionary to hold unbundled value for discounts
unbundledExtendedListPriceDict = dict("float");
//End 00180017 (1/3)
//ATG (1 of 1) Moved from below 1st loop to here to combine loops
/* case 85005 May 14 2012*/
/*BM_VT. Implementation Method is required at the quote level. */
ImplementationMethodFoundFlag = true;//Implementation Method is an attribute in configurator. we want to recieve it only from the first model
strImpMethod = "";

//for addons
hasPreprodFeeForAddons = false;

//########## Detect Core and Edition Changes within configuration ##########//
isCoreChangedDict = dict("string");
isEditionChangedDict = dict("string");
detectEditionAndCoreChanges = commerce.detectEditionAndCoreChanges(isCoreChangedDict,isEditionChangedDict);

hasIncDict = dict("string"); //For Unique PI Keys (CSYS-37711) part 1

//CSYS-61512. KA. 4-27-2016. Update: commenting out until further notice due to biz requirement change.
/*TandM_Dict = dict("string");
TandM_Rez = BMQL("SELECT TandM_PO, TandM_Attr, TandM_Product FROM TimeAndMaterials"); //Grab the list of TandM PO's and their related config attributes from the data table*/

//We need to make sure with cases like reconfigure core, swap core/edition, that docNums are iterated through in order.
//This applies to the 'for modelDocNum in docNumList' loops
//Therefore, the next 2 lines added for CSYS-75571 (KA. 1-19-2017):
seqNumAttributeMappingDict = dict("string");
seqNumArray = integer[];

//CSYS-85811 (LN. 9/27/2017) If submit for custom pricing is ran (therefore setting customPricingFlag_quote to 'true') put the value of 1 into the piQtyAndImplementationMethodToPriceDict dictionary to use for evaluation in the util.getStandTierPricing
if(customPricingFlag_quote){
    utilResultFlag = util.putFloatAttribute( piQtyAndImplementationMethodToPriceDict, "customPricingExecuted", DELIMITER, "customPricingExecuted", 1);
}
//CSYS-88388 - Start
coreTerminatesDict = dict("string");
familyCreateDict = dict("string");
familyTerminateDict = dict("string");
//CSYS-88388 - End

rampPriceOverrideArray = string[];//CSYS-89211 (LN. 2/22/2018) Initializing an array to be leveraged below to store how many line items are using the rampPriceOverride functionality
//CSYS-94164
//debugLogStr = debugLog_quote;
coreTerminateTrxnDict = dict("integer");
for line in line_process {
    docNum = line._document_number;
    //Added by Andre Must be able to deal with multiple models @ALFIX00126236
    parentDocNum = line._parent_doc_number;
    poCategory = line._part_custom_field20;
    assetAction = line.assetAction_line;
    familyName = line._part_custom_field23;
    numTrans = line.numCommittedTransaction_line;
    piItemType = line._part_custom_field8;
    //CSYS-88388 - Start
    isCoreChanged = get(isCoreChangedDict, parentDocNum);
    isEditionChanged = get(isEditionChangedDict, parentDocNum);
    if (poCategory == CORE_SERVICE AND assetAction == TERMINATE_ACTION AND (isCoreChanged == TRUE_STR OR isEditionChanged == TRUE_STR)){
        put(coreTerminatesDict, parentDocNum, TERMINATE_ACTION); //core has TERMINATE's and CREATE's. original core is getting replaced with another since there's a core/edition change.
        //CSYS-94164
        if (piItemType == BASE_FEE){
            put(coreTerminateTrxnDict, parentDocNum, numTrans);
        }
    }
    if (isnull(get(coreTerminatesDict, parentDocNum))){
        put(coreTerminatesDict, parentDocNum, "BLANK");
    }
    if (assetAction == CREATE_ACTION){ //if we run into a CREATE line
        put(familyCreateDict, familyName, assetAction); //family has CREATEs
    }
    if (assetAction == TERMINATE_ACTION){ //if we run into a TERMINATE line
        put(familyTerminateDict, familyName, assetAction); //Family has TERMINATEs
    }
    //CSYS-88388 - End
    //next 4 lines added for CSYS-75571 (KA. 1-19-2017):
    seqNum = line._sequence_number;
    seqNumStr = string(seqNum);
    put(seqNumAttributeMappingDict, seqNumStr + DELIMITER + "DOC_NUM", docNum);
    put(seqNumAttributeMappingDict, seqNumStr + DELIMITER + "PARENT_DOC_NUM", parentDocNum);
    append(seqNumArray, seqNum);

    reconfig = util.getConfigValue(line._config_attr_info, "reconfigure");

    if (reconfig <> ""){
        put( stringsDict, "reconfigure", reconfig );
    }
    //Store PO category at a dictionary key that won't get overwritten
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "_part_custom_field20" + "***", line._part_custom_field20);


    pi = line._part_number;
    po = line._part_custom_field1;
    poCat = line.poCategory_line;

    customPricingHasOccured = line.customPricingHasOccured_line;//CSYS-85811 (LN. 9/27/2017)
    customListPrice = line.customListPrice_line;//CSYS-85811 (LN. 9/27/2017)

    put(stringsDict, docNum + DELIMITER + PO_CATEGORY, poCat);

    if (piItemType == INCREMENTAL_FEE){
        put(hasIncDict, po, TRUE_STR);
    }

    isPartOfPackage = line.isPartOfPackage_line;
    assetActionFromGrid = line.assetAction_line;
    longDiscount = line.longDiscount_line;
    discountType = line.discountType_line;

    if (piItemType == ""){
        baseDiscountFlag = true;
        incrementalDiscountFlag = true;
        setupDiscountflag = true;
        preProdDiscountFlag = true;
    }

    poCategory = line._part_custom_field20;
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, CORE_HAS_SETUP, FALSE_STR); //@RC set core has setup to false by default for each model in case of reconfiguration from a service with setup to one without
    if(piItemType == BASE_FEE AND isPartOfPackage AND baseDiscountFlag AND poCategory == CORE_SERVICE){//Added 'AND poCategory == CORE_SERVICE' Case 119146 -AL

        baseDiscountVal = 1;
        put(baseDiscountValDict, parentDocNum, longDiscount);
        put(baseDiscountTypeDict, parentDocNum, discountType);
        baseDiscountFlag = false;
    }
    elif(piItemType == INCREMENTAL_FEE AND isPartOfPackage and incrementalDiscountFlag AND poCategory == CORE_SERVICE ){ //Added 'AND poCategory == CORE_SERVICE' Case 119146 -AL

        incrementalDiscountVal = 1;
        put(incrementalDiscountValDict, parentDocNum, longDiscount);
        put(incrementalDiscountTypeDict, parentDocNum, discountType);
        incrementalDiscountFlag = false;
    }
    elif(piItemType == SETUP_FEE AND isPartOfPackage and setupDiscountFlag AND poCategory == CORE_SERVICE){//Added 'AND poCategory == CORE_SERVICE' Case 119146 -AL

        setupDiscountVal = 1;
        put(setupDiscountValDict, parentDocNum, longDiscount);
        put(setupDiscountTypeDict, parentDocNum, discountType);
        setupDiscountFlag = false;
    }
    elif(piItemType == PRE_PRODUCTION AND isPartOfPackage and preProdDiscountFlag AND poCategory == CORE_SERVICE){//Added 'AND poCategory == CORE_SERVICE' Case 119146 -AL

        preProdDiscountVal = 1;
        put(preProdDiscountValDict, parentDocNum, longDiscount);
        put(preProdDiscountTypeDict, parentDocNum, discountType);
        preProdDiscountFlag = false;
    }

    if(isPartOfPackage){
        utilResultFlag = util.putStringAttribute(stringsDict, parentDocNum, DELIMITER, BASE_GROUPING_REQUIRED, TRUE_STR);
    }
    //Setting Core Service terminate flag for addons (core service first item in loop) Added by Andre Lancour @ALFIX00154530
    if(quoteType_quote == ADD_ON AND poCategory == CORE_SERVICE AND (assetActionFromGrid == TERMINATE_ACTION OR assetActionFromGrid == MODIFY_ACTION)) {
        assetCoreServiceTerminatedOrModified = true;
    }//Done adding By Andre Lancour @ALFIX00154530

    //CSYS-64174 part 1. KA. 5-26-2016. Update: commenting out until further notice due to biz requirement change.
    /*if(containskey(TandM_Dict, po + "attrKey") AND poCat == CORE_SERVICE AND piItemType == SETUP_FEE AND assetActionFromGrid <> TERMINATE_ACTION){
        put(stringsDict, parentDocNum + DELIMITER + "TandM_Flag", get(TandM_Dict, po + "attrKey"));
    }*/


    if(pi <> ""){
        //CSYS-69701:
        if(assetActionFromGrid == TERMINATE_ACTION AND line.isPartOfPackage_line <> line.assetOriginalGroupCheck_line AND line.assetOriginalGroupCheck_line)    {
            //original asset was manually terminated from grouping, so mark the core it was terminated from:
            put(stringsDict, parentDocNum + DELIMITER + "groupedAssetTerminatedFromCore", TRUE_STR);
        }
        //CSYS-71641 part 1: map transactions and create/terminate info (KA. 1-6-2017):
        if(poCategory == CORE_SERVICE AND piItemType == BASE_FEE AND assetActionFromGrid <> TERMINATE_ACTION){
            put(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans", numTrans);
        }
        if(poCategory == CORE_SERVICE AND piItemType == BASE_FEE AND assetActionFromGrid == CREATE_ACTION){
            put(stringsDict, parentDocNum + DELIMITER + "coreCreateWithinModel", TRUE_STR);
        }
        if(poCategory == CORE_SERVICE AND piItemType == BASE_FEE AND assetActionFromGrid == TERMINATE_ACTION){
            put(stringsDict, parentDocNum + DELIMITER + "coreTerminateWithinModel", TRUE_STR);
        }

        //CSYS-77853: map core action code to the model:
        if(poCategory == CORE_SERVICE AND assetActionFromGrid <> TERMINATE_ACTION){
            put(stringsDict, parentDocNum + DELIMITER + "coreActionCode", assetActionFromGrid);

            //CSYS-93247 (LN. 9-12-2018) Store the Core Service Base Fee Transaction amount
            if(piItemType == BASE_FEE){
                put(integersDict, parentDocNum + DELIMITER + "defaultAuditTrxn", numTrans);
            }
        }

        /*********capture all POs - sorted by parent doc number (add-on)***************/
        append(fullPOlist,po);//capture all POs, with no sorting

        if(customPricingHasOccured){//CSYS-85811 (LN. 9/27/2017) If pi <> "" (not a model) AND only when Custom Pricing has occured on a singular product put the customListPrice into the piQtyAndImplementationMethodToPriceDict dictionary to be used by util.getStandTierPricing
            utilResultFlag = util.putFloatAttribute( piQtyAndImplementationMethodToPriceDict, pi, DELIMITER, "customListPriceStdTierPricing", customListPrice );
        }

        //CSYS-86115 (put in the stringsDict the value of Override Price at the line ramp level. KA. 10-16-2017):
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "overrideRampPrice", line.overrideRampPrice_line);

        //CSYS-89211 (LN. 2/22/2018)
        overrideRampPrice = util.getStringAttribute( stringsDict, docNum, DELIMITER, "overrideRampPrice");

        //If the Override Ramp Price functionality is used on any line item, append the docNum to the rampPriceOverrideArray for later assessment
        if(overrideRampPrice == TRUE_STR){
            append(rampPriceOverrideArray, TRUE_STR);
        }

        //CSYS-86857 (KA. 11-9-2017):
        if(line.overrideDefaultRampPlan_line == TRUE_STR){
            if((poCategory == CORE_SERVICE AND line._part_custom_field21 == "Y") OR poCategory <> CORE_SERVICE){
                put(stringsDict, po + DELIMITER + "overrideDefaultRampPlanForPoID", TRUE_STR);
            }
        }

        //CSYS-93828 (LN. 2-24-2019) Set the outputSetupFee_line back to zero in Pricing to ensure language in Set Output Values script is set correctly
        utilResultString = util.formAttrValueStr(attributesDict, "outputSetupFee_line", docNum, string(0.0));

    }
}

//CSYS-89211 If the rampPriceOverrideArray has values, set the rampPriceOverride_quote attribute to TRUE
if(sizeofarray(rampPriceOverrideArray) > 0 ){
    utilResultString = util.formAttrValueStr(attributesDict, "rampPriceOverride_quote", QUOTE_DOC_NUM, TRUE_STR);
}
else {//Else, set this attribute to false
    utilResultString = util.formAttrValueStr(attributesDict, "rampPriceOverride_quote", QUOTE_DOC_NUM, FALSE_STR);
}

//CSYS-94033
coreTerminatesTrxnDict = dict("integer");
coreTerminateEditionDict = dict("string");//CSYS-95225 (LN. 3-28-2019)
//CSYS-95591
for line in line_process{
    pi = line._part_number;
    piItemType = line._part_custom_field8;
    assetAction = line.assetAction_line;
    lineItemComment = line._line_item_comment;
    poID = line.poId_line;//CSYS-93247 (LN. 9-11-2018)
    parentDocNum = line._parent_doc_number;
    poCategory = line._part_custom_field20;
    reconfig = get(stringsDict, "reconfigure");
    docNum = line._document_number;
    productFamily = line._part_custom_field23;


    //CSYS-94033
    if (piItemType == BASE_FEE AND poCategory == CORE_SERVICE AND assetAction == TERMINATE_ACTION){
        if (get(coreTerminatesDict, parentDocNum) == TERMINATE_ACTION){
            comment = split(lineItemComment,ASSET_DELIMITER);
            if(sizeofarray(comment)>1){

                assetString = comment[2];

                if(assetString <> ""){
                    currentAssetString = split(assetString,INTERNAL_DELIMITER);
                    originalTrxns = integer(atof(currentAssetString[ASSET_COMMITED_TRNS]));
                    assetEdition = currentAssetString[3];//CSYS-95225 (LN. 3-28-2019)

                    /* CSYS-95225 (LN. 3-28-2019)
                        In the event that there is a TERMINATE on a Core Edition Change with a Tier DECREASE,
                        We need to retain the original Core's Edition to pass into stdTierPricing, otherwise the pricing retrieved
                        is incorrect since the pi on the new Edition doesn't exist.
                    */
                    put(coreTerminateEditionDict, pi + DELIMITER + TERMINATED_CORE_ASSET_EDITION, assetEdition);
                    put(coreTerminatesTrxnDict, parentDocNum, originalTrxns);
                }
            }
        }
    }
    //CSYS-93247 (LN. 9-11-2018)
    if(poID == POLICY_AUDIT_PO AND assetAction == CREATE_ACTION){
        policyAuditExists = true;
    }

    //CSYS-93247 (LN. 9-11-2018)
    if(poID == AUDIT_ELITE_PO AND assetAction == CREATE_ACTION){
        auditEliteExists = true;
    }

    //CSYS-93247 (LN. 9-11-2018)
    if(poID == CONCUR_DETECT_PO AND assetAction <> TERMINATE_ACTION){
        detectExists = true;
    }
    //CSYS-94164
    if ( quoteType == ADD_ON AND (assetAction == CREATE_ACTION) AND poCategory == CORE_SERVICE AND containskey(coreTerminateTrxnDict, parentDocNum) AND reconfig == TRUE_STR AND containskey(triggerDict, "customActionName") AND containskey(triggerDict, "reconfiguredDocNum")){
        if (get(triggerDict, "customActionName") == "Reconfigure Inbound" AND get(triggerDict, "reconfiguredDocNum") == parentDocNum){
            put(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans", get(coreTerminateTrxnDict, parentDocNum));
        }
    }

    //CSYS-94381 (LN. 1-3-2019)
    if(findinarray(parentProductPOArr, poID) <> -1 AND assetAction <> TERMINATE_ACTION){//If a Parent POID is found on the quote, continue

        index = 0;

        for eachPO in parentProductPOArr {

            if(eachPO == poID AND piItemType == BASE_FEE){
                /*Store the index number of the Parent POID found in the parentProductPOArr.
                The index is how we will associate the corresponding Child PO below.
                If both the Parent POID & corresponding Child POID is found, ensure the Child's ramps match the Parent.*/
                put(integersDict, PARENT_PRODUCT_POID_INDEX + DELIMITER + string(index), index);
                put(stringsDict, childProductPOArr[index] + DELIMITER + PARENT_INDEX_DOC_NUM, docNum);
            }

            index = index + 1;
        }
    }
    //CSYS-95591
    utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, LINE_COMMENT_ASSET_STRING, lineItemComment);
    utilResultFlag = util.putStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY, productFamily);
}

//CSYS-93247 (LN. 9-11-2018)
if( (policyAuditExists OR (policyAuditExists AND auditEliteExists)) AND detectExists){
    triggerAuditDefaultTrxn = true;
    auditTrxnDefaulted = true;
}

//CSYS-95591
for line in line_process{
    pi = line._part_number;
    docNum = line._document_number;
    piItemType = line._part_custom_field8;
    assetAction = line.assetAction_line;
    docNum = line._document_number;
    //CSYS-94164
    poCategory = line._part_custom_field20;
    reconfig = get(stringsDict, "reconfigure");
    parentDocNum = line._parent_doc_number;
    poID = line.poId_line;//CSYS-94381 (LN. 1-3-2019)

    if( piItemType == BASE_FEE AND assetAction == TERMINATE_ACTION ){

        //CSYS-94164
        //CSYS-94682
        if (poCategory == CORE_SERVICE AND containskey(coreTerminateTrxnDict, parentDocNum) AND reconfig == TRUE_STR AND containskey(triggerDict, "customActionName") AND containskey(triggerDict, "reconfiguredDocNum") AND get(triggerDict, "reconfiguredDocNum") == parentDocNum){
            continue;
        }
    }

    //CSYS-94381 (LN. 1-3-2019)
    if(findinarray(childProductPOArr, poID) <> -1 AND assetAction <> TERMINATE_ACTION){//If a Child POID is found on the quote, continue

        index = 0;

        for eachPO in childProductPOArr {

            if(eachPO == poID AND get(integersDict, PARENT_PRODUCT_POID_INDEX + DELIMITER + string(index)) == index){
                /* If the Child POID's index matches the index of the Parent POID in the parentProductPOArr that is also on the quote,
                write to the productBasedTransaction_line attribute to indicate this Child Product POID will need to match the Parent Product Ramp Plan.*/
                utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_PRODUCTBASED, TRUE_STR);
            }

            index = index + 1;
        }
    }
}

sort(seqNumArray, "asc");

//make list of PIs that qualify for num of trans constraint
rez = BMQL("SELECT PO FROM trnsValidation WHERE PO in $fullPOlist");
listOfNumOfTransPOs = string[];
for entry in rez{
    poID = get(entry,"PO");
    append(listOfNumOfTransPOs,poID);
    put(stringsDict, poID + DELIMITER + TRANS_VALIDATION_APPLIES, TRUE_STR); //CSYS-70683
}

//CSYS-93675 (LN. 11-7-2018) Query this table only when the Edition; Establishing Constants/Arrays to be leveraged;
usOfferProfessionalOnlyArr = String[];
createProfessionalUniversalArr = String[];

if(find(implementationMethods_quote, "Universal") <> -1){
    //When Edition is Universal: Query the 'USOfferSimp' table and gather the poIDs for those Professional ONLY products
    //CSYS-98751, Phil S, 03/26/2020
    //universalPORes = BMQL("SELECT pONumber, edition FROM USOfferSimp");
    universalPORes = BMQL("SELECT pONumber, edition FROM UniversalOfferSimp");

    for entry in universalPORes {
        edition = get(entry, "edition");
        poIDArr = split(get(entry, "pONumber"), "~");

        if(edition == "Professional"){
            for eachPO in poIDArr {
                //append the POs to the 'usOfferProfessionalOnlyArr', to be used later in the script
                append(usOfferProfessionalOnlyArr, eachPO);
            }
        }
    }
}

//CSYS-95701 SN. 09-2019
travelAndExpenseWithTriplinkProductArr = String[];
travelAndExpenseWithTriplinkRes = BMQL("SELECT pi FROM tAndEWithTriplink");

for entry in travelAndExpenseWithTriplinkRes {
    pi = get(entry, "pi");
    append(travelAndExpenseWithTriplinkProductArr, pi);
}

//CSYS-98067 (KW & SA 1-22-2020) Prevent Adjustment to ARR to being set to $0
/*
assetNextBillDateToBeUpdated = FALSE_STR;
if (commerce.manageAssetNBDValidation()){
    assetNextBillDateToBeUpdated = TRUE_STR;
}
utilResultString = util.formAttrValueStr(attributesDict, "nBDNeedsToBeUpdated_quote", QUOTE_DOC_NUM, assetNextBillDateToBeUpdated);
*/

baseArray = string[]; //for CSYS-37711 part 2
incArray = string[]; //for CSYS-37711 part 2

//CSYS-92516 (LN. 8-27-2018) Flag to check if there are any MODIFYs in an Add-On bundle
bundleIsModify = false;
//94033
quoteTierChange = FALSE_STR;
//CSYS-97101 SN. 09-2019
permanentTestEnvironmentApprovalMessage = "";
for line in line_process {
    seqNumber = line._sequence_number;
    docNum = line._document_number;
    piItemType = line._part_custom_field8;
    itemType = line.piItemType_line;
    isFirstIteration = line.isFirstIteration_line;
    isTransOverridden = string(line.numTransOverride_line);
    isTransOverriddenFromGrid = line.numTransOverride_line;
    tierChange = string(line.tierChange_line);
    prevTrxns = line.prevNumCommittedTransaction_line;
    itemType = piItemType;
    originalTrxns = line.originalNumCommittedTransaction_line;
    parentDocNum = line._parent_doc_number;
    pi = line._part_number;
    isEditionChanged = "";
    isCoreChanged = "";
    assetArr = 0.0;
    poID = line._part_custom_field1;
    append(piList, pi);
    utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, PO_ID, poID );
    append(docNumList, docNum);
    put(piDict, docNum, pi);
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, PART_NUM, pi);
    utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, SEQ_NUM, seqNumber);
    utilResultFlag = util.putStringAttribute(StringsDict, docNum, DELIMITER, "isFirstIteration_line", string(isFirstIteration));
    assetActionFromGrid = line.assetAction_line;
    disc = line.longDiscount_line;
    discountType = line.discountType_line;
    poCategory = line._part_custom_field20;
    prodFamilyName = line._part_custom_field23;
    baseDiscountType = get(baseDiscountTypeDict, parentDocNum); //@RC - discount types tracked since bundled items should not get the core discount if it is "Amt"
    incrementalDiscountType = get(incrementalDiscountTypeDict, parentDocNum);
    setupDiscountType = get(setupDiscountTypeDict, parentDocNum);
    preProdDiscountType = get(preProdDiscountTypeDict, parentDocNum);
    partNumber = line.partNumber_line;
    lineItemComment = line._line_item_comment;
    assetOriginalNetPrice = line.assetOriginalNetPrice_list;
    assetOriginalDiscount = line.assetsOriginalDiscount_line;
    assetOriginalListPrice = line.assetOriginalListPrice_list;
    originalBundleID = line.originalBundleID_line;
    assetOriginalGroupCheck = line.assetOriginalGroupCheck_line;
    assetAdjustedArr = line.assetAdjustedArr_line;
    discountFromGrid = line.discount_line;
    overrideDefaultRampPlan = line.overrideDefaultRampPlan_line;
    salesARRCurrency = line.salesARRCurrency_line;
    netNewARRCurrency = line.netNewARRCurrency_line;
    priceQuantityFromGrid = line._price_quantity;
    customListPriceFromGrid = line.customListPrice_line;
    customQuantityFromGrid = line.customQuantity_line; //CSYS-96366 SN. 07-2019
    editQuantityFromGrid = line.editQuantity_line; //CSYS-97422 SN. 01-2020
    useCustomPriceFromGrid = line.useCustomPrice_line;
    implementationMethodFromGrid = line.implementationMethod_line;
    coreOfferingFromGrid = line.coreOffering_line;
    editionFromGrid = line.edition_line;
    advLearningSvcsReqd = line.advLearningSvcsReqd_line;
    rampPlanDetailsFromGrid = line.rampPlanDetails_line;
    uomTypeFromGrid = line.uomType_line;
    poCategoryFromGrid = line.poCategory_line;
    rampFlagFromGrid = line._part_custom_field13;
    configAttrInfo = line._config_attr_info;
    modelNameFromGrid = line._model_name;
    discountPercentFromGrid = line.discountPercent_line;
    numOfTransactionsFromGrid = line.numCommittedTransaction_line;
    isPartOfPackage = line.isPartOfPackage_line;
    lineDescription = line.lineDescription_line;
    customPricingHasOccured = line.customPricingHasOccured_line;//CSYS-85811 (LN. 9/28/2017)
    auditTransactionsDefaulted = line.auditTransactionsDefaulted_line;//CSYS-93247 (LN. 11-27-2018)
    unitBasedProductCanBeRamped = line.unitBasedProductCanBeRamped_line; //CSYS-95500 (LN. 4-27-2019)
    unitBasedProductCanUseOverridePrice = line.unitBasedProductCanUseOverridePrice_line; //CSYS-95500 (LN. 4-27-2019)
    pricebookChange = line.pricebookChange_line; //CSYS-95251 (LN. 5-1-2019)
    pricebookChangeUpdatedDiscount = line.pricebookChangeUpdatedDiscount_line; //CSYS-95251 (LN. 5-1-2019)
    pricebookChangeWithinBundle = line.pricebookChangeWithinBundle_line;//CSYS-97680 LN. 11-05-2019
    reconfig = get(stringsDict, "reconfigure");
    //CSYS-88388 - Start
    if (poCategory == CORE_SERVICE AND assetActionFromGrid == CREATE_ACTION){
        if (get(coreTerminatesDict, parentDocNum) == TERMINATE_ACTION){ //3. core is being replaced with another (has edition or core change)
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "skipCoreService", "TRUE" );
        }
    }
    if (poCategory == EXT_SERVICE AND assetActionFromGrid == CREATE_ACTION){
        if (get(familyCreateDict, prodFamilyName) == CREATE_ACTION AND get(familyTerminateDict, prodFamilyName) == TERMINATE_ACTION){
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "skipExtendedService", "TRUE" );
        }
    }
    //CSYS-88388 - End

    if (piItemType == BASE_FEE AND get(hasIncDict, poID) == TRUE_STR){ //for CSYS-37711 part 2
        append(baseArray, pi);
    }

    if (piItemType == INCREMENTAL_FEE AND get(hasIncDict, poID) == TRUE_STR){ //for CSYS-37711 part 2
        append(incArray, pi);
    }

    //CSYS-91348 Evaluate if the Config Attribute "requiresProfessionalProductsAndorServices_concur" is set to true, if yes trigger approvals
    requiresProfessionalServices = util.getConfigValue(line._config_attr_info, "requiresProfessionalProductsAndorServices_concur");
    if(pi == "" AND requiresProfessionalServices == "true"){
        put(triggerDict, "requiresProfessionalServices", TRUE_STR);
    }

    /* case 85005 May 14 2012*/
    //Changed 'baseDiscountVal < 0' to 'baseDiscountVal <> 0' on lines 819, 825, 831, 837 (next line + 6 for 4 times) per case 119146 -Andre Lancour
    if(piItemType == BASE_FEE AND isPartOfPackage AND baseDiscountVal <> 0){
        if(baseDiscountType == PERCENTAGE_DISCOUNT_TYPE){
            discountType = get(baseDiscountTypeDict, parentDocNum);
            disc = get(baseDiscountValDict, parentDocNum);
        }
    }
    elif(piItemType == INCREMENTAL_FEE AND isPartOfPackage AND incrementalDiscountVal <> 0){
        if(incrementalDiscountType == PERCENTAGE_DISCOUNT_TYPE){
            discountType = get(incrementalDiscountTypeDict, parentDocNum);
            disc =  get(incrementalDiscountValDict, parentDocNum);
        }
    }
    elif(piItemType == SETUP_FEE AND isPartOfPackage AND setupDiscountVal <> 0){
        if(setupDiscountType == PERCENTAGE_DISCOUNT_TYPE){
            discountType = get(setupDiscountTypeDict, parentDocNum);
            disc = get(setupDiscountValDict, parentDocNum);
        }
    }
    elif(piItemType == PRE_PRODUCTION AND isPartOfPackage AND preProdDiscountVal <> 0){
        if(preProdDiscountType == PERCENTAGE_DISCOUNT_TYPE){
            discountType =  get(preProdDiscountTypeDict, parentDocNum);
            disc =  get(preProdDiscountValDict, parentDocNum);
        }
    }

    //Setting preprodfee flag for addons
    if( quoteType_quote == ADD_ON AND piItemType == PRE_PRODUCTION ){
        hasPreprodFeeForAddons = true;
    }

    /*BM_VT. Implementation Method is require at the quote level. */
    //if(partNumber <> ""){//if this is a model line number
    if (poCategoryFromGrid == CORE_SERVICE AND assetActionFromGrid <> TERMINATE_ACTION){ //rather than checking models, we need to check the actual core products so that we can ignore terminated cores. fix for CSYS-42777 as part of SC Phase 5 (ATG)
        //if(ImplementationMethodFoundFlag){//retrieve Implementation Method attribute value from the first CREATE/NONE model in the configurator
            strImpMethod = getconfigattrvalue(/*docNum*/parentDocNum, "implementationMethods_concur");
            //if(strImpMethod <> ""){
                //ImplementationMethodFoundFlag = false;
            //}
        //}
    }
    /*End BM_VT*/

    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, DISCOUNT_TYPE, discountType);
    rollup = line._part_custom_field21;
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ROLL_UP, rollup );
    modelImplementationMethod = "";
    lastTierDecreaseDate = "";
    if (pi <> "") { //If the line item is a Product, and not a Model
        baseGroupRequired = util.getStringAttribute(stringsDict, parentDocNum, DELIMITER, BASE_GROUPING_REQUIRED);
        orgSubID = "";
        //add on related - start
        comment = split(lineItemComment,ASSET_DELIMITER);
        packageID = comment[0];
        numOfTransactions = line.numCommittedTransaction_line;
        /* Code for Asset Action implemented by Zak Kampmann for case 153261 on 6/21/13 */
        assetAction = assetActionFromGrid;
                if(NOT isnull(comment[1]) OR isnull(assetActionFromGrid)) {
                                assetAction = comment[1];
                }
                if(isnull(assetAction) AND quoteType_quote <> NEW_BIZ) {
                                assetAction = NONE_ACTION;
                }
                if(quoteType_quote == NEW_BIZ) {
                                assetAction = CREATE_ACTION;
                }

        isGrouped = string(isPartOfPackage);
        tempSwitch = "";
        if(NOT (assetAction <> "")){ //setting logic like this for existing quotes.
            assetAction = CREATE_ACTION;
        }
        //CSYS-68345: On first iteration, assign any Partner Discount to CREATE line items:
        //if( line.isFirstIteration_line AND assetAction == CREATE_ACTION AND acctPartnerDiscount <> 0 AND NOT isnull(acctPartnerDiscount) ){
        //  disc = acctPartnerDiscount;
        //}
        latestDisc = disc;
        utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, "latestDisc", latestDisc);
        /* End of code for Asset Action change for case 153261- ZK */
        assetString = "";
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, PACKAGE_ID, packageID );
        //CSYS-87125: added the next line to store packageID at part number key (wrap in tilda delimiters to prevent conflicts with other keys):
        utilResultFlag = util.putStringAttribute( stringsDict, TILDE_DELIMITER + pi + TILDE_DELIMITER, DELIMITER, PACKAGE_ID, packageID );
        currentAssetString = string[];

        //CSYS-97722, PhilS 12/12/2019
        assetStringQuoteIntegration = split(assetsString_quote, ASSET_DELIMITER );

        for item in assetStringQuoteIntegration {
            eachAsset = split(item, INTERNAL_DELIMITER);

            if(pi == eachAsset[ASSET_PID]){
                orgSubID = eachAsset[ASSET_SUBSCRIP_ID]; ////CASE 121961 - 1/4/13
                utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, SUBSCRIP_ID, orgSubID );

                utilResultString = util.formAttrValueStr(attributesDict, SUBSCRIP_ID, docNum, orgSubID);
                lastTierDecreaseDate = eachAsset[ASSET_LAST_TIER_DEC_DATE]; //CSYS-97861
                utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "LastTierDecreaseDate", lastTierDecreaseDate );
            }
        }
        //end of CSYS-97722

        if(sizeofarray(comment)>1){ //If an existing asset
            assetString = comment[2];
            adjustedArr = "0";
            assetDisc = 0.0;//to void run time error  - By Sai Krishna
            if(assetString<>""){

                isTransOverridden = TRUE_STR;

                if( quoteType_quote == ADD_ON AND itemType == BASE_FEE AND assetAction == MODIFY_ACTION){
                    tierChange = TRUE_STR;
                } //Added for ARR Enhancement - Ronald Mendoza

                assetIsGrouped = FALSE_STR;
                currentAssetString = split(assetString,INTERNAL_DELIMITER);

                //AH 181910 2014/02/20 (1 of 4)
                originalTrxns = integer(atof(currentAssetString[ASSET_COMMITED_TRNS]));
                utilResultString = util.formAttrValueStr(attributesDict, ORIGINAL_TRANSACTIONS, docNum, string(originalTrxns));
                //End (1 of 4)


                put(stringsDict, docNum + "currentAssetTrxns", string(originalTrxns));

                isCoreChanged = get(isCoreChangedDict, parentDocNum); //grab the result of core change detection
                isEditionChanged = get(isEditionChangedDict, parentDocNum); //grab the result of edition change detection
                //end modify fix(1 of 3)

                // Write core and edition change to strings dict for use in NPSD Function
                put(triggerDict, parentDocNum + DELIMITER + "coreFlip", isCoreChanged);
                put(triggerDict, parentDocNum + DELIMITER + "editionFlip", isEditionChanged);

                /*CSYS-98097 (LN. 1-14-2020)
                    Pushing this logic further up to be assessed before assigning NONE/MODIFY action codes.
                    If there have been a pricebook change detected, set the 'assetDic' accordingly.
                */
                if(pricebookChange OR pricebookChangeWithinBundle){
                    //If there was no updated discount (no pricebook change detected),
                    if(pricebookChangeUpdatedDiscount == 0.0){

                        currentAssetDisc = atof(currentAssetString[ASSET_DISCOUNT]);//Current discount on the SFDC Asset String

                        if(currentAssetDisc == discountFromGrid){
                            assetDisc = currentAssetDisc;
                        }
                    }
                    else {//Else, if there was an updated discount, set the assetDisc to the newly calculated discount
                        assetDisc = pricebookChangeUpdatedDiscount;
                    }
                }
                else {//Otherwise, business as usual
                    if( isnumber(currentAssetString[ASSET_DISCOUNT]) ) {
                        assetDisc = atof(currentAssetString[ASSET_DISCOUNT]);
                    } else {
                        assetDisc = 0.0;
                    }
                }

                if( isnumber(currentAssetString[ASSET_LIST_PRICE]) ) {
                    listPrice = atof(currentAssetString[ASSET_LIST_PRICE]);
                }
                else {
                    listPrice = 0.0;
                }
                //CSYS-95251 (LN. 5-2-2019) Pulling in the Asset Tier Price from SFDC, this is the non-unified Price
                if( isnumber(currentAssetString[ASSET_TIER_PRICE]) ) {
                    if(currencyCode == "USD"){
                        tierPrice = atof(currentAssetString[ASSET_TIER_PRICE]);
                    }
                    else {
                        //CSYS-95956 (LN. 6-5-2019) For non-USD currency quotes, we need to find the Tier Price in USD (Tier Price/Conversion Rate)
                        convertedTierPrice = atof(currentAssetString[ASSET_TIER_PRICE]);
                        tierPrice = round((convertedTierPrice/conversionRate), 2);
                    }
                }
                else {
                    tierPrice = 0.0;
                }

                utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_TIER_PRICE, docNum, string(tierPrice));//CSYS-95251 (LN. 5-2-2019)
                utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_TIER_PRICE, tierPrice);//CSYS-95251 (LN. 5-2-2019)

                if( isnumber(currentAssetString[ASSET_EXT_LIST_PRICE]) ) {  // TEMPORARY FIX BY MMARTIN 08/09
                    extListPrice = atof(currentAssetString[ASSET_EXT_LIST_PRICE]);


                    //CSYS-82292:
                    if( piItemType == INCREMENTAL_FEE AND NOT containskey(floatsDict, poID + DELIMITER + "assetIncExtListPrice") ){
                        utilResultFlag = util.putFloatAttribute( floatsDict, poID, DELIMITER, "assetIncExtListPrice", extListPrice );
                    }
                    elif(piItemType == BASE_FEE AND NOT containskey(floatsDict, poID + DELIMITER + "assetBaseExtListPrice")){
                        utilResultFlag = util.putFloatAttribute( floatsDict, poID, DELIMITER, "assetBaseExtListPrice", extListPrice );
                        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "firstBaseofPoId", TRUE_STR );

                    }
                }
                else {
                    extListPrice = 0.0;
                }
                if( isnumber(currentAssetString[ASSET_NET_PRICE]) ) {
                    netPriceEach = atof(currentAssetString[ASSET_NET_PRICE]);

                }
                else {
                    netPriceEach = 0.0;
                }
                if( isnumber(currentAssetString[ASSET_EXT_NET_PRICE]) ) {
                    extendedNetPrice = atof(currentAssetString[ASSET_EXT_NET_PRICE]);


                    //CSYS-82292:
                    if( piItemType == INCREMENTAL_FEE AND NOT containskey(floatsDict, poID + DELIMITER + "assetIncExtNetPrice") ){
                        utilResultFlag = util.putFloatAttribute( floatsDict, poID, DELIMITER, "assetIncExtNetPrice", extendedNetPrice );
                    }
                }
                else {
                    extendedNetPrice = 0.0;
                }

                if(assetIsGrouped == FALSE_STR){ // @RC: Modified as systematized-forced grouping should overwrite add-ons
                    assetIsGrouped = currentAssetString[ASSET_IS_BUNDLE];
                }

                //CSYS-70966 part 2: fix assetOriginalGroupCheck_line for line items terminated via
                //'Select Core and Related products' on the first config trip. KA. 9-30-2016
                if(containskey(assetBillingDict, pi + "assetIsBundleKey") AND NOT isnull(get(assetBillingDict, pi + "assetIsBundleKey"))){
                    assetIsGrouped = get(assetBillingDict, pi + "assetIsBundleKey");
                }

                if((isEditionChanged <> TRUE_STR AND isCoreChanged <> TRUE_STR) AND assetAction == MODIFY_ACTION){
                    assetAction = NONE_ACTION;
                    utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, assetAction );
                }

                //add-on related By Sai Krishna Case:105868
                if( assetAction <> MODIFY_ACTION){
                        numOfTransactions = util.customAtof(currentAssetString[ASSET_COMMITED_TRNS], 0.0);
                        //Added by Andre to throw the Action and Transactions of a Modify line to equal its entered transactions @ALFIX00154530
                        if(assetActionFromGrid == MODIFY_ACTION AND assetCoreServiceTerminatedOrModified == true AND piItemType <> INCREMENTAL_FEE) {

                            numOfTransactions = line.numCommittedTransaction_line;
                        }
                        // End adding by Andre @ALFIX00154530
                        //Next elif block added by KA for CSYS-63285 to maintain integrity of numOfTransactions for cores whose asset transactions don't match the original global tier:
                        elif(NOT isFirstIteration AND assetActionFromGrid == NONE_ACTION AND
                        util.customAtoi(currentAssetString[ASSET_COMMITED_TRNS], 0) <> oRGNumberOfComittedTransactions_quote AND
                        util.customAtoi(currentAssetString[ASSET_COMMITED_TRNS], 0) <> numOfTransactionsFromGrid){
                            numOfTransactions = line.numCommittedTransaction_line;
                        }
                        //Modding transactions when it's allowed:
                        elif(NOT isFirstIteration AND numCommittedTransaction_quote == oRGNumberOfComittedTransactions_quote /*AND findinarray(listOfNumOfTransPOs, poID) == -1*/ AND assetActionFromGrid == MODIFY_ACTION AND util.customAtoi(currentAssetString[ASSET_COMMITED_TRNS], 0) <> numOfTransactionsFromGrid AND piItemType <> INCREMENTAL_FEE){
                            numOfTransactions = line.numCommittedTransaction_line;
                        }
                }

                //added by Ronald Mendoza for ARR Enhancement
                if( currentAssetString[ASSET_CUSTOMER_CURRENCY_REV_REC] <> "" and isnumber(currentAssetString[ASSET_CUSTOMER_CURRENCY_REV_REC]) ){
                    extNetPriceNonUnified = atof(currentAssetString[ASSET_CUSTOMER_CURRENCY_REV_REC]);
                }
                 else {
                    extNetPriceNonUnified = 0.0;
                }

                orgBundleID = currentAssetString[ASSET_ORG_BUNDLE_ID];

                //CSYS-97722, PhilS 12/12/2019, comment out following two lines since subscription ID has been taking care in front of this loop
                // orgSubID = currentAssetString[ASSET_SUBSCRIP_ID]; ////CASE 121961 - 1/4/13
                // utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, SUBSCRIP_ID, orgSubID );

                if( orgBundleID <> ""){
                    utilResultFlag = util.putStringAttribute(stringsDict, parentDocNum, DELIMITER, CORE_ASSET_SERVICEID,orgBundleID);
                }
                if( piItemType == BASE_FEE ){
                    assetArr = extNetPriceNonUnified * RAMP_FLAG_MULTIPLIER; //Modified by Ronald Mendoza - Changed Calculation from extendedNetprice to Customer Currency Rev Rec Monthly
                }

                if(currentAssetString[ASSET_ADJUSTED_ARR]<> ""){
                    adjustedArr = currentAssetString[ASSET_ADJUSTED_ARR];
                }

                //Adding the condition below to update Adjustment to ARR on Save/Submit CSYS-46906 Part 2
                if ( containskey( assetAdjArrDict, pi )){
                    adjustedArr = get( assetAdjArrDict, pi );
                }

                QUOTE_TOTAL_EXISTING_ARR = QUOTE_TOTAL_EXISTING_ARR + assetArr;
                nxtBillingDate = currentAssetString[ASSET_NEXT_BILLING_DATE];

                if(isFirstIteration){ //Asset Action will ALWAYS be what was pulled in from config

                    assetAction = comment[1];

                    if(addOnNumOfTrans == "-1" AND integer(numOfTransactions) > 0 AND piItemType == BASE_FEE){
                        addOnNumOfTrans = string(integer(numOfTransactions));
                        if( assetAction <> TERMINATE_ACTION ){
                            if(QUOTE_TRANSACTIONS < 1){
                                QUOTE_TRANSACTIONS = atoi(addOnNumOfTrans);
                            }
                        }
                        if( currentAssetString[ASSET_COMMITED_TRNS] <> "" AND atof(currentAssetString[ASSET_COMMITED_TRNS]) > 1 ){
                            oRGNumCommittedTrans = integer(atof(currentAssetString[ASSET_COMMITED_TRNS]));
                            //Nov 6 - This line will be modified as follows:

                            if(isnull(oRGNumberOfComittedTransactions_quote) OR oRGNumberOfComittedTransactions_quote == 0){ //CSYS-63285: added this condition so oRGNumberOfComittedTransactions_quote doesn't get overwritten by 2nd and subsequent cores whose asset transactions are different than the original global tier. KA. 5-9-2016.
                                utilResultString = util.formAttrValueStr(attributesDict, "oRGNumberOfComittedTransactions_quote", QUOTE_DOC_NUM, string(oRGNumCommittedTrans));
                            }

                            put(stringsDict, "originalTrans", string(oRGNumCommittedTrans));
                        }
                    }

                    sizeOfAssetString = sizeofarray( currentAssetString );
                    assetOriginalGroup = currentAssetString[sizeOfAssetString - 1];

                    tempSwitch = "none";
                    tempSwitch_dictVal = util.getStringAttribute( stringsDict, parentDocNum, DELIMITER, "assetGroupMappingDict" ); //This will always be null the first item in a configuration

                    if(tempSwitch_dictVal<>""){
                        tempSwitch = tempSwitch_dictVal;
                    }
                    if(assetOriginalGroup == TRUE_STR AND assetAction == TERMINATE_ACTION) {
                        if(tempSwitch == "none"){ tempSwitch = "group";}
                    }

                    if( oRGRampPlanInformation_quote == "" ){
                        utilResultString = util.formAttrValueStr(attributesDict, "oRGRampPlanInformation_quote", QUOTE_DOC_NUM, rampPlanDetails_quote);
                    }
                    disc = assetDisc;

                    isGrouped = assetIsGrouped;
                    if(poCategory == CORE_SERVICE AND baseGroupRequired == TRUE_STR AND assetAction <> TERMINATE_ACTION){
                        isGrouped = TRUE_STR;
                    }
                    if (isGrouped == FALSE_STR) { // If it is not Grouped.
                        if(find(posToBeGrouped,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1) {        // If PO needs to be grouped
                            isGrouped = TRUE_STR;           // Set to true.
                        }
                    }
                    if(assetIsGrouped <> isGrouped AND assetAction == NONE_ACTION){
                        assetAction = MODIFY_ACTION;
                    }

                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_PO, docNum, currentAssetString[1]);
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_PI, docNum, currentAssetString[0]);
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_NET_PRICE, docNum, string(netPriceEach));
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_EXT_NET_PRICE, docNum, string(extendedNetPrice)); //added for CSYS-36627
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_DISCOUNT, docNum, string(assetDisc));
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_LIST_PRICE, docNum, string(listPrice));
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_EXT_LIST_PRICE, docNum, string(extListPrice)); //added for CSYS-36627
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_IS_GROUPED, docNum, assetIsGrouped);
                    utilResultString = util.formAttrValueStr(attributesDict, "nextBillingDate_line", docNum, nxtBillingDate);
                    utilResultString = util.formAttrValueStr(attributesDict, "assetExistingARR_line", docNum, string(assetArr));
                    utilResultString = util.formAttrValueStr(attributesDict, EXISTING_ARR_CURRENCY_LINE, docNum, string(assetArr));

                    //CSYS-98067 (KW & SA 1-22-2020) Prevent Adjustment to ARR to being set to $0
                    //if (gracePeriodSubmission_quote == false OR assetNextBillDateToBeUpdated == TRUE_STR){
                        utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ADJUSTED_ARR, docNum, adjustedArr);
                        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ADJUSTED_ARR,atof(adjustedArr));
                    //}

                    utilResultString = util.formAttrValueStr(attributesDict, "serviceAccountID_line", docNum, currentAssetString[ASSET_SERVICE_ACCT_ID]);
                    utilResultString = util.formAttrValueStr(attributesDict, "billingID_line", docNum, currentAssetString[ASSET_BILLING_ID]);
                    utilResultString = util.formAttrValueStr(attributesDict, "isFirstIteration_line", docNum, FALSE_STR);

                    if(orgBundleID<>""){
                        utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ORIGINAL_BUNDLE_ID, docNum, orgBundleID);
                    }
                    utilResultString = util.formAttrValueStr(attributesDict, "isPartOfPackage_line", docNum, isGrouped);

                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_NET_PRICE, netPriceEach);
                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_DISCOUNT, assetDisc);
                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_LIST_PRICE, listPrice);
                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_EXT_LIST_PRICE, extListPrice); //added for CSYS-70755
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ASSETS_ORIGINAL_BUNDLE_ID,orgBundleID);
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ASSETS_ORIGINAL_IS_GROUPED,assetIsGrouped);
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_GROUPED, isGrouped);
                    
                    utilResultString = util.formAttrValueStr(attributesDict, "assetAction_line", docNum, assetAction);

                    if (currentAssetString[ASSET_SERVICE_ACCT_ID] <> ""){ //prevent null value population
                        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "serviceAccountID_line", currentAssetString[ASSET_SERVICE_ACCT_ID]); //for Service Acct ID fix 8-20-2014
                    }
                }

                if(assetAction == NONE_ACTION){ //populate line attributes

                    utilResultString = util.formAttrValueStr(attributesDict, "listPrice_line", docNum, string(round(listPrice,2)));
                    utilResultString = util.formAttrValueStr(attributesDict, "extendedList_line", docNum, string(round(extListPrice,2)));
                    utilResultString = util.formAttrValueStr(attributesDict, "discount_line", docNum, string(round(assetDisc,2)));
                    utilResultString = util.formAttrValueStr(attributesDict, LONG_DISCOUNT, docNum, string(round(assetDisc,2))); //for ext net price fix (ATG)
                    utilResultString = util.formAttrValueStr(attributesDict, "prevDiscount_line", docNum, string(round(assetDisc,2))); //for CSYS-36981 (ATG)
                    utilResultString = util.formAttrValueStr(attributesDict, "prevDiscountStatic_line", docNum, string(round(assetDisc,2)));
                    utilResultString = util.formAttrValueStr(attributesDict, "netPriceEach_line", docNum, string(round(netPriceEach,2)));
                    utilResultString = util.formAttrValueStr(attributesDict, "extendedNetPrice_line", docNum, string(round(extendedNetPrice,2)));
                    //CSYS-98067 (KW & SA 1-22-2020) Prevent Adjustment to ARR to being set to $0
                    //if (gracePeriodSubmission_quote == false OR assetNextBillDateToBeUpdated == TRUE_STR){
                        utilResultString = util.formAttrValueStr(attributesDict, "arrNet_line", docNum, adjustedArr);
                    //}
                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_EXT_LIST_PRICE, extListPrice); //added for CSYS-70755
                }

                //CSYS-98067 (KW & SA 1-22-2020) Prevent Adjustment to ARR to being set to $0
                //if (gracePeriodSubmission_quote == false OR assetNextBillDateToBeUpdated == TRUE_STR){
                    utilResultString = util.formAttrValueStr(attributesDict, ASSETS_ADJUSTED_ARR, docNum, adjustedArr); //iteration independent, added for CSYS-46906 Part 3
                //}

            }   //End field population from assets string


            if(NOT isFirstIteration){//assess if this line/model require a change from NONE to MODIFY

                utilResultString = util.formAttrValueStr(attributesDict, "prevDiscount_line", docNum, string(line.prevDiscount_line)); //for CSYS-59630. Make sure Prev Discount stays what it was set to by the Auto-Update script after Saving (applies to NONE/MODIFY action codes) KA. 4-14-2016
                // If line trans matches quote trans, it needs to continue matching the quote trans
                if (isTransOverriddenFromGrid <> true OR numOfTransactionsFromGrid == PAST_QUOTE_TRANSACTIONS OR piItemType == INCREMENTAL_FEE){
                                //Above comment forgot to check if the attribute was actually set to true, so we don't clear it out. Andre Case 00127175

                    if ( numOfTransactionsFromGrid == PAST_QUOTE_TRANSACTIONS OR poCategory == CORE_SERVICE OR piItemType == INCREMENTAL_FEE){

                        isTransOverridden = FALSE_STR;
                        tierChange = FALSE_STR; //Added by Ronald Mendoza
                    }
                }
                utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_NET_PRICE, assetOriginalNetPrice);
                utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_DISCOUNT, assetOriginalDiscount);
                utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_LIST_PRICE, assetOriginalListPrice);
                utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ASSETS_ORIGINAL_BUNDLE_ID,originalBundleID);
                utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ASSETS_ORIGINAL_IS_GROUPED,string(assetOriginalGroupCheck));
                //CSYS-98067 (KW & SA 1-22-2020) Prevent Adjustment to ARR to being set to $0
                if ( containskey( assetAdjArrDict, pi )/* AND (gracePeriodSubmission_quote == false OR assetNextBillDateToBeUpdated == TRUE_STR)*/ ){ //existing asset adjustment to ARR value
                    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ADJUSTED_ARR,atof(adjustedArr)); //use the asset updated adjustment to arr value
                }
                else{ utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ADJUSTED_ARR,assetAdjustedArr); } //keep the line value

                if (currentAssetString[ASSET_SERVICE_ACCT_ID] <> ""){ //prevent null value population
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "serviceAccountID_line", currentAssetString[ASSET_SERVICE_ACCT_ID]); //for Service Acct ID fix 8-20-2014
                }
                //Do not group Terminated Line Items  -- By Sai Krishna (Validation Error on Grouping Terminated Line items)
                if(poCategory == CORE_SERVICE AND baseGroupRequired == TRUE_STR AND assetAction <> TERMINATE_ACTION ){
                    isGrouped = TRUE_STR;
                }

                if (isGrouped == FALSE_STR) { // If it is not Grouped.
                    if(find(posToBeGrouped,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1) {        // If PO needs to be grouped
                        isGrouped = TRUE_STR;           // Set to true.
                    }
                }
                // Remove terminated line items from the group when the line item is TERMINATED during reconfigure
                assetIsGroupedReconfig = FALSE_STR;

                if(assetIsGroupedReconfig == FALSE_STR){
                    assetIsGroupedReconfig = currentAssetString[ASSET_IS_BUNDLE];
                }

                tempSwitch = "none";
                tempSwitch_dictVal = util.getStringAttribute( stringsDict, parentDocNum, DELIMITER, "assetGroupMappingDict" ); //This will always be null the first item in a configuration

                if(tempSwitch_dictVal<>""){
                    tempSwitch = tempSwitch_dictVal;
                }
                if(isGrouped == TRUE_STR AND assetIsGroupedReconfig == FALSE_STR AND assetAction == TERMINATE_ACTION) {
                    if(tempSwitch == "none"){ tempSwitch = "group";}
                    isGrouped = FALSE_STR;
                }

                /*//M.A. 04/28/2014 - SR 2-9333372
                // set action to MODIFY if item is grouped, reconfigured, and the action is currently NONE
                if(isGrouped == TRUE_STR AND assetIsGroupedReconfig == TRUE_STR AND assetAction == NONE_ACTION) {
                        if(tempSwitch == "none"){ tempSwitch = "group";}
                    assetAction = MODIFY_ACTION;
                }
                //end of action change - M.A. */

                if(tempSwitch <> "all"){

                    //next two only affect the lines that belong to a group
                    if(isGrouped <> string(assetOriginalGroupCheck)){
                        if(tempSwitch == "none"){
                        tempSwitch = "group";
                        }
                        if(assetAction == NONE_ACTION){//make sure that lines that have been removed from the group will be tagged as modify
                            assetAction = MODIFY_ACTION;
                            put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, MODIFY_ACTION);
                        }
                    }//if the grouping status has changed

                    if((assetAction == TERMINATE_ACTION OR assetAction == CREATE_ACTION) AND isGrouped == TRUE_STR){
                        if(tempSwitch == "none"){
                            tempSwitch = "group";
                        }
                    }//if manually terminated from group

                }

                //##########################################################//
                //#####    Action Code NONE VS MODIFY main section     #####//
                //##########################################################//

                //CSYS-57212: check if the action code should stay at NONE, else change from NONE to MODIFY. KA. Most recent update: 9-30-2016
                if(
                /*=== dealing with a NONE or MODIFY action ===*/
                (assetAction == NONE_ACTION OR assetAction == MODIFY_ACTION) AND
                /*=== Core and Edition change detection ===*/
                (isCoreChanged <> TRUE_STR AND isEditionChanged <> TRUE_STR) AND
                /*=== assetString is not blank ===*/
                assetString <> "" AND
                /*=== line discount = asset discount ===*/
                discountFromGrid == assetDisc AND
                /*=== line ramp is not overridden ===*/
                //overrideDefaultRampPlan <> TRUE_STR AND
                NOT containskey(stringsDict, poID + DELIMITER + "overrideDefaultRampPlanForPoID") AND
                /*=== quote ramp is not overridden ===*/
                NOT sizeofarray(quoteRampTransactionStrings) > 1 AND
                /*=== line trans equals asset trans ===*/
                numOfTransactionsFromGrid == util.customAtoi(currentAssetString[ASSET_COMMITED_TRNS], 0) AND
                /*=== original term months is blank. Commenting out for now until CSYS-70421 is done ===*/
                //oRGTermNumMonths_quote == "" AND
                /*=== billing cycle is original ===*/
                //currentBillingCycle_quote == billingCycle_quote AND //CSYS-99043
                /*=== asset was not terminated from the core bundle
                OR any asset was terminated from the bundle but
                the product that we're currently processing in the
                loop was not part of the original bundle ===*/
                ((NOT containskey(stringsDict, parentDocNum + DELIMITER + "groupedAssetTerminatedFromCore")) OR (containskey(stringsDict,parentDocNum + DELIMITER + "groupedAssetTerminatedFromCore") AND NOT assetOriginalGroupCheck)) AND
                /*=== line bundle flag equals the asset bundle flag ===*/
                isGrouped == string(assetOriginalGroupCheck) ){
                        //CSYS-99043
                        if (currentBillingCycle_quote == billingCycle_quote){
                            put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, NONE_ACTION);
                        }
                        else{
                            put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, MODIFY_ACTION);
                            if (containskey(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly")){
                                billCycleChangeOnlyCheck = get(stringsDict,QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly");
                                if (billCycleChangeOnlyCheck <> TRUE_STR){
                                    put(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly", "");
                                }
                            }
                            else{
                                put(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly", TRUE_STR);
                            }
                            //CSYS-92516 (LN. 8-27-2018) If this is an existing bundled asset that has been altered (set to MODIFY), set the bundleIsModify flag to true to be leveraged below to set all other NONEs in the bundle to MODIFY
                            if( isGrouped == string(assetOriginalGroupCheck) AND isPartOfPackage ){
                                bundleIsModify = true;
                                put(stringsDict, parentDocNum + DELIMITER + "bundleIsModify", parentDocNum);
                            }

                            if( assetAction <> TERMINATE_ACTION ){

                                numOfTransactions = numOfTransactionsFromGrid;
                            }
                        }

                }
                else{

                    put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, MODIFY_ACTION);
                    //CSYS-99043
                    if(assetAction <> CREATE_ACTION){
                        put(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly", "");
                    }
                    //CSYS-92516 (LN. 8-27-2018) If this is an existing bundled asset that has been altered (set to MODIFY), set the bundleIsModify flag to true to be leveraged below to set all other NONEs in the bundle to MODIFY
                    if( isGrouped == string(assetOriginalGroupCheck) AND isPartOfPackage ){
                        bundleIsModify = true;
                        put(stringsDict, parentDocNum + DELIMITER + "bundleIsModify", parentDocNum);
                    }

                    if( assetAction <> TERMINATE_ACTION ){

                        numOfTransactions = numOfTransactionsFromGrid;
                    }
                }


                //CSYS-86113:
                // if((assetAction == NONE_ACTION OR assetAction == MODIFY_ACTION) AND rollup == "Y" AND overrideDefaultRampPlan == TRUE_STR){
                //  put(stringsDict, poID + DELIMITER + "overrideRampPlanForPoID", TRUE_STR);
                //  print "testit";
                // }

                //Process the Invoice Check Payments action code (inc and base): analyze if a switch back to NONE is needed. CSYS-65212. KA. 8-30-2016
                if(poID == "566" OR poID == "416635") {
                    if(currentBillingCycle_quote == billingCycle_quote AND
                        assetString <> "" AND
                        assetDisc == discountFromGrid AND
                        (isCoreChanged <> TRUE_STR AND isEditionChanged <> TRUE_STR)
                        //ignore transaction checks since transactions for ICP are always 0
                        //ignore ramp checks since ICP has a static 1 ramp
                        //ignore group checks since ICP can't be dynamically grouped
                        ){

                        put(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + piItemType, NONE_ACTION);
                    }
                    else{
                        put(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + piItemType, MODIFY_ACTION);
                    }
                }
                /*//CSYS-98054
                if(poID == "36309"){//CSYS-85237 (LN. 10/20/2017)
                    if(currentBillingCycle_quote == billingCycle_quote AND assetString <> "" AND isCoreChanged <> TRUE_STR AND isEditionChanged <> TRUE_STR AND
                    numOfTransactionsFromGrid == util.customAtoi(currentAssetString[ASSET_COMMITED_TRNS], 0)){

                        put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, NONE_ACTION);

                    }
                    else{

                        put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + piItemType, MODIFY_ACTION);

                    }
                }*/
            }
        }   //End existing assets logic.

            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_GROUPED, isGrouped);
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, assetAction );
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_STRING, assetString );
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "isFirstIteration_line", string(isFirstIteration) );
            utilResultFlag = util.putStringAttribute(stringsDict, parentDocNum, DELIMITER, "assetGroupMappingDict", tempSwitch);
            utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, "salesARRCurrency_line", salesARRCurrency);
            utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, "netNewARRCurrency_line", netNewARRCurrency);
            utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, EXISTING_ARR_CURRENCY_LINE, assetArr);

            //Moving the following line further down so that assetAction is accurate for the triggerDict. KA. 10-24-2016:
            //put(triggerDict, docNum + "~" + "assetAction", docNum + "~" + "assetAction" + TRIG_KEY_VALUE_DELIM + assetAction);

        //Moved the next line higher:
        //append(fullPOlist,poID);//capture all POs, with no sorting

        /* Store line items that may need to have their transactions changed */
        append( overWriteTransactionArr, docNum );
        /* --- Store the state of this line item's non-calculated fields -- */
        quantity = priceQuantityFromGrid;
        customListPrice = customListPriceFromGrid;
        customQuantity = customQuantityFromGrid;//CSYS-96366 SN. 07-2019
        editQuantity = editQuantityFromGrid;//CSYS-97422 SN. 01-2020
        useCustomPrice = useCustomPriceFromGrid;

        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, QTY, quantity);
        utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, CUSTOM_LIST_PRICE, customListPrice );
        utilResultFlag = util.putIntegerAttribute( integersDict, docNum, DELIMITER, "customQuantity_line", customQuantity );//CSYS-96366 SN. 07-2019
        utilResultFlag = util.putIntegerAttribute( integersDict, docNum, DELIMITER, "editQuantity_line", editQuantity );//CSYS-97422 SN. 01-2020
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, USE_CUSTOM_PRICE, useCustomPrice );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE, piItemType );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, IS_TRANS_OVERRIDDEN, isTransOverridden );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, CUSTOM_PRICING_HAS_OCCURED, string(customPricingHasOccured));//CSYS-85811 (LN. 9/27/2017) To be used below by Custom Pricing workflow

        /* BM_VT. 07/05/2012. Added for Systematized Contracts Project */
        /* BM_VT. 07/05/2012. POs for travel expense must always be grouped. List of pos are maintained in the data table */
        isGrouped = util.getStringAttribute(stringsDict, docNum, DELIMITER, IS_GROUPED );

        // @RC 08/06/2012: set core service flag to true;
        if(poCategory == CORE_SERVICE AND piItemType == SETUP_FEE){
            utilResultFlag = util.putStringAttribute(stringsDict, parentDocNum, DELIMITER, CORE_HAS_SETUP, TRUE_STR);
        }
        /* @RC 07/23/2012: If core service is forced to be grouped, do so.*/
        //Do not group Terminated Line Items  -- By Sai Krishna (Validation Error on Grouping Terminated Line items)
        if(poCategory == CORE_SERVICE AND baseGroupRequired == TRUE_STR AND assetAction <> TERMINATE_ACTION ){
            isGrouped = TRUE_STR;
        }
        if (isGrouped == FALSE_STR) { // If it is not Grouped.
            // If PO needs to be grouped
            if(find(posToBeGrouped,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 AND assetAction <> TERMINATE_ACTION) {// If PO needs to be grouped//@ALFIX156008 Do not group T&E when terminated.
                isGrouped = TRUE_STR;           // Set to true.
            }
        }
        /* End BM_VT 07/05/2012 */
        /* BM_VT. 07/05/2012. Added for Systematized Contracts Project */
        if(find(concurforcePOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and concurforceExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {       // If Concurforce PO exist. Added the action check for CSYS-46393 (ATG)
            concurforceExistInQuote = TRUE_STR; // Set to true.
        } elif(find(premierTravelPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and premierTravelExistInQuote == FALSE_STR and concurforceExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {      // else check for premier travel. both cannot exist at the same time. Added the action check for CSYS-46393 (ATG)
            premierTravelExistInQuote = TRUE_STR;   // Set to true.
        }

        if(find(clientWebServicePOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and piItemType == SETUP_FEE and clientWebServiceInQuote == FALSE_STR AND assetAction == CREATE_ACTION) {     // If CWS PO exist and line item is a setup. Added the action check for CSYS-46393 (ATG)
            clientWebServiceInQuote = TRUE_STR; // Set to true.
        }
        if(find(intelRptPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and intelligenceReportInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {        // If Intelligence Report PO exist. Added the action check for CSYS-46393 (ATG)
            intelligenceReportInQuote = TRUE_STR;   // Set to true.
        }

        if(find(meetingMgtPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and meetMgtInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {     // If Meeting Management PO exist. Added the action check for CSYS-46393 (ATG)
            meetMgtInQuote = TRUE_STR;  // Set to true.
        }

        //@DS: Language updates for multi and single country  Kevin Z. updated to add Consulting Session, Site Review & Site Review Elite 5.21.13

        if(find(multiCountryExpPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and multiCountryExpExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {       // If multiCountryExp PO exist. Added the action check for CSYS-46393 (ATG)
            multiCountryExpExistInQuote = TRUE_STR; // Set to true.
        }
        if(find(singleCountryExpPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and singleCountryExpExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {     // If singleCountryExp PO exist. Added the action check for CSYS-46393 (ATG)
            singleCountryExpExistInQuote = TRUE_STR;    // Set to true.
        }
        if(find(consultingSessionPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and consultingSessionExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {       // If consultingSession PO exist. Added the action check for CSYS-46393 (ATG)
            consultingSessionExistInQuote = TRUE_STR;   // Set to true.
        }
        if(find(SiteReviewPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and siteReviewExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {     // If SiteReview PO exist. Added the action check for CSYS-46393 (ATG)
            siteReviewExistInQuote = TRUE_STR;  // Set to true.
        }
        if(find(SiteReviewElitePOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1 and siteReviewEliteExistInQuote == FALSE_STR AND assetAction <> TERMINATE_ACTION) {       // If SiteReviewElite PO exist. Added the action check for CSYS-46393 (ATG)
            siteReviewEliteExistInQuote = TRUE_STR; // Set to true.
        }

        if(find(unitBasedPOs,TILDE_DELIMITER+poID+TILDE_DELIMITER) > -1) {      // If this is a unit based recurring fee product
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_UNITBASED, TRUE_STR);
        }
        /* End BM_VT 07/05/2012 */
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_GROUPED, isGrouped);

        if ( isGrouped == TRUE_STR ){
            dynamicGroupingPo = util.getStringAttribute( stringsDict, parentDocNum, DELIMITER, PO_GROUPS_DYNAMIC_GROUPING );
            dynamicGroupingPo = dynamicGroupingPo + poID + PO_DELIMITER;
            utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum, DELIMITER, PO_GROUPS_DYNAMIC_GROUPING, dynamicGroupingPo );
            utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum, DELIMITER, MODEL_FORCE_GROUPING, TRUE_STR );
        }
        implementationMethod = implementationMethodFromGrid;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD, implementationMethod);
        coreOffering = coreOfferingFromGrid;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, CORE_OFFERING, coreOffering);
        editionVal = editionFromGrid;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, EDITION_LINE, editionVal);
        advLearningServicesRequired = advLearningSvcsReqd;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, ADV_LEARNING_SERVICES_REQUIRED, advLearningServicesRequired);
        put(triggerDict, docNum + DELIMITER + ADV_LEARNING_SERVICES_REQUIRED, advLearningServicesRequired);

        //CSYS-97934 SN. 01/2020, Rolled back as per CSYS-99246
        /*
        if ((poID == "6210737" OR poID == "6210772") AND assetAction == CREATE_ACTION ){
            put(triggerDict, "xeroAccountingIntegrationExistsCREATE", TRUE_STR);
        }*/
        //CSYS-98316 SN. 01/2020
        if ((poID == "5793980") AND assetAction == CREATE_ACTION ){
            put(triggerDict, "ADPIntegrationExistsCREATE", TRUE_STR);
        }
        //CSYS-98407 SN. 02/2020
        if ((poID == "3780125") AND assetAction == CREATE_ACTION AND ownerBU_quote == "Enterprise BU" AND ownerMarket_quote == "Australia"){
            put(triggerDict, "concurDetectAustraliaExistsCREATE", TRUE_STR);
        }
        //CSYS-98725 SN. 01/2020
       	//CSYS-99594 SV 11/06/2020 Modified the logic below to include the poId = 6891736
        if ((poID == "6583098" OR poID == "6583498" OR poID == "6891736") AND assetAction == CREATE_ACTION ){
            put(triggerDict, "advancedCareExistsCREATE", TRUE_STR);
        }
        
        if ( poID == "2648653") {   /* CSYS-67244*/
            put(triggerDict, docNum + "~" + "onsiteDeliveryTrigger", docNum + "~" + "onsiteDeliveryTrigger" + TRIG_KEY_VALUE_DELIM + "TRUE");
        }

        rampPlanOverride = overrideDefaultRampPlan;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_OVERRIDE, rampPlanOverride);

        lineItemRampPlan = rampPlanDetailsFromGrid;
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL, lineItemRampPlan);

        /* -------------- Determine the number of transactions ------------ */
        //add on related - if numOfTransactions was given a value - use it.
        trxns = integer(numOfTransactions);
        if(trxns <> prevTrxns AND prevTrxns > 0){

            isTransOverridden = TRUE_STR;
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IS_TRANS_OVERRIDDEN, isTransOverridden);

            //Setting to Tier Change to True if prevTrxns has been changed - Ronald Mendoza
            if( quoteType_quote == ADD_ON AND itemType == BASE_FEE AND assetAction == MODIFY_ACTION){
                tierChange = TRUE_STR;
            }
            else{
                tierChange = FALSE_STR;
            }

            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, TIER_CHANGE, tierChange);

            // Store the new transactions for this model
            if ( itemType <> INCREMENTAL_FEE ){
                utilResultFlag = util.putIntegerAttribute( integersDict, docNum /*parentDocNum*/, DELIMITER, MODEL_NEW_TRANSACTIONS, trxns);
                currentPoGroupsForTrans = util.getStringAttribute( stringsDict, docNum /*parentDocNum*/, DELIMITER, PO_GROUPS_TRANS );
                currentPoGroupsForTrans = currentPoGroupsForTrans + poID + PO_DELIMITER;
                utilResultFlag = util.putStringAttribute( stringsDict, docNum /*parentDocNum*/, DELIMITER, PO_GROUPS_TRANS, currentPoGroupsForTrans );
                //CSYS-96788
                put( incrementalFeeTransactionDict, parentDocNum + DELIMITER + poID, trxns );
            }

        }
        // Store the standard transactions for the line
        elif ( itemType <> INCREMENTAL_FEE ){
            utilResultFlag = util.putIntegerAttribute( integersDict, parentDocNum, DELIMITER, MODEL_TRANSACTIONS, trxns );
            // Store the number of transactions for the incremental line items to access
            if ( isTransOverridden == TRUE_STR ){
                put( incrementalFeeTransactionDict, parentDocNum + DELIMITER + poID, trxns );
            }

            if ( trxns == originalTrxns AND quoteType_quote == ADD_ON AND itemType == BASE_FEE AND assetAction == MODIFY_ACTION){
                tierChange = FALSE_STR;
                utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, TIER_CHANGE, tierChange);
            }
        }
        //CSYS-95701 SN. Remove temp fix and check in new variable
        if(findinarray(travelAndExpenseWithTriplinkProductArr, pi) <> -1){
            rollup = "No";
        }
        incKey = parentDocNum + RAMP_DELIMITER + poID + RAMP_DELIMITER + rollup;
        // Save the incremental fee for this PO/model
        if ( itemType == INCREMENTAL_FEE ){
            utilResultFlag = util.putStringAttribute( stringsDict, incKey, DELIMITER, INCREMENTAL_FEE_FOR_PO, docNum );
        }

        if (isTransOverridden <> TRUE_STR AND assetAction <> TERMINATE_ACTION ) {

            //CSYS-71641 part 2: fix addon transaction issues. KA. 1-3-2017.
            //trxns = QUOTE_TRANSACTIONS; (old logic)
            //New logic:
            if(quoteType == ADD_ON AND assetAction == CREATE_ACTION AND poCategory <> CORE_SERVICE AND containskey(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans")){
                //Match non-core products' transactions to that of their core:
                trxns = get(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans");
            }
            else{
                //CSYS-94164
                if ( quoteType == ADD_ON AND (assetAction == CREATE_ACTION) AND poCategory == CORE_SERVICE AND containskey(coreTerminateTrxnDict, parentDocNum) AND reconfig == TRUE_STR){
                    if ( containskey(triggerDict, "customActionName") AND get(triggerDict, "customActionName") == "Reconfigure Inbound" AND containskey(triggerDict, "reconfiguredDocNum") AND get(triggerDict, "reconfiguredDocNum") == parentDocNum){
                        trxns = get(coreTerminateTrxnDict, parentDocNum);
                    }
                    else{
                        trxns = numOfTransactionsFromGrid;
                    }
                }
                else{
                    trxns = QUOTE_TRANSACTIONS;
                }
            }

            //For products whose transactions do not have to match that of their core, retain line transactions if the line item already exists:
            if(quoteType == ADD_ON AND assetAction == CREATE_ACTION AND poCategory <> CORE_SERVICE AND findinarray(listOfNumOfTransPOs,poID) == -1 AND NOT isFirstIteration){

                trxns = numOfTransactionsFromGrid;
            }

            //if trxns is ever 0 on the first iteration (excluding Invoice Check Payments), set trxns to quote transactions:
            if(quoteType == ADD_ON AND assetAction == CREATE_ACTION AND poCategory <> CORE_SERVICE AND
                isFirstIteration AND trxns == 0 AND poID <> "566" AND poID <> "416635"){
                trxns = QUOTE_TRANSACTIONS;
            }
            //CSYS-71641 part 2 END.

                //Commenting out this tierChange logic since tierChange is handled later:
                //Logic for Quote Level Tier Changes - Ronald Mendoza
                /*if( quoteType_quote == ADD_ON AND itemType == BASE_FEE AND assetAction == MODIFY_ACTION){
                        tierChange = TRUE_STR;
                }
                else{
                    tierChange = FALSE_STR;
                }

                if ( trxns == originalTrxns AND quoteType_quote == ADD_ON AND itemType == BASE_FEE AND assetAction == MODIFY_ACTION){
                    tierChange = FALSE_STR;
                }
                utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, TIER_CHANGE, tierChange);*/

        }

        //CSYS-91026 (LN. 10-9-2018) - CSYS-93886 (LN. 12-10-2018)
        if(poID == CONCUR_DETECT_PO AND itemType <> INCREMENTAL_FEE AND ( (assetAction == CREATE_ACTION and trxns >= 25000) OR (assetAction <> TERMINATE_ACTION AND assetAction <> CREATE_ACTION AND originalTrxns < 25000 AND trxns >= 25000))){
            put(triggerDict, "concurDetectTransactionGreaterEqual25K", TRUE_STR);
        }
        //CSYS-98981 SN. 04/2020
        if(editionlessUniversal_quote AND ownerBU_quote == SMB_BU AND quoteType == ADD_ON AND poID == "36309" AND assetAction == CREATE_ACTION AND implementationPlatform_quote == "Standard"){
            put(triggerDict, "permanentTestEnvironmentPlatformChange", TRUE_STR);
        }
        //UNCOMMENTING OUT CSYS-97101 SN. 09-2019, adding citeria for conditions
        //CSYS-93607 (LN. 10-25-2018) If Permanent Test Environment is added Net New (CREATE), trigger approvals up and through CFO
        //COMMENTING OUT (LN. 12-21-2018)
        if(poID == "36309" AND assetAction == CREATE_ACTION AND (trxns < 1000 OR discountFromGrid > 20)){
            //COMMENTING OUT CSYS-99541 SN. 06/2020
            /*if(ownerBU_quote == SMB_BU and trxns < 1000){
                put(triggerDict, "permanentTestEnvironmentExistsCREATE", TRUE_STR);
                permanentTestEnvironmentApprovalMessage = permanentTestEnvironmentApprovalMessage + "Please ensure the transaction count for Permanent Test Environment is 1000 per month.";
            }*/
            if (discountFromGrid > 20 AND discountFromGrid <> acctPartnerDiscount){
                put(triggerDict, "permanentTestEnvironmentExistsCREATE", TRUE_STR);
                permanentTestEnvironmentApprovalMessage = permanentTestEnvironmentApprovalMessage + " Please ensure Permanent Test Environment is not discounted more than 20%.";
            }
        }
        //CSYS-93735 (LN. 10-28-2018) If Concur FAVR (driveFAVR_concur) is added Net New (CREATE), trigger approvals up and through MGR
        if (poID == "4722310"){
            if(assetAction == CREATE_ACTION){
                put(triggerDict, "concurFavrExistsCREATE", TRUE_STR);
            }

            //CSYS-93973 If Concur FAVR is present on the Quote, set this flag to true and write to the attribute further down.
            if(assetAction <> TERMINATE_ACTION){
                concurFAVRExistInQuote = true;
            }
        }
        //CSYS-95230
        if (poID == "4999040" AND assetAction == CREATE_ACTION AND itemType == BASE_FEE){
            put(triggerDict, "procurementNetworkIntExistsCREATE", TRUE_STR);
        }

        //CSYS-93675 (LN. 11-07-2018) Universal Edition, if CREATE Professional Products exists on the Quote, append the poID (only once) to the 'createProfessionalUniversalArr'
        if(assetAction == CREATE_ACTION AND findinarray(usOfferProfessionalOnlyArr, poID) <> -1){
            if(findinarray(createProfessionalUniversalArr, poID) == -1){
                append(createProfessionalUniversalArr, poID);
            }
        }


        //CSYS-71641 part 3: make sure core service transactions stay intact if core or edition is changed and not reconfiguring:
        //Scenario: add-on business, core/edition change upon adding the core for the first time (not reconfiguring)
        if(quoteType == ADD_ON AND assetAction <> TERMINATE_ACTION AND poCategory == CORE_SERVICE AND NOT isFirstIteration AND
          (actionName == "submit" OR actionName == "request approval" OR actionName == "update" OR actionName == "Return to Opportunity") ){

            coreCreateWithinModel = false;
            coreTerminateWithinModel = false;

            if( containskey(stringsDict, parentDocNum + DELIMITER + "coreCreateWithinModel") ){
                coreCreateWithinModel = true;
            }
            if( containskey(stringsDict, parentDocNum + DELIMITER + "coreTerminateWithinModel") ){
                coreTerminateWithinModel = true;
            }
            //Not reconfiguring and core or edition already changed for this model:
            if(reconfig <> TRUE_STR AND coreCreateWithinModel AND coreTerminateWithinModel){
                if( containskey(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans") ){
                    trxns = get(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans");
                }
            }

        }
        //END CSYS-71641 part 3

        //CSYS-71641 part 4: process existing extended service line items, coming out of reconfiguring a core after swapping the core/edition in config:
        //Scenario: add-on business, core/edition change, returning to commerce from config (reconfigure inbound)
        if(quoteType == ADD_ON AND reconfig == TRUE_STR AND NOT isFirstIteration AND assetAction <> CREATE_ACTION
            AND assetAction <> TERMINATE_ACTION AND poCategory <> CORE_SERVICE AND findinarray(listOfNumOfTransPOs,poID) <> -1 AND
            containskey(triggerDict, "customActionName")
            ){

            isCoreChanged = "";
            isEditionChanged = "";
            customActionName = get(triggerDict, "customActionName");

            if( containskey(isCoreChangedDict, parentDocNum) ){
                isCoreChanged = get(isCoreChangedDict, parentDocNum); //grab the result of core change detection
            }
            if( containskey(isEditionChangedDict, parentDocNum) ){
                isEditionChanged = get(isEditionChangedDict, parentDocNum); //grab the result of edition change detection
            }
            /*coreCreateWithinModel = containskey(stringsDict, parentDocNum + DELIMITER + "coreCreateWithinModel"); //does a core create line item already exist?
            coreTerminateWithinModel = containskey(stringsDict, parentDocNum + DELIMITER + "coreTerminateWithinModel"); //does a core terminate line item already exist?

            coreCreateFirstIteration = containskey(stringsDict, parentDocNum + DELIMITER + "coreCreateFirstIteration");
            coreTerminateFirstIteration = containskey(stringsDict, parentDocNum + DELIMITER + "coreTerminateFirstIteration");*/

            if(customActionName == "Reconfigure Inbound" AND (isCoreChanged == TRUE_STR OR isEditionChanged == TRUE_STR)){ //core or edition changed in config for the first time and returning to commerce
                reconfiguredDocNum = get(triggerDict, "reconfiguredDocNum");
                if(parentDocNum == reconfiguredDocNum){ //silo the updates to the reconfigured model
                    if( containskey(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans") ){
                        trxns = get(integersDict, parentDocNum + DELIMITER + "AddOnCoreTrans");
                    }
                    else{
                        trxns = QUOTE_TRANSACTIONS;
                    }
                }

            }
        }
        //END CSYS-71641 part 4

        //CSYS-78922 (KA. 3-9-2017): Make sure incrementalFeeTransactionDict has a value at the poID key to avoid incorrect inflation of incremental fees
        if(assetAction == CREATE_ACTION AND piItemType <> INCREMENTAL_FEE){
            put( incrementalFeeTransactionDict, parentDocNum + DELIMITER + poID, trxns );
        }


        //CSYS-93247 (LN. 9-12-2018) - If Policy Audit or Audit Elite is being added to the quote for the first time together
        if( (poID == POLICY_AUDIT_PO OR poID == AUDIT_ELITE_PO) AND triggerAuditDefaultTrxn AND ( NOT(auditTransactionsDefaulted_quote) OR NOT(auditTransactionsDefaulted) ) ){

            //For the Audit Setup Fee, retrieve the number of transactions of the corresponding Core Service and apply to Audit
            if(piItemType <> INCREMENTAL_FEE AND containskey(integersDict, parentDocNum + DELIMITER + "defaultAuditTrxn")){
                coreSetupTrxn = get(integersDict, parentDocNum + DELIMITER + "defaultAuditTrxn");

                trxns = integer(round(coreSetupTrxn*(.3), 0));//Calculate 30% of the Cores Transactions
            }
            else{
                //Fail safe, if there is nothing stored for the Core Service Transaction, apply 30% of the Quote Level Transactions
                trxns = integer(round(QUOTE_TRANSACTIONS*(.3), 0));
            }

            utilResultString = util.formAttrValueStr(attributesDict, AUDIT_TRANSACTION_DEFAULTED, docNum, string(true));
        }

        //CSYS-93972 (LN. 12-5-2018) Capture the TRXN count of Policy Audit & Receipt Audit to then populate the Audit 48 Hour SLA for Policy/Receipt Audit
        if( (poID == POLICY_AUDIT_PO OR poID == RECEIPT_AUDIT_PO) AND assetAction <> TERMINATE_ACTION AND piItemType == BASE_FEE){
            put(integersDict, parentDocNum + DELIMITER + POLICY_RECEIPT_AUDIT_TRXN_COUNT, trxns);
        }

        // If we are incremental, we need to be set to the global number of transactions for line items, for now just append to the array to set later
        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, trxns);

        // AH 181910 2014/02/20 (2 of 4)
        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, ORIGINAL_TRANSACTIONS, originalTrxns);
        //End (2 of 4)
        //Setting OriginalNumberofTrans if TIER_CHANGE is false - Ronald Mendoza
        if(piItemType == BASE_FEE AND poCategory == CORE_SERVICE AND (quoteType_quote <> ADD_ON OR (quoteType_quote == ADD_ON AND assetAction <> TERMINATE_ACTION))){
            if(util.getIntegerAttribute(integersDict, parentDocNum, DELIMITER, "modelNumOfTransDict") == 0){ //integers dictionaries values are never null. They start out at 0.
                utilResultFlag = util.putIntegerAttribute( integersDict, parentDocNum, DELIMITER, "modelNumOfTransDict", trxns );
            }
        }

        //CSYS-49649 Fix. KA. 7-29-15. If user edits a Core Trxn field, overwrite the dictionary value.
        if(numOfTransactionsFromGrid <> prevTrxns AND piItemType == BASE_FEE AND poCategory == CORE_SERVICE AND (quoteType_quote <> ADD_ON OR (quoteType_quote == ADD_ON AND assetAction <> TERMINATE_ACTION))){
            utilResultFlag = util.putIntegerAttribute( integersDict, parentDocNum, DELIMITER, "modelNumOfTransDict", trxns );
        }

                //##################Approval ####################//
        // Line level approval triggers
        // By default, the number of transactions on the line level is "Monthly" basis.
        if ( billingCycleNumber == "12" ) {
            put(triggerDict, docNum + "~" + "annualTransaction", docNum + "~" + "annualTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 12));
        } elif ( billingCycleNumber == "3" ) {
            put(triggerDict, docNum + "~" + "quarterlyTransaction", docNum + "~" + "quarterlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns * 3));
        } else {
            put(triggerDict, docNum + "~" + "monthlyTransaction", docNum + "~" + "monthlyTransaction" + TRIG_KEY_VALUE_DELIM + string(trxns));
        }

        uomType = uomTypeFromGrid;
        put(triggerDict, docNum + "~" + "itemType", docNum + "~" + "itemType" + TRIG_KEY_VALUE_DELIM + itemType);
        poCategory = poCategoryFromGrid;
        put(triggerDict, docNum + "~" + "poCategory_line", docNum + "~" + "poCategory_line" + TRIG_KEY_VALUE_DELIM + poCategory); //00170952 - JV 10.10.2013
        put(triggerDict, docNum + "~" + "uomType", docNum + "~" + "uomType" + TRIG_KEY_VALUE_DELIM + uomType);

        /* Populate containers for relating line items to the parent Model  */
        if (parentDocNum <> "") {
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM, parentDocNum);

            //CSYS-75571 (KA. 1-19-2019): commenting out the block below and moving to new util (sortModelToLineDictionaries):
            //Populate the modelToLineDocNumsDict
            /*
            lineDocNums = string[];
            if (containskey(modelToLineDocNumsDict, parentDocNum)) {
                lineDocNums = get(modelToLineDocNumsDict, parentDocNum);
            }

            append(lineDocNums, docNum);
            put(modelToLineDocNumsDict, parentDocNum, lineDocNums);
            //Populate the modelToLinePartNumsDict
            linePartNums = string[];

            if (containskey(modelToLinePartNumsDict, parentDocNum)) {
                linePartNums = get(modelToLinePartNumsDict, parentDocNum);
            }
            append(linePartNums, docNum);
            put(modelToLinePartNumsDict, parentDocNum, linePartNums);
            */

            //Populate the implementationMethod
            modelImplementationMethod = util.getStringAttribute(stringsDict, parentDocNum, DELIMITER, CONFIG_IMPLEMENTATION_METHODS);
            // Required for Promotion
            append(implementationMethodArr, modelImplementationMethod);

            //add on related ,added if inorder to omitt promotions for NONE Line items
            //CSYS-99236
            if(/*assetAction <> NONE_ACTION AND assetAction <> MODIFY_ACTION AND*/ assetAction <> TERMINATE_ACTION){
                append(partNumArr, pi);
                //put(stringsDict, pi, assetAction);
                if(assetAction <> CREATE_ACTION){
                    utilResultFlag = util.putStringAttribute(stringsDict, pi, DELIMITER, "partNumberNotValidForPromo", assetAction);
                }
            }
        }

        /* ------------------------ Calculate Line Item Ramp Plans ---------------------- */

        rampFlag = rampFlagFromGrid;
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, RAMP_FLAG, rampFlag );
        rampPlanOverride = util.getStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_OVERRIDE);

        // Store rampPlanOverride for the Model + PO
        if ( rollup == "Y" AND itemType == BASE_FEE ){
            utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, PO_RAMP_OVERRIDE, rampPlanOverride );
            utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, ROLLUP_DOC_NUM, docNum );
            utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum, DELIMITER, PRIMARY_BASE_FEE, docNum );
        }
        elif ( itemType == BASE_FEE ){
            existingRollupDocNum = util.getStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, ROLLUP_DOC_NUM );

            if ( existingRollupDocNum == "" ){
                utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, PO_RAMP_OVERRIDE, rampPlanOverride );
                utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, ROLLUP_DOC_NUM, docNum );
            }
        }



        //AH 181910 2014/02/20 (3 of 4) ~Replaces other logic for tierChange
        tierChange = FALSE_STR;
        if(quoteType_quote == ADD_ON AND itemType == BASE_FEE AND ( assetAction <> CREATE_ACTION OR (assetAction == CREATE_ACTION AND poCategory == CORE_SERVICE AND containskey(coreTerminatesTrxnDict, parentDocNum)) ) ){ //CSYS-51476
            //94033
            if (assetAction == CREATE_ACTION){
                originalTrxns = get(coreTerminatesTrxnDict, parentDocNum);
            }

            //CSYS-88632 Part 1 of 3 (LN. 2/19/2018)
            //if(poCategory == CORE_SERVICE){
                //For each core service evaluate if there has been a tier increase/decrease and map to the dictionary

                if (trxns <> originalTrxns){
                    tierChange = TRUE_STR;
                    if(trxns > originalTrxns){
                        put(CORE_TIER_INCREASE, parentDocNum + DELIMITER + "coreTierIncrease_line", TRUE_STR);
                    } else {
                        put(CORE_TIER_DECREASE, parentDocNum + DELIMITER + "coreTierDecrease_line", TRUE_STR);
                    }
                    if (quoteTierChange == FALSE_STR){
                        quoteTierChange = TRUE_STR;
                    }
                }
            //}
        }

        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, TIER_CHANGE, tierChange);
        //End (3 of 4)
        //CSYS-97861
        tierIncrease = FALSE_STR;
        tierDecrease = FALSE_STR;
        if (orderEffectiveDate_quote <> ""  AND NOT isnull(orderEffectiveDate_quote) AND quoteType_quote == ADD_ON AND itemType == BASE_FEE AND /* assetAction <> TERMINATE_ACTION AND */ trxns <> 0 AND originalTrxns <> 0){
            if (trxns < originalTrxns){
                utilResultString = util.formAttrValueStr(attributesDict, "lastTierDecrease_line", docNum, datetostr(util.getDateFromString(orderEffectiveDate_quote)));
                tierDecrease = TRUE_STR;
            }
            elif (trxns > originalTrxns){
                assetTierDecreaseDate = util.getStringAttribute(stringsDict, docNum, DELIMITER, "LastTierDecreaseDate");
                if (assetTierDecreaseDate <> "" AND NOT isnull(assetTierDecreaseDate)){
                    if ( displayARRCommissionsAlert == false ){
                        if (util.getDifferenceInMonths(assetTierDecreaseDate, orderEffectiveDate_quote) <= 12 ){
                            displayARRCommissionsAlert = true;
                        }
                    }
                    utilResultString = util.formAttrValueStr(attributesDict, "lastTierDecrease_line", docNum, assetTierDecreaseDate);
                }
                tierIncrease = TRUE_STR;
            }
            else{
                assetTierDecreaseDate = util.getStringAttribute(stringsDict, docNum, DELIMITER, "LastTierDecreaseDate");
                if (assetTierDecreaseDate <> "" AND NOT isnull(assetTierDecreaseDate)){
                    utilResultString = util.formAttrValueStr(attributesDict, "lastTierDecrease_line", docNum, assetTierDecreaseDate);
                }
            }
        }
        utilResultString = util.formAttrValueStr(attributesDict, "tierDecrease_line", docNum, tierDecrease);
        utilResultString = util.formAttrValueStr(attributesDict, "tierIncrease_line", docNum, tierIncrease);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, LONG_DISCOUNT, disc); //CSYS-52578. KA. 10-12-2015

    } else {
        modelImplementationMethod = util.getConfigValue(configAttrInfo, CONFIG_IMPLEMENTATION_METHODS);
        // LFodge,  00100538
        modelPoPriority = util.getConfigValue(configAttrInfo, MODEL_PO_PRIORITY );

        //Added by Andre Lancour for Case 119146
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, MODEL_PO_PRIORITY, modelPoPriority );
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, CONFIG_IMPLEMENTATION_METHODS, modelImplementationMethod);
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, MODEL_HAS_GROUPING, FALSE_STR );
        coreOffering = util.getConfigValue( configAttrInfo, CONFIG_CORE_OFFERING );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, CORE_OFFERING, coreOffering );
        //BI = util.getConfigValue( configAttrInfo, "businessIntelligence_concur" ); //Oracle didn't update this to their new attr created in the UI/UX overhaul, so rewriting to the line below:
        //BI = util.getConfigValue( configAttrInfo, "businessIntelligenceSSM_concur" ); //uses new config attr
        /*
        if(BI<>""){
            put(modelContainsBI,docNum,TRUE_STR);
        }
        */
        if(coreOffering <> "") {
            append(listOfCore,coreOffering);
            append(listOfIM,modelImplementationMethod);
        }

        //add on related - start
        //append(parentDNarray,docNum);
        //add selected service ID to string:
        configuredAssetsService = configuredAssetsService + "!^!" + util.getConfigValue(configAttrInfo, "currentAssetSAId_concur");
        //add on related - end

        modelName = modelNameFromGrid;
        modelDesc = "Concur " + modelName + " " + coreOffering + " - " + modelImplementationmethod + " Implementation";
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, PO_NAME, modelDesc );
        
        // CSYS-98942 MJ, give product number quantity of 1 so it can be added to favorites
    utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, "_price_quantity", 1);
    }
    /* case 85005 May 14 2012*/
    utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, DISCOUNT, disc);
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD, modelImplementationMethod);
        // Functionality to store greatest line disc amount. Added by jhartman 5/14 - Do not remove.

    if (((piItemType == "Setup" OR piItemType == "Pre Prod" OR piItemType == "Base" OR piItemType == "Incremental") AND (uomTypeFromGrid == "TRXN")) OR ((piItemType == "Setup" OR piItemType == "Base" OR piItemType == "Incremental") AND (uomTypeFromGrid == "QTY"))){
        if (discountPercentFromGrid > greatestLineDisc){
            greatestLineDisc = discountPercentFromGrid;
            highestDiscountItemType = piItemType;
        }
    }

    //CSYS-95500
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "unitBasedProductCanBeRamped_line", string(unitBasedProductCanBeRamped));
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "unitBasedProductCanUseOverridePrice_line", string(unitBasedProductCanUseOverridePrice));
    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "pricebookChange_line", string(pricebookChange));//CSYS-95251 (LN. 5-1-2019)
}
//CSYS-97101 SN. 09-2019
utilResultString = util.formAttrValueStr(attributesDict, "permanentTestEnvironmentApprovalMessage_quote", QUOTE_DOC_NUM, permanentTestEnvironmentApprovalMessage);
//debugLogStr = debugLogStr + "*************Pricing**********" + "\n";
//utilResultString = util.formAttrValueStr(attributesDict, "debugLog", QUOTE_DOC_NUM, debugLogStr);
//94033
utilResultString = util.formAttrValueStr(attributesDict, "tierChange_quote", QUOTE_DOC_NUM, quoteTierChange);
//CSYS-93675 (LN. 11-7-2018) If there are poIDs present in the 'createProfessionalUniversalArr', indicating that there is at least 1 CREATE Professional ONLY product on a Universal Quote, trigger approvals up and through EVP
if(sizeofarray(createProfessionalUniversalArr) > 0){
    put(triggerDict, "universalProfessionalProductsExistsCREATE", TRUE_STR);
}
//CSYS-97861
utilResultString = util.formAttrValueStr(attributesDict, "aRRAdjustmentAlert_quote", QUOTE_DOC_NUM, string(displayARRCommissionsAlert));

//CSYS-93973 (LN. 11-9-2018) Write to the "concurFAVRRequired_quote" indicating whether or not the Concur FAVR is present on the Quote to print legal language on the Contract
utilResultString = util.formAttrValueStr(attributesDict, "concurFAVRRequired_quote", QUOTE_DOC_NUM, string(concurFAVRExistInQuote));

//CSYS-93247 (LN. 9-12-2018)
utilResultString = util.formAttrValueStr(attributesDict, "auditTransactionsDefaulted_quote", QUOTE_DOC_NUM, string(auditTrxnDefaulted));
//CSYS-87441 (LN. 1/2/2018) Moving this further up to make further room in Pricing f(x)
utilResultString = util.formAttrValueStr(attributesDict, "greatestLineDisc_quote", QUOTE_DOC_NUM, string(greatestLineDisc));
utilResultString = util.formAttrValueStr(attributesDict, "highestDiscountItemType_quote", QUOTE_DOC_NUM, highestDiscountItemType);
utilResultString = util.formAttrValueStr(attributesDict, "configuredAssets_quote", QUOTE_DOC_NUM, configuredAssetsService);

//CSYS-87441 (LN. 1/2/2018) Moving this further up to make further room in Pricing f(x)
if(addOnNumOfTrans <> "-1" AND numCommittedTransaction_quote <1){
    utilResultString = util.formAttrValueStr(attributesDict, "numCommittedTransaction_quote", QUOTE_DOC_NUM, addOnNumOfTrans);
}

//CSYS-87441 (LN. 1/2/2018) Moving this further up to make further room in Pricing f(x)
//setting preprodfeeFlag for Addons
utilResultString = util.formAttrValueStr(attributesDict, QUOTE_HAS_PREPROD_FEE, QUOTE_DOC_NUM, string(hasPreprodFeeForAddons));


//for CSYS 37711 part 3
baseCnt = 0;
incToBaseDict = dict("string");
for basePi in baseArray {
    put(incToBaseDict, basePi, incArray[baseCnt]);
    baseCnt = baseCnt + 1;
}

/*print "modelToLineDocNumsDict:";
print modelToLineDocNumsDict;
print "modelToLinePartNumsDict:";
print modelToLinePartNumsDict;*/

//CSYS-75571 (KA. 1-19-2017):
//The purpose of the next 2 dictionaries is to solve docNum sorting discrepancies spawned from core/edition change in config:
modelToLineDocNumsDictCustom = dict("string[]");
modelToLinePartNumsDictCustom = dict("string[]");
sortModelDicts = util.sortModelToLineDictionaries(modelToLineDocNumsDictCustom, modelToLinePartNumsDictCustom, seqNumArray, seqNumAttributeMappingDict);

//set the modeltoLine dictionaries to the new dictionaries built in the setModelDicts util library,
//only if the util succeeded in populating the new dictionaries:
if(sortModelDicts == "EXECUTED"){
    modelToLineDocNumsDict = modelToLineDocNumsDictCustom;
    modelToLinePartNumsDict = modelToLinePartNumsDictCustom;
}
//CSYS-75571 END

/*print "modelToLineDocNumsDictCustom:";
print modelToLineDocNumsDictCustom;
print "modelToLinePartNumsDictCustom:";
print modelToLinePartNumsDictCustom;*/

// *************** Reorganize the line items based on config data ***************
docNumList = util.sortLineItems( stringsDict, integersDict, floatsDict, docNumlist );

//capture data for Monthly Transactions Validation Rule
rez = BMQL("SELECT PO FROM trnsValidation WHERE PO in $fullPOlist");
listOfFixedTransactionNum = string[];
for entry in rez{
    append(listOfFixedTransactionNum,get(entry,"PO"));
}
utilResultDict = util.getPartFields(piList, CUSTOM_FIELD_DICT, stringsDict, DELIMITER);

/* ***************** CALCULATE NEW TRANSACTIONS ****************
This is used to update the transactions of all line items after the initial information gathering process.*/
utilResultString = util.updateTransactionsAfterAttributeGathering(stringsDict, integersDict, floatsDict, overwriteTransactionArr, piDict, incrementalFeeTransactionDict, billingCycleNumber, QUOTE_TRANSACTIONS, quoteType_quote, oRGNumberOfComittedTransactions_quote, triggerDict);

//print "---NEW triggerDict after update--";
//print triggerDict;

//Setup Only detection
addonHasSetup = false;
ignoreSetupCheck = false;
arrInvolved = false;
ignoreNonModifySetupCheck = false;//CSYS-99043
//CSYS-95378
addonHasExtServ = false;
ignoreExtServCheck = false;

//TandM_BillingExceptionNotes = "";

// add on related Generate values for ramp plans and re-evaluate actions


for docNum in docNumlist{
    //first thing - evaluate if a change is needed with the action:
    parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM);
    actionSwitch = util.getStringAttribute(stringsDict, parentDocNum, DELIMITER, "assetGroupMappingDict");
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    isGrouped = util.getStringAttribute( stringsDict, docNum, DELIMITER, IS_GROUPED);
    poID = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_ID );
    itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
    //poCategory = util.getStringAttribute( stringsDict, docNum, DELIMITER, PO_CATEGORY + "***" );
    poCategory = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_CATEGORY);//CSYS-88632
    isCoreChanged = get(isCoreChangedDict, parentDocNum); //grab the result of core change detection
    isEditionChanged = get(isEditionChangedDict, parentDocNum); //grab the result of edition change detection
    assetAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    isFirstIteration = util.getStringAttribute(stringsDict, docNum, DELIMITER, "isFirstIteration_line");
    pricebookChangeDetected = util.getStringAttribute(stringsDict, docNum, DELIMITER, "pricebookChange_line");
    pi = util.getStringAttribute( stringsDict, docNum, DELIMITER, PART_NUM );//CSYS-95591
    productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106; CSYS-95591

    reconfig = get(stringsDict, "reconfigure"); //prevent runtime error

    //CSYS-93972 (LN. 12-5-2018) Populate the Audit 48 Hour SLA for Policy/Receipt Audit to match the TRXN count of Policy/Receipt Audit
    if( (poID == AUDIT_48_HOUR_POLICY_AUDIT_PO OR poID == AUDIT_48_HOUR_RECEIPT_AUDIT_PO) AND itemType <> INCREMENTAL_FEE AND assetAction <> TERMINATE_ACTION AND containskey(integersDict, parentDocNum + DELIMITER + POLICY_RECEIPT_AUDIT_TRXN_COUNT)){
        trxns = get(integersDict, parentDocNum + DELIMITER + POLICY_RECEIPT_AUDIT_TRXN_COUNT);

        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, trxns);
    }

    if(isFirstIteration == TRUE_STR AND reconfig == FALSE_STR AND assetAction == CREATE_ACTION AND quoteType_quote == "Add-On Business"){

        myTrxns = get(stringsDict, "originalTrans");
        if (isnumber(myTrxns)){
            utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, atoi(myTrxns));
        }
    }

    if(isFirstIteration == TRUE_STR AND reconfig == FALSE_STR AND assetAction == MODIFY_ACTION AND quoteType_quote == "Add-On Business"){
        myTrxns = get(stringsDict, docNum + "currentAssetTrxns");
        if (isnumber(myTrxns)){
            utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, atoi(myTrxns));
        }
    }

    if(actionSwitch <> "none"){//if a change is needed: add on related
        if(currentAction == NONE_ACTION AND (actionSwitch == "all" OR (actionSwitch == "group" and isGrouped == TRUE_STR))) {
            currentAction = MODIFY_ACTION;//change the action to MODIFY
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER,ASSET_ACTION,currentAction);//and store the new value
            put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + itemType, MODIFY_ACTION);
        }
    }

    //CSYS-92516 (LN. 8-27-2018) Fixing the issue for Add-ons, when one item in a bundle changes, the entire bundle must equal MODIFY
    if( currentAction == NONE_ACTION AND bundleIsModify AND isGrouped == TRUE_STR AND containskey(stringsDict, parentDocNum + DELIMITER + "bundleIsModify")) {
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, MODIFY_ACTION);//and store the new action code of MODIFY
        put(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + itemType, MODIFY_ACTION);
    }

    if(currentAction <> TERMINATE_ACTION AND currentAction <> CREATE_ACTION AND containskey(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + BASE_FEE) ){

        if(containskey(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + INCREMENTAL_FEE)){

            baseAction = get(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + BASE_FEE);
            incAction = get(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + INCREMENTAL_FEE);

            if(baseAction == NONE_ACTION AND incAction == NONE_ACTION){
                currentAction = NONE_ACTION; //change the action to NONE
            }
            else{
                currentAction = MODIFY_ACTION; //change the action to MODIFY
            }

        }
        else {//CSYS-85237 (LN. 10/20/2017) (deals with products that have a base fee but no inc fee):

            baseAction = get(stringsDict, poID + DELIMITER + "itemTypeActionSync" + DELIMITER + BASE_FEE);

            if(baseAction == NONE_ACTION){
                currentAction = NONE_ACTION; //change the action to NONE
            }
            else{
                currentAction = MODIFY_ACTION; //change the action to MODIFY
            }

        }

        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, currentAction ); //and store the new value
    }

    //CSYS-65212: Overwrite action code for Invoice Check Payments to set it back to NONE (if applicable). KA. 8-30-2016.
    if(currentAction <> TERMINATE_ACTION AND currentAction <> CREATE_ACTION and
        containskey(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + BASE_FEE) AND
        containskey(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + INCREMENTAL_FEE)){

        baseAction = get(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + BASE_FEE);
        incAction = get(stringsDict, poID + DELIMITER + "InvoiceCheckPaymentsActionSync" + DELIMITER + INCREMENTAL_FEE);

        if(baseAction == NONE_ACTION AND incAction == NONE_ACTION){
            currentAction = NONE_ACTION; //change the action to NONE
        }
        else{
            currentAction = MODIFY_ACTION; //change the action to MODIFY
        }

        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER,ASSET_ACTION,currentAction); //and store the new value
    }
    // end add on logic

    lineItemRampPlan = "";
    transArr = String[];
    fromNodeArr = String[];
    toNodeArr = String[];
    fromNodeStr = ""; // Use *.* delimiter to separate different from entries
    toNodeStr = ""; // Use *.* delimiter to separate different to entries
    rampPlanOverride = util.getStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_OVERRIDE);
    rampFlag = util.getStringAttribute( stringsDict, pi, DELIMITER, RAMP_FLAG );
    utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, RAMP_FLAG, rampFlag );
    lineItemRampPlan = util.getStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL);

    //CSYS-88632 Part 2 of 3 START (LN. 2/19/2018)
    if(poCategory == CORE_SERVICE){
        //if there is a tier increase at the parentDocNum continue
        if(containskey(CORE_TIER_INCREASE, parentDocNum + DELIMITER + "coreTierIncrease_line")){
            //if the parentDocNum is not currently present in the tierIncreaseArray, add it to the array
            if(findinarray(tierIncreaseArray, parentDocNum) == -1){
                append(tierIncreaseArray, parentDocNum);
            }

        }
        //if there is a tier increase at the parentDocNum continue
        if(containskey(CORE_TIER_DECREASE, parentDocNum + DELIMITER + "coreTierDecrease_line") ){
            //if the parentDocNum is not currently present in the tierDecreaseArray, add it to the array
            if(findinarray(tierDecreaseArray, parentDocNum) == -1){
                append(tierDecreaseArray, parentDocNum);
            }
        }
    }
    //CSYS-88632 Part 2 of 3 END

    if (rampPlanOverride <> TRUE_STR OR lineItemRampPlan == "") {

        lineItemRampPlan = QUOTE_LEVEL_RAMP_PLAN;
        trxnCount = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);

        newTransactionValues = util.getNewTransactionValues(QUOTE_RAMP_PLAN_TRANSACTION_RATIOS, trxnCount);

        //CSYS-70410 (KA. 1-10-2017): correct the ramp plan transactions if necessary:
        if( NOT isempty(newTransactionValues) ){
            transCnt = 0; //index of the value in the array
            for transValue in newTransactionValues {
                if( isNumber(transValue) ){
                    if(trxnCount < 10){ //if less than 10 transactions is committed to this product on the grid
                        newTransactionValues[transCnt] = string(trxnCount); //set to line transactions
                    }
                    elif( atoi(transValue) < 10 ){ //if less than 10 transactions is NOT committed to this product on the the grid AND the ratio affected value is below 10 (usually this will be a multi-core scenario)
                        newTransactionValues[transCnt] = quoteRampTransactionStrings[transCnt]; //set to quote ramp plan transactions
                    }
                    transCnt = transCnt + 1;
                }
            }
        }
        //END CSYS-70410

        transArr = newTransactionValues;

        transString = join( transArr, DELIMITER );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TRANS_STRING, transString );

        newLineItemRampPlan = util.spliceXMLNodeValuesExtended(lineItemRampPlan, TRANSACTION_XML_NODE_NAME, newTransactionValues, RAMP_PARENT_NODE);
        fromNodeArr = util.getXMLNodeValues(lineItemRampPlan, "from");

        for fromNode in fromNodeArr {
            fromNodeStr = fromNodeStr + fromNode + "*.*";
        }

        toNodeArr = util.getXMLNodeValues(lineItemRampPlan, "to");

        for toNode in toNodeArr {
            toNodeStr = toNodeStr + toNode + "*.*";
        }

        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, FROM, fromNodeStr );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TO, toNodeStr );
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL, newLineItemRampPlan );
        utilFlagResult = util.putStringAttribute( stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL_SAVE_XML, newLineItemRampPlan );
    } else {
        if (rampFlag == PCF_YES and rampPlanOverride == TRUE_STR) {
            // If we override the ramp plan, it needs to stay exactly the same except for its final value, that must be the number of transactions.
            lineItemRampPlan = util.getStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL);
            lineRampPlanTransactionString = util.getXMLNodeValues(lineItemRampPlan, "transactions");    //This will be a string array, e.g. ["100", "200", "300", "400", "500"]
            trxnCount = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
            //Change the highest value to the number of transactions.
            highestTransactionIndex = sizeofarray( lineRampPlanTransactionString ) - 1;

            if ( highestTransactionIndex >= 0 ){
                lineRampPlanTransactionString[highestTransactionIndex] = string(trxnCount);
            }

            lineRampFromMonths = util.getXMLNodeValues(lineItemRampPlan, FROM); //This will be a string array, e.g. ["1", "2", "3"]
            utilResultString = util.formAttrValueStr(attributesDict, LINE_RAMP_FROM_MONTHS, docNum, join( lineRampFromMonths, DELIMITER )); //ramp delete integration upgrade. KA 10-5-15

            //CSYS-86115 (parse any user-entered Base Fee Net/Inc Fee Net prices. KA. 10-16-2017):
            //CSYS-95895
            //if(actionName <> "revise"){
                userBaseFeeNetArr = util.getXMLNodeValues(lineItemRampPlan, "baseFeeNet");
                userIncreFeeNetArr = util.getXMLNodeValues(lineItemRampPlan, "increFeeNet");
                rampIndex = 0;

                print " I AM HERE IN PRICING";
                print userBaseFeeNetArr;
                for eachBaseFeeNet in userBaseFeeNetArr{
                    eachBaseFeeNet = eachBaseFeeNet;
                    
                    if(find(eachBaseFeeNet, " ") <> -1){
                        eachBaseFeeNet = replace(eachBaseFeeNet, " ", "");
                    }
                    
                    //CSYS-99592 (O.C. 6-10-2020)  Resolve CHF User Defined Ramp Pricing
                    if(find(eachBaseFeeNet, "'") <> -1){
                        eachBaseFeeNet = replace(eachBaseFeeNet, "'", "");
                    }
                    
                    if(isNumber(replace(eachBaseFeeNet, ",", ""))){
                        //CSYS-97407 (LN. 12-11-2019) Ensure that those BRL/EUR/CHF Currencies format correctly
                        //CSYS-98706 (OC. 05-01-2020) DKK/NOK/SEK currency formats
                        // DKK  kr 1.234,12
                        // NOK  kr 1 234,12
                        // SEK  1 234,12 kr  
                        print "eachBaseFeeNet here:";
                        print eachBaseFeeNet;
                        eachBaseFeeNetFormatted = "";
                        if(quoteCurrency_quote == "BRL" OR quoteCurrency_quote == "EUR" OR quoteCurrency_quote == "DKK" OR quoteCurrency_quote == "NOK" OR quoteCurrency_quote == "SEK"){

                            eachBaseFeeNetFormat = eachBaseFeeNet;
                            if(find(eachBaseFeeNet, ".") <> -1){
                                eachBaseFeeNetFormat = replace(eachBaseFeeNet, ".", "");
                            }
                            if(find(eachBaseFeeNet, " ") <> -1){
                                eachBaseFeeNetFormat = replace(eachBaseFeeNetFormat, " ", "");
                            }
                            eachBaseFeeNetFormatted = replace(eachBaseFeeNetFormat, ",", ".");
                        }
                        else {
                            eachBaseFeeNetFormatted = replace(eachBaseFeeNet, ",", "");
                        }

                        //this will be used in calculateUnifiedPricing and calculateProdBasedPricing util libraries:

                        if(quoteCurrency_quote <> "USD"){//CSYS-95310 (L.N. 6-24-2019) Reverse Currency Conversion to get User Entered Pricing in USD and then trickle through Pricing as expected.
                            put(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userBaseFeeNet", atof(eachBaseFeeNetFormatted));
                            conversionResult = util.convertDictCurrency( floatsDict, docNum + RAMP_DELIMITER + string(rampIndex), DELIMITER, "userBaseFeeNet", 1/conversionRate, 7 );

                            eachBaseFeeNetFormatted = string(round(get(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userBaseFeeNet"), 7));//Decimal Precision
                        }

                        put(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userBaseFeeNet", atof(eachBaseFeeNetFormatted));

                    }

                    rampIndex = rampIndex + 1;
                }
                rampIndex = 0;
                for eachIncFeeNet in userIncreFeeNetArr{
                    eachIncFeeNet = eachIncFeeNet;

                    if(find(eachIncFeeNet, " ") <> -1){
                        eachIncFeeNet = replace(eachIncFeeNet, " ", "");
                    }
                    
                    //CSYS-99592 (O.C. 6-10-2020)  Resolve CHF User Defined Ramp Pricing
                    if(find(eachIncFeeNet, "'") <> -1){
                        eachIncFeeNet = replace(eachIncFeeNet, "'", "");
                    }
                    
                    if(isNumber(replace(eachIncFeeNet, ",", ""))){
                        //CSYS-97407 (LN. 12-11-2019) Ensure that those BRL/EUR/CHF Currencies format correctly
                        //CSYS-98706 (OC. 05-01-2020) DKK/NOK/SEK currency formats
                        // DKK  kr 1.234,12
                        // NOK  kr 1 234,12
                        // SEK  1 234,12 kr  
                        eachIncFeeNetFormatted = "";
                        if(quoteCurrency_quote == "BRL" OR quoteCurrency_quote == "EUR" OR quoteCurrency_quote == "DKK" OR quoteCurrency_quote == "NOK" OR quoteCurrency_quote == "SEK"){
                            //eachInFeeNetFormat = replace(replace(eachIncFeeNet, ".", ""), " ", "");
                            
                            eachInFeeNetFormat = eachIncFeeNet;
                            if(find(eachIncFeeNet, ".") <> -1){
                                eachInFeeNetFormat = replace(eachIncFeeNet, ".", "");
                            }
                            if(find(eachIncFeeNet, " ") <> -1){
                                eachInFeeNetFormat = replace(eachInFeeNetFormat, " ", "");
                            }

                            eachIncFeeNetFormatted = replace(eachInFeeNetFormat, ",", ".");
                        }
                        else {
                            eachIncFeeNetFormatted = replace(eachIncFeeNet, ",", "");
                        }
                        //this will be used in calculateUnifiedPricing and calculateProdBasedPricing util libraries:

                        if(quoteCurrency_quote <> "USD"){//CSYS-95310 (L.N. 6-24-2019) Reverse Currency Conversion to get User Entered Pricing in USD and then trickle through Pricing as expected.
                            put(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userIncFeeNet", atof(eachIncFeeNetFormatted));
                            conversionResult = util.convertDictCurrency( floatsDict, docNum + RAMP_DELIMITER + string(rampIndex), DELIMITER, "userIncFeeNet", 1/conversionRate, 7 );

                            eachIncFeeNetFormatted = string(round(get(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userIncFeeNet"), 7));//Decimal Precision
                        }

                        put(floatsDict, docNum + RAMP_DELIMITER + string(rampIndex) + DELIMITER + "userIncFeeNet", atof(eachIncFeeNetFormatted));


                    }

                    rampIndex = rampIndex + 1;
                }
            //}

            transArr = lineRampPlanTransactionString;
            transString = join( transArr, DELIMITER );

            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TRANS_STRING, transString );
            newLineItemRampPlan = util.spliceXMLNodeValuesExtended(lineItemRampPlan, TRANSACTION_XML_NODE_NAME, lineRampPlanTransactionString, RAMP_PARENT_NODE);
            fromNodeArr = util.getXMLNodeValues(lineItemRampPlan, "from");

            for fromNode in fromNodeArr {
                fromNodeStr = fromNodeStr + fromNode + "*.*";
            }

            toNodeArr = util.getXMLNodeValues(lineItemRampPlan, "to");

            for toNode in toNodeArr {
                toNodeStr = toNodeStr + toNode + "*.*";
            }

            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, FROM, fromNodeStr );
            utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TO, toNodeStr );
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL, newLineItemRampPlan);
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_DETAIL_SAVE_XML, newLineItemRampPlan);
        }
    }

    //CSYS-95500 (LN. 4-12-2019) First check to see if the Core Service has more than one ramp applied
    if(poCategory == CORE_SERVICE AND itemType == BASE_FEE AND currentAction <> TERMINATE_ACTION ){
        toNodeArr = split(util.getStringAttribute(stringsDict, docNum, DELIMITER, TO), "*.*");

        if(toNodeArr[0] <> "and beyond"){//More than one ramp is applied to the Core Service
            put(stringsDict, parentDocNum + DELIMITER + "coreServiceHasRampsApplied", TRUE_STR);

            if(rampPlanOverride == TRUE_STR){
                put(stringsDict, parentDocNum + DELIMITER + "coreServiceOverrideRampPlan", TRUE_STR);
            }
        }
    }

    //CSYS-44734 and CSYS-47536 (part 1)
    //CSYS-95378
    if(quoteType_quote == ADD_ON){
        if(currentAction == CREATE_ACTION){ //addon quote has a setup fee
            if (itemType == SETUP_FEE){
                addonHasSetup = true;
            }
            if(poCategory == EXT_SERVICE){
                addonHasExtServ = true;
            }
            //CSYS-98752
            if(poCategory == "Professional Service"){
                addonHasProfServ = true;
            }
        }
        //CSYS-99043
        if((itemType <> SETUP_FEE AND currentAction == CREATE_ACTION) OR currentAction == TERMINATE_ACTION){ //if there was anything else done to the quote besides just adding a setup fee 
            ignoreNonModifySetupCheck = true;
        }
        if((itemType <> SETUP_FEE AND currentAction == CREATE_ACTION) OR currentAction == MODIFY_ACTION OR currentAction == TERMINATE_ACTION){ //if there was anything else done to the quote besides just adding a setup fee
            ignoreSetupCheck = true;
        }
        if((itemType <> SETUP_FEE AND poCategory <> EXT_SERVICE AND currentAction == CREATE_ACTION) OR currentAction == MODIFY_ACTION OR currentAction == TERMINATE_ACTION){
            ignoreExtServCheck = true;
        }
        //CSYS-98752
        if((poCategory <> "Professional Service" AND currentAction == CREATE_ACTION) OR currentAction == MODIFY_ACTION OR currentAction == TERMINATE_ACTION){ //if there was anything else done to the quote besides just adding a setup fee
            ignoreProfServCheck = true;
        }
    }

    //CSYS-44734 ARR check part 1
    if(itemType == BASE_FEE AND (currentAction == CREATE_ACTION OR currentAction == MODIFY_ACTION OR currentAction == TERMINATE_ACTION)){
        arrInvolved = true;
    }

    //Bundle Incremental fix part 1 for CSYS-39318. Part 2 is in calculateprodbasedpricing util.
    //This maps the asset action to each PI so we can see if the PI pulled from the productDependentPIs table is a TERMINATE on the grid
    //myPi = get(primeStringsDict, docNum + DOCNUM_DELIM + "_part_number");
    myPi = get(piDict, docNum);
    put(stringsDict, myPi + ACTION_DELIMITER, currentAction);

    //CSYS-95251 (LN. 5-2-2019)
    if(get(stringsDict, docNum + DELIMITER + ASSET_ACTION) == MODIFY_ACTION AND pricebookChangeDetected == TRUE_STR){
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, "pricebookChange_line", FALSE_STR);
    }

    //CSYS-97924 (MJ 1/13/2020) 
    if(pi == PARTNER_EXPANSION_SKU_PI) {
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, NONE_ACTION);   
    }
    
    //CSYS-98798 MJ 5/19/20
    if(pi == PARTNER_IMPLEMENTATION_PI) {
        utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION, NONE_ACTION);   
    }

    //CSYS-87106 (LN.1/2/2018) For Add-On's & Base Fee's if TERMINATE or CREATE store the Product Family at the PI (part number)
    //CSYS-95591 (LN. 8-16-2019) Pushing this logic further down to account for the correct setting of MODIFY action codes.
    if(quoteType_quote == ADD_ON AND itemType == BASE_FEE AND currentAction <> NONE_ACTION) {
        put(PRODUCT_FAMILY_DICT, productFamily + DELIMITER + currentAction + DELIMITER + pi, productFamily);
    }
}

//CSYS-88632 Part 3 of 3 START (LN. 2/19/2018)
tierInc = FALSE_STR;
tierDec = FALSE_STR;

//Evaluate the tierIncrease/DecreaseArrays, if there are values evaluate accordingly and write to the quote level attribute
if(sizeofarray(tierIncreaseArray) > 0){
    tierInc = TRUE_STR;
}
if(sizeofarray(tierDecreaseArray) > 0){
    tierDec = TRUE_STR;
}

utilResultString = util.formAttrValueStr( attributesDict, "tierIncrease_quote", QUOTE_DOC_NUM, tierInc);
utilResultString = util.formAttrValueStr( attributesDict, "tierDecrease_quote", QUOTE_DOC_NUM, tierDec);
//CSYS-88632 Part 3 of 3 END



//Update: commenting out until further notice due to biz requirement change.
/*TandM_BillingExceptionNotes = substring(TandM_BillingExceptionNotes, 0, -2); //trim the last comma and space
utilResultString = util.formAttrValueStr(attributesDict, "TandM_BillingExceptionNotes_quote", QUOTE_DOC_NUM, TandM_BillingExceptionNotes);*/

//CSYS-44734 and CSYS-47536 (part 2)
if(NOT ignoreSetupCheck AND addonHasSetup){
    utilResultString = util.formAttrValueStr(attributesDict, "setupOnlyFlag_quote", QUOTE_DOC_NUM, TRUE_STR);
    //CSYS-92409
    utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, "setupOnlyFlag_quote", TRUE_STR);
}
else{utilResultString = util.formAttrValueStr(attributesDict, "setupOnlyFlag_quote", QUOTE_DOC_NUM, FALSE_STR);
    utilResultString = util.formAttrValueStr(attributesDict, "pONumException_quote", QUOTE_DOC_NUM, "");} //blank out po exception field
//CSYS-95378
if(NOT ignoreExtServCheck AND (addonHasExtServ OR addonHasSetup)){
    utilResultString = util.formAttrValueStr(attributesDict, "extServOnlyFlag_quote", QUOTE_DOC_NUM, TRUE_STR);
    utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, "extServOnlyFlag_quote", TRUE_STR);
}
else{utilResultString = util.formAttrValueStr(attributesDict, "extServOnlyFlag_quote", QUOTE_DOC_NUM, FALSE_STR);
}
//CSYS-99043
billCycleChangeOnly = "false";
if(containskey(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly")){
    billCycleChangeOnly = get(stringsDict, QUOTE_DOC_NUM + DELIMITER + "billingCycleChangeOnly");
}
if(addonHasSetup AND NOT ignoreNonModifySetupCheck AND billCycleChangeOnly == TRUE_STR){
    utilResultString = util.formAttrValueStr(attributesDict, "profServOnlyFlag_quote", QUOTE_DOC_NUM, TRUE_STR);
}
else{
    utilResultString = util.formAttrValueStr(attributesDict, "profServOnlyFlag_quote", QUOTE_DOC_NUM, FALSE_STR);
}
//CSYS-44734 ARR check part 2
utilResultString = util.formAttrValueStr(attributesDict, "aRRInvolvedFlag_quote", QUOTE_DOC_NUM, string(arrInvolved));

for docNum in docNumList {//CSYS-95500
    pi = get(piDict, docNum);
    poID = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_ID );
    parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM);
    isUnitBased = util.getStringAttribute(stringsDict, docNum, DELIMITER, IS_UNITBASED);
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    isGrouped = util.getStringAttribute( stringsDict, docNum, DELIMITER, IS_GROUPED );
    rampPriceOverride = util.getStringAttribute(stringsDict, docNum, DELIMITER, "overrideRampPrice");
    overrideDefaultRampPlan = util.getStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_OVERRIDE);
    itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
    unitBasedProductCanBeRamped = util.getStringAttribute(stringsDict, docNum, DELIMITER, "unitBasedProductCanBeRamped_line");
    unitBasedProductCanUseOverridePrice = util.getStringAttribute(stringsDict, docNum, DELIMITER, "unitBasedProductCanUseOverridePrice_line");
    numOfTransactions = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
    productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106; CSYS-95591
    lineItemComment = util.getStringAttribute(stringsDict, docNum, DELIMITER, LINE_COMMENT_ASSET_STRING);//CSYS-95591

    if (pi <> "") {

        //CSYS-95591 - Expansion of CSYS-87106 (LN. 1/23/2018) - Track Transaction Count within Product Families
        if( itemType == BASE_FEE AND containskey(PRODUCT_FAMILY_DICT, productFamily + DELIMITER + currentAction + DELIMITER + pi) ){

            //Store the CREATE's number of transacions, to be used later for comparison
            //CSYS-97291 (P.S. 1-8-2020) Updated all Product Family Tier Count Dictionary KEY references to add in scope of the ParentDocNum
            if( currentAction == CREATE_ACTION ){
                put(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, numOfTransactions);
            }
            //Store the TERMINATE's & MODIFY's original number of transactions (# of trans on the asset) to be used for comparison later on
            else {
                 comment = split(lineItemComment,ASSET_DELIMITER);

                if(sizeofarray(comment)>1){

                    assetString = comment[2];

                    if(assetString <> ""){
                        currentAssetString = split(assetString,INTERNAL_DELIMITER);
                        originalTrxns = integer(atof(currentAssetString[ASSET_COMMITED_TRNS]));

                        if(currentAction == TERMINATE_ACTION){
                            put(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, originalTrxns);
                        }
                        else {

                            put(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum, originalTrxns);

                            if(originalTrxns > numOfTransactions){//Tier Decrease has occurred:
                                put(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER + parentDocNum, numOfTransactions);
                            }
                        }
                    }
                }
            }
        }

        //CSYS-95500 (LN. 4-12-2019)
        //CSYS-98018 (P.S. 1-10-2020) Allowing MODIFY Unit Based Products to leverage Override/Override Price
        if( isUnitBased == TRUE_STR AND (currentAction == CREATE_ACTION OR currentAction == MODIFY_ACTION) AND itemType == BASE_FEE){

            toNodeArr = split(util.getStringAttribute(stringsDict, docNum, DELIMITER, TO), "*.*");
            unitBasedCanHaveIndependentRampPlan = false;
            unitBasedCanUseOverridePrice = false;

            //If the Unit Based Product has more than one ramp, allow availibility to use the Override Price (leveraged in hiding rules)
            if(toNodeArr[0] <> "and beyond"){
                unitBasedCanUseOverridePrice = true;
            }
            else {
                if(rampPriceOverride == TRUE_STR){
                    utilResultString = util.formAttrValueStr(attributesDict, "overrideRampPrice_line", docNum, "");
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "overrideRampPrice", "");
                }
            }

            //If the Core Service does NOT have ramps
            if(NOT(containskey(stringsDict, parentDocNum + DELIMITER + "coreServiceHasRampsApplied")) ){
                //If the Unit Based is NOT Bundled, allow the ability to Override the Ramp (this attribute is leveraged in hiding rules)
                if(isGrouped <> TRUE_STR){
                    unitBasedCanHaveIndependentRampPlan = true;
                }
            }
            else {

                unitBasedCanUseOverridePrice = true;
                /*
                This scenario is when the Core does JUST GOT ramps applied.
                The Unit Based Create DOES have > 1 Ramp AND is using Override Price prior to the Core having a ramp.
                */
                if(rampPriceOverride == TRUE_STR AND unitBasedProductCanBeRamped == TRUE_STR AND unitBasedProductCanUseOverridePrice == TRUE_STR){

                    //In that scenario, set the Override Price to FALSE - this is not working
                    utilResultString = util.formAttrValueStr(attributesDict, "overrideRampPrice_line", docNum, "");
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "overrideRampPrice", "");

                    //If a GLOBAL ramp is applied, set the Override Ramp to FALSE
                    // Otherwise leave it set to TRUE when the Core is leveraging the Override
                    if( NOT(containskey(stringsDict, parentDocNum + DELIMITER + "coreServiceOverrideRampPlan")) ){//this is working
                        utilResultFlag = util.putStringAttribute( stringsDict, parentDocNum + RAMP_DELIMITER + poID, DELIMITER, PO_RAMP_OVERRIDE, "" );
                    }
                }
            }

            if(isGrouped == TRUE_STR){//If the Unit Based CREATE is bundled,

                if(rampPriceOverride == TRUE_STR){//If Ramp Price Override was TRUE, set to FALSE when bundled
                    utilResultString = util.formAttrValueStr(attributesDict, "overrideRampPrice_line", docNum, "");
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, "overrideRampPrice_line", "");
                }

                //If Override Default Ramp Plan was TRUE and the Core is NOT utilizing Override Default Ramp, set Override Ramp to FALSE
                if(overrideDefaultRampPlan == TRUE_STR AND NOT(containskey(stringsDict, parentDocNum + DELIMITER + "coreServiceOverrideRampPlan")) ){
                    utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, RAMP_PLAN_OVERRIDE, "");
                }
            }

            //Writing to attributes
            utilResultString = util.formAttrValueStr(attributesDict, "unitBasedProductCanBeRamped_line", docNum, string(unitBasedCanHaveIndependentRampPlan));
            utilResultString = util.formAttrValueStr(attributesDict, "unitBasedProductCanUseOverridePrice_line", docNum, string(unitBasedCanUseOverridePrice));
            //Priming StringsDict
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, UNIT_BASED_CAN_HAVE_INDEPENDENT_RAMP_PLAN, string(unitBasedCanHaveIndependentRampPlan));
        }
    }
}

//CSYS-96801 (LN. 7-3-2018) Setting up constants for CIP Setup Fee Rework
piArray = string[];
cipPiDict = dict("string");

/* CSYS-95591 (LN. 8-16-2019)
    Moving this logic further down to account for the correct setting of MODIFY actions.  Expanding the original logic of CSYS-87106 to account for
    MODIFY's within the same Product Family to offset the ARR at a reduced Tier Count (effectively reducing the ARR).
*/
for docNum in docNumList {
    pi = get(piDict, docNum);
    productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106; CSYS-95591
    parentDocNum = util.getStringAttribute(stringsDict, docNum, DELIMITER, PARENT_DOC_NUM);//CSYS-97291 (P.S. 1-8-2020)
    itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    numOfTransactions = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
    tierDecrease = false;

    if( itemType == BASE_FEE AND containskey(PRODUCT_FAMILY_DICT, productFamily + DELIMITER + currentAction + DELIMITER + pi) ){

        // 1. This accounts for Tier Decrease Scenarios..
        if( containskey(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum) ){

            createTierCnt = get(PRODUCT_FAMILY_CREATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER + parentDocNum);

            if( currentAction == TERMINATE_ACTION AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER) ){

                terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER);

                //If the original Termiante Trxn number is > than the Create, a tier decrease has occured,
                if(terminateTierCnt > createTierCnt  AND createTierCnt <> 0){
                    //CSYS-95591
                    //Store the decreased number of transactions from the create at the terminate line level
                    utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, createTierCnt);
                    //Update the Ramp transaction string with the updated TRXN count:
                    utilResultFlag = util.putStringAttribute( stringsDict, docNum, DELIMITER, TRANS_STRING, string(createTierCnt));

                    tierDecrease = true;
                }
            }

            if( currentAction == MODIFY_ACTION AND containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER) ){

                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER);

                if(modifyOriginalTierCnt > numOfTransactions){
                    tierDecrease = true;
                }

            }
        }
        // 2. This accounts for the Tier Increase Scenario.
        else {
            if( containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER) AND containskey(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER) ){

                modifyOriginalTierCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER);

                if(containskey(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER)){
                    terminateTierCnt = get(PRODUCT_FAMILY_TERMINATE_TIER_COUNT_DICT, productFamily + DELIMITER + PRODUCT_FAMILY_ARR_OFFSET + DELIMITER);
                    modifyTierDecreaseTrxnCnt = get(PRODUCT_FAMILY_MODIFY_TIER_COUNT_DICT, productFamily + DELIMITER + "MODIFY_TIER_DECREASE_TRANSACTION_COUNT" + DELIMITER);

                    if(terminateTierCnt > modifyTierDecreaseTrxnCnt){
                        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS, modifyTierDecreaseTrxnCnt);
                        tierDecrease = true;
                    }
                }
            }
            //CSYS-98152 SN. 01/2020
            if (ownerBU_quote == SMB_BU AND currentAction == TERMINATE_ACTION){
                put(triggerDict, docNum + "~" + "terminateOutsideProductFamily", docNum + "~" + "terminateOutsideProductFamily" + TRIG_KEY_VALUE_DELIM + TRUE_STR);
            }
        }
    }

    //CSYS-96801 (LN. 7-3-2018) If this is a CIP quote, store a list of all product numbers for use later
    if(pi <> "" AND implementationPartner_quote <> ""){
        append(piArray, pi);
    }

    //CSYS-95591
    put(PROD_FAM_TIER_DECREASE_OCCURRED_DICT, currentAction + DELIMITER + pi, string(tierDecrease));
}

/* Run all Line Items.  For any line item with a rollup Flag of no, set its ramp plan to the line item that has a rollup of yes*/
// This util library will set many variables in the dictionaries.  docNumList is not the only var affected.
//CSYS-95701 SN. 09-2019 Add travelAndExpenseWithTriplinkProductArr to argument list
docNumList = util.setRampPlanData(stringsDict, integersDict, floatsDict, docNumList, overWriteTransactionArr, piDict, modelToLineDocNumsDict, modelToLinePartNumsDict, implementationMethodArr, travelAndExpenseWithTriplinkProductArr );

/* ======================================================================== */
/*                          Get all Part fields info                        */
/* ======================================================================== */
/*
    This util function call populates the stringsDict.

    KEY: <pi><DELIMITER><customFieldName>
    VALUE: <customFieldValue>

    where...
        customFieldName is the name of a Part Custom Field
        customFieldValue is the corresponding value of that Part Custom Field
        DELIMITER is the constant defined at the top of this script
        pi is the PI (a.k.a. _part_number) of the line item/product
*/
/*
if (debug) {
    printTempVal = util.printDebugHeader("Get all custom part fields info");
}
*/
//utilResultDict = util.getPartFields(piList, CUSTOM_FIELD_DICT, stringsDict, DELIMITER);
/*
if (debug) {
    printTempVal = util.printError(utilResultDict, 0);
    printTempVal = util.printDebug("Called with piList", "", 0);
    print(piList);
    printTempVal = util.printDebugSubsection("stringsDict after obtaining custom field info: ", 0);
    print(stringsDict);
}
*/

/* ======================================================================== */
/*                   Promotions                             */
/* ======================================================================== */
// Put all the data for querying promo information in this dictionary
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, REGION, ownerRegion_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, BUSINESS_UNIT, ownerBU_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, SEGMENT, segment_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, THEATER, ownerTheater_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, OWNER_TEAM, ownerTeam_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, MARKET, ownerMarket_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, REVENUE_GROUP, ownerRevenueGroup_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, ACCOUNT_VERTICAL, accountVertical_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, CUSTOMER_TYPE, customerType_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, QUOTE_TYPE, quoteType_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, PROMOTION_CODE, promotionCode_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, EXTERNAL_PROMOTION, externalPromotion_quote);
utilResultFlag = util.putStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, SYSTEM_DATE, datetostr(getdate()));
//CSYS-99074
if (quoteType_quote == ADD_ON){
    renewalDateText = "";
    timezone = util.getUserTimeZone();  
    if(contractRenewalDateText_quote <> "" AND NOT(isnull(contractRenewalDateText_quote))) {
        renewalDateText = contractRenewalDateText_quote;
    }
    else{   
        if (NOT(isnull(contractRenewalDateAcc_quote))){
            renewalDateText = contractRenewalDateAcc_quote; //use contract renewal date from account
        }
    }
    renewalDate = getdate();
    if (renewalDateText <> ""){
        if(find(renewalDateText , "/") <> -1) {
            renewalDate = strtojavadate(renewalDateText , DATE_FORMAT_PREFERENCE_SLASH);
        } 
        else{
            renewalDate = strtojavadate(renewalDateText , DATE_FORMAT_PREFERENCE_HYPHEN); 
        }
    }
    currentDateText = substring(datetostr(getdate()), 0, 10);
    currentDate = getdate();
    if(find(currentDateText, "/") <> -1) {
        currentDate = strtojavadate(currentDateText, DATE_FORMAT_PREFERENCE_SLASH);
    } 
    else{
        currentDate = strtojavadate(currentDateText, DATE_FORMAT_PREFERENCE_HYPHEN);
    }
    //CSYS-99262, Phil S, 04/27/2020
    dateIn = contractRenewalDateAcc_quote;
    dateOut = getdate();
    if(NOT(isnull(dateIn)) AND dateIn <> "") {
        if(find(dateIn, "/") <> -1) {
            dateOut = strtojavadate(dateIn, DATE_FORMAT_PREFERENCE_SLASH);
        } 
        else{
            dateOut = strtojavadate(dateIn, DATE_FORMAT_PREFERENCE_HYPHEN);
        }
    } 
    
    renewalDate = dateOut;
    if (comparedates(renewalDate, currentDate) <> 1){ //
        put(stringsDict, "renewalPromoValidation", TRUE_STR);
    }
}

// partNumArr is constructed (normally) with CREATE Part Numbers...
// We want to conditionally add Part Numbers for NONE/MODIFY when...renewalPromoValidation = TRUE....
//      In this scenario leverage a Dictionary to store part numbers with thier action code...  be able to track pi's and the action code..
//      For those pi's that are NONE/MODIFY we only want to return the RENEWALOFFER90DAYS promo...
//      Return applicable promos for those CREATE lines...
utilResultFlag = util.putPromotionsInfo(stringsDict, promoResultsDict, promotionsDataDict, promoCodeDescAndDetailsDict, internalPromoDescDict, externalPromoDescDict, customerFriendlyPromoDescDict, legalPromoDescDict, docNumList, implementationMethodArr, partNumArr);

if(containskey(promoResultsDict, "promoCodeApplied")) {
    promoCodeApplied = get(promoResultsDict, "promoCodeApplied");
}

if(containskey(promoResultsDict, "applicablePromotions")) {
    applicablePromotions = get(promoResultsDict, "applicablePromotions");
}
if(containskey(promoResultsDict, "invalidPromoMessage")) {
    invalidPromoMessage = get(promoResultsDict, "invalidPromoMessage");
}
if(containskey(promoResultsDict, "autoAppliedPromotions")) {
    autoAppliedPromotions = get(promoResultsDict, "autoAppliedPromotions");
}
if(containskey(promoCodeDescAndDetailsDict, "promoCodeDetails")) {
    promoCodeDetails = get(promoCodeDescAndDetailsDict, "promoCodeDetails");
}

//if(containskey(stringsDict, "renewalPromoValidation")){
    //print "we are past the CRN date";
//}
//print "applicablePromotions here in pricing";
//print applicablePromotions;

tempPromoCodeAppliedArr = split(promoCodeApplied, "#^#");

/* ======================================================================== */
/*                          Calculate Standard Tier Prices                  */
/* ======================================================================== */
/*
if (debug) {
    printTempVal = util.printDebugHeader("Calculate Standard Tier Prices");
    printTempVal = util.printDebugSubsection("Determine the UOM Type of each line item", 0);
}
*/
/* ------------------------------------------------------------------------ */
/*  Determine the UOM Type of each line item
    Populate the pricing key for standard tier pricing
*/
/* ------------------------------------------------------------------------ */


for docNum in docNumList {
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    pi = get(piDict, docNum);

    if (pi <> "") {
        /*if (debug) {
            printTempVal = util.printDebugSubsection("docNum: " + docNum + "; PI: " + pi, 1);
        }*/
        //Initialize local variables
        quantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, QTY);
        trxns = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
        //Determine the UOM Type of this product
        uomType = util.getStringAttribute(stringsDict, pi, DELIMITER, UOM_TYPE);
        //Determine the implementionMethod of this line item
        implementationMethod = util.getStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD);
        //Determine the core Offering of this line item
        coreOffering = util.getStringAttribute( stringsDict, docNum, DELIMITER, CORE_OFFERING );
        // Determine the term of commitment of this line item
        termOfCommitment = util.getStringAttribute(stringsDict, docNum, DELIMITER, TERM_OF_COMMITMENT);
        //Determine the pricingKey for this line item.
        pricingKey = pi + DELIMITER;
        poCategory = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_CATEGORY);

        if (uomType == UOM_QTY) {
            pricingKey = pricingKey + string(quantity);
        } else {
            pricingKey = pricingKey + string(trxns);
        }

        /* CSYS-95225 (LN. 3-28-2019)
            In the event that there is a CREATE/TERMINATE on an Core Edition Change with a Tier DECREASE,
            We need to retain the original Core's Edition to pass into stdTierPricing, otherwise the pricing retrieved
            is incorrect since the pi on the new Edition doesn't exist.

            CSYS-95591 (LN. 8-16-2019)
            Putting the Implementation Method into the StringsDict to be consumed by calculateTierPricing to set the Edition correctly.
        */
        if(containskey(coreTerminateEditionDict, pi + DELIMITER + TERMINATED_CORE_ASSET_EDITION)){
            implementationMethod = get(coreTerminateEditionDict, pi + DELIMITER + TERMINATED_CORE_ASSET_EDITION);
            utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD, implementationMethod);
        }

        pricingKey = pricingKey + DELIMITER + implementationMethod + DELIMITER + coreOffering;

        /* RAMP PLAN INCREMENTAL PRICE
            If this is a ramp line item, we are also going to get an associated tier price for the incremental fee line item */
        incFeePricingKey = "";
        incMult = "1";

        if ( find( docNum, RAMP_DELIMITER ) <> -1 ){
            if ( uomType == UOM_QTY ){
                incMult = string(quantity);
            }
            else{
                incMult = string(trxns);
            }

            incPi = util.getStringAttribute( stringsDict, docNum, DELIMITER, INCREMENTAL_PI );
            incFeePricingKey = incPi + DELIMITER + incMult + DELIMITER + implementationMethod + DELIMITER + coreOffering;
            append( piQtyAndImplementationMethodList, incFeePricingKey );
            put( piQtyAndImplementationMethodToPriceDict, incFeePricingKey, 0.0 );
        }

        //Populate pricingKey dictionaries
        put(piQtyAndImplementationMethodDict, docNum, pricingKey);
        append(piQtyAndImplementationMethodList, pricingKey);

        //Populate pricing dictionaries with pricingKeys
        put(piQtyAndImplementationMethodToPriceDict, pricingKey, 0.0);
        /*
        if (debug) {
            printTempVal = util.printInternalSection("uomType: " + uomType, 1);
            printTempVal = util.printDebug("pricingKey", pricingKey, 1);
        }
        */
    }
}

/*
CSYS-80927 (KA.):
Query the cipSetupFees table to extract any CIP Pi's that reside on the grid:
CSYS-92389 (LN. 7-3-2018):
Moving the dictionary build after getStandardTierPricing is called, need to retrieve the Setup Fee's
*/
if(implementationPartner_quote <> ""){//Only query when 'Implementation Partner' field is populated
    //CSYS-96006
    cipRez = BMQL("SELECT partNumber, coreService, ServPartnerSpecialty, ServPartnerAuthrzns FROM cipSetupFees WHERE partNumber IN $piArray");

    for entry in cipRez {
        cipPi = get(entry, "partNumber");
        cipCore = get(entry, "coreService");
        servicePartnerSpecialty = get(entry, "ServPartnerSpecialty");
        servPartnerAuthrzns = get(entry, "ServPartnerAuthrzns");

        if (servicePartnerSpecialty == "" AND servPartnerAuthrzns == ""){
            put(cipPiDict, cipPi, "true");
            put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
        }
        else{
            //CSYS-96006
            if ( find(accountServicePartnerSpecialty_quote, servicePartnerSpecialty) <> -1 OR
                 find(accountServicePartnerAuthorizations_quote, servPartnerAuthrzns) <> -1 ){

                //CSYS-96739 If there dictionary key is not yet populated, continue
                if(NOT(containskey(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore"))){
                    put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", cipCore);
                }
                //CSYS-96739 If there is already a key in the dictionary, update the key to include Invoice
                else {

                    invoiceCore = split(cipCore, TILDE_DELIMITER);
                    firstCipCore = get(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore");
                    firstCipCore = firstCipCore + invoiceCore[1];

                    put(cipPiDict, cipPi + TILDE_DELIMITER + "cipCore", firstCipCore + TILDE_DELIMITER);
                }

                put(cipPiDict, cipPi, "true");
            }
        }
    }
}


//CSYS-85811 (LN. 9/27/2017) Added actionName as a parameter to the util.getStandTierPricing, allows access to this parameter in the util
//CSYS-87125 (KA. 11-29-2017) Added stringsDict as a parameter to the util.getStandTierPricing, allows zeroing of Incremental list prices belonging to State and Local Government package

//CSYS-97295 (OC. 9.30.2019) Removing quoteVertical and remove getStandardTierPricing from Library Functions.  Then remove quoteVertical from getStandardTierPricing paramaters
utilResultDict = util.getStandTierPricing(PRICELIST, currencyCode, piQtyAndImplementationMethodToPriceDict, piQtyAndImplementationMethodList, DELIMITER, quoteTheater, quoteMarket, quoteType, actionName, stringsDict);//CSYS-88979

//print floatsDict;
/*if (debug) {

    printTempVal = util.printDebugSubsection("Obtain Standard Tier Price of each PI + Qty/Trxn combination", 0);
    printTempVal = util.printError(utilResultDict, 0);
    printTempVal = util.printDebug("piQtyAndImplementationMethodToPriceDict", "", 0);
    print(piQtyAndImplementationMethodToPriceDict);
    printTempVal = util.printDebug("utilResultDict", "", 0);
    print(utilResultDict);

}*/

/* ---------- Calculate the Tier Price and Extended Tier Price of each line item --------- */
//print "stringsDict";
//print stringsDict;
//print "integersDict";
//print integersDict;

//print "calculating pitierprices";
//print piQtyAndImplementationMethodToPriceDict;

for docNum in docNumList {
    //currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    pi = util.getStringAttribute(stringsDict, docNum, DELIMITER, PART_NUM);
    //CSYS-96801
    uomType = util.getStringAttribute(stringsDict, pi, DELIMITER, UOM_TYPE);
    quantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, QTY);
    trxns = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);
    implementationMethod = util.getStringAttribute(stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD);
    coreOffering = util.getStringAttribute( stringsDict, docNum, DELIMITER, CORE_OFFERING );
    cipProductLine = FALSE_STR;

    if (pi <> "") {

        qtyTrans = "";

        if (uomType == UOM_QTY) {
            qtyTrans = string(quantity);
        } else {
            qtyTrans = string(trxns);
        }

        //CSYS-96801 (LN. 8-23-2019)
        if(implementationPartner_quote <> ""){
            if( containskey(cipPiDict, pi) AND containskey(piQtyAndImplementationMethodToPriceDict, pi + DELIMITER + qtyTrans + DELIMITER + implementationMethod + DELIMITER + coreOffering)){

                cipCore = "";
                cIPSetupTierPrice = 0.0;
                stdTierPrice = get(piQtyAndImplementationMethodToPriceDict, pi + DELIMITER + qtyTrans + DELIMITER + implementationMethod + DELIMITER + coreOffering);

                if(containskey(cipPiDict, pi + TILDE_DELIMITER + "cipCore")){
                    cipCore = get(cipPiDict, pi + TILDE_DELIMITER + "cipCore");
                }

                // If the current part number is core specific in order to have a $0 setup fee, continue;
                if(cipCore <> "" AND NOT isnull(cipCore)){
                    // If core offering is available at the line level, continue;
                    if(coreOffering <> ""){
                        // If the current core service is an acceptable option for the $0 setup fee,
                        // store the original setup fee before setting to $0
                        if(find(cipCore, TILDE_DELIMITER + coreOffering + TILDE_DELIMITER) <> -1){

                            cIPSetupTierPrice = stdTierPrice;
                            cipProductLine = TRUE_STR;//CSYS-96326
                            stdTierPrice = 0.0;
                        }
                    }
                }
                else {
                    cIPSetupTierPrice = stdTierPrice;
                    cipProductLine = TRUE_STR;//CSYS-96326
                    stdTierPrice = 0.0;
                }

                if(currencyCode <> "USD"){
                    utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, CIP_SETUP_FEE, cIPSetupTierPrice );
                        conversionResult = util.convertDictCurrency( floatsDict, docNum, DELIMITER, CIP_SETUP_FEE, conversionRate, numDecimals );
                    cIPSetupTierPrice = util.getFloatAttribute( floatsDict, docNum, DELIMITER, CIP_SETUP_FEE );
                }

                totalCIPSetupFee = totalCIPSetupFee +  cIPSetupTierPrice;

                utilResultFlag = util.putFloatAttribute( floatsDict, docNum, DELIMITER, CIP_SETUP_FEE, cIPSetupTierPrice );
                put(piQtyAndImplementationMethodToPriceDict, pi + DELIMITER + qtyTrans + DELIMITER + implementationMethod + DELIMITER + coreOffering, stdTierPrice);
            }
        }

        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, CIP_PRODUCT, cipProductLine);

        utilResultDict = util.calculateTierPricing(piQtyAndImplementationMethodToPriceDict, DELIMITER, docNum, stringsDict, integersDict, floatsDict);
        /*
        if (debug) {
            printTempVal = util.printDebugSubsection("Calculate Tier Price and Extended Tier Price of each line item", 1);
            printTempVal = util.printError(utilResultDict, 1);
            printTempVal = util.printDebug("docNum", docNum, 1);
            printTempVal = util.printDebug("tierPrice", string(util.getFloatAttribute(floatsDict, docNum, DELIMITER, TIER_PRICE)), 1);
            printTempVal = util.printDebug("extTierPrice", string(util.getFloatAttribute(floatsDict, docNum, DELIMITER, EXT_TIER_PRICE)), 1);
            printTempVal = util.printDebug("floatsDict", "", 1);
            print(floatsDict);
        }
        */
    }
}


//CSYS-96801 (LN. 7-3-2018) Capture the Total CIP Setup Fee amount and write to the Quote level attribute
utilResultString = util.formAttrValueStr(attributesDict, TOTAL_CIP_SETUP_FEE, QUOTE_DOC_NUM, string(totalCIPSetupFee));

//print "after tier pricing";
//print floatsDict;

/* ======================================================================== */
/*                          Find Term Based Discount                        */
/* ======================================================================== */
defaultVal = 0.0;
termDisc = util.getTermBasedDisc(contractLength_quote, defaultVal);

//print "before prod based pricing";
//print floatsDict;

/* ======================================================================== */
/*      Calculate Product-Based Pricing and Tier based Discounting          */
/* ======================================================================== */

//Obtain the relevant Product Based Pricing data
piBasedProductPricingDict = dict("string[]");
qtyBasedProductPricingDict = dict("string[]");
utilResultDict = util.getPIBasedProductPricingData(piList, piBasedProductPricingDict);
piBasedRowCount = integer(atof(get(utilResultDict, "rowCount")));
utilResultDict = util.getQtyBasedProductPricingConditions(piList, qtyBasedProductPricingDict);
//qtyBasedRowCount = integer(atof(get(utilResultDict, "rowCount")));
/*
if (debug) {
    printTempVal = util.printDebugHeader("Calculate Product-Based Pricing");
    printTempVal = util.printDebug("piBasedProductPricingDict", "", 0);
    print(piBasedProductPricingDict);
    printTempVal = util.printDebug("qtyBasedProductPricingDict", "", 0);
    print(qtyBasedProductPricingDict);
}
*/

//CSYS-93420 (MJ 2-27-20)
customApprovalHistory = approvalHistoryCustom_quote;
customPricingArray = String[];

modelDocNumList = string[];

for docNum in docNumList {
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    pi = util.getStringAttribute(stringsDict, docNum, DELIMITER, PART_NUM);

    if (pi == "") { //If this IS a Model
        append(modelDocNumList, docNum);

        //Obtain the docNums and partNums that belong to this Model
        lineItemDocNums = string[];
        lineItemDocNums = util.getStrListDict(modelToLineDocNumsDict, docNum, lineItemDocNums);
        lineItemPartNums = get(modelToLinePartNumsDict, docNum);
        /*
        if (debug) {
            printTempVal = util.printDebugSubsection("Model docNum:" + docNum, 1);
            printTempVal = util.printDebug("lineItemDocNums", "", 1);
            print(lineItemDocNums);
        }
        */
        for lineDocNum in lineItemDocNums {
            /*
            if (debug) {
                printTempVal = util.printDebug("lineDocNum", lineDocNum, 2);
            }*/
            lineItemPI = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, PART_NUM);
            //Adding the below line on Nov 15, 2012 as part of pricing refactor.
            //Updating triggerDict with specialWorkFlowFlag will ensure that all approval related data is in triggerDict
            if(containskey(stringsDict, lineItemPI + DELIMITER + SPECIAL_WORKFLOW_FLAG)){
                specialWorkflowFlag = util.getStringAttribute(stringsDict, lineItemPI, DELIMITER, SPECIAL_WORKFLOW_FLAG);
                put(triggerDict, lineItemPI + DELIMITER + SPECIAL_WORKFLOW_FLAG, specialWorkflowFlag);
            }
            rollup = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, ROLL_UP );
            // Approval
            // Advantage/Learning Services
            piItemType = util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, PI_ITEM_TYPE );
            tierPrice = util.getFloatAttribute( floatsDict, lineDocNum, DELIMITER, TIER_PRICE );
            extTierPrice = util.getFloatAttribute( floatsDict, lineDocNum, DELIMITER, EXT_TIER_PRICE );
            implementationMethod = util.getStringAttribute( stringsDict, docNum, DELIMITER, IMPLEMENTATION_METHOD );
            utilResultFlag = util.putStringAttribute( stringsDict, lineDocNum, DELIMITER, IMPLEMENTATION_METHOD, implementationMethod );
            coreOffering = util.getStringAttribute( stringsDict, docNum, DELIMITER, CORE_OFFERING );
            utilResultFlag = util.putStringAttribute( stringsDict, lineDocNum, DELIMITER, CORE_OFFERING, coreOffering );
            /* ***** FOR INCREMENTAL FEE, SET EXT TIER PRICE = TIER PRICE, SET TRANSACTIONS BACK TO 1 ***** */

            if ( piItemType == INCREMENTAL_FEE ){
                utilResultFlag = util.putFloatAttribute( floatsDict, lineDocNum, DELIMITER, EXT_TIER_PRICE, tierPrice );
                extTierPrice = tierPrice;
                utilResultFlag = util.putIntegerAttribute( integersDict, lineDocNum, DELIMITER, TRANSACTIONS, INCREMENTAL_TRANSACTION_DEFAULT );
            }

            bundleFlag = util.getStringAttribute(stringsDict, lineItemPi, DELIMITER, BUNDLE_FLAG );
            poID = util.getStringAttribute( stringsDict, lineItemPi, DELIMITER, PO_ID );
            dynamicGroupingPoGroup = util.getStringAttribute( stringsDict, docNum, DELIMITER, PO_GROUPS_DYNAMIC_GROUPING );
            dynamicGroupPoArr = split( dynamicGroupingPoGroup, PO_DELIMITER );
            isGrouped = util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, IS_GROUPED );

            //CSYS-97908
            poCategory = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, PO_CATEGORY);
            currentAction = util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, ASSET_ACTION);
            if ( poCategory == CORE_SERVICE AND NOT(containskey(stringsDict, "modelDocNumPO" + docNum)) AND currentAction <> TERMINATE_ACTION AND currentAction <> ""){
                put( stringsDict, "modelDocNumPO" + docNum, poID );
                print "Sunday1, modelDocNumPO key value are :" + docNum + ":" + poID;
            }
            // If the model has any grouped line items, all in the same PO must be grouped, unless bundleflag = false
            if ( util.getStringAttribute( stringsDict, docNum, DELIMITER, MODEL_FORCE_GROUPING ) == TRUE_STR AND bundleFlag == "Y"
                AND findinarray( dynamicGroupPoArr, poID ) <> -1){
                isGrouped = TRUE_STR;
                utilResultFlag = util.putStringAttribute( stringsDict, lineDocNum, DELIMITER, IS_GROUPED, TRUE_STR );
            }
            /* If we are a non rampable Base Fee, we still need the appropriate prices to add to the ramps for the incremental Fee */
            if ( util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, IS_RAMPABLE ) <> TRUE_STR AND isGrouped == TRUE_STR
                AND piItemType == BASE_FEE ){
                // First, get the transaction string.  As a non rampable item, it should match the transaction string of the core base fee
                baseCoreDocNum = util.getStringAttribute( stringsDict, docNum, DELIMITER, PRIMARY_BASE_FEE );
                transString = util.getStringAttribute( stringsDict, baseCoreDocNum, DELIMITER, TRANS_STRING );
                transArr = split( transString, DELIMITER );
                baseNonRampableIncrementalString = util.getStringAttribute( stringsDict, baseCoreDocNum, DELIMITER, NON_RAMPABLE_BASE_INCREMENTAL_STRING );
                nonRampableArr = String[];

                if ( baseNonRampableIncrementalString <> "" ){
                    nonRampableArr = split( baseNonRampableIncrementalString, DELIMITER );
                }
                // For Every transaction in the trans arr, find the new price based on the number of transactions of the core ramp
                pbPriceArr = String[];
                transArrIndex = 0;

                for baseTransaction in transArr{
                    baseTransactionInt = util.customAtoi( baseTransaction, 0 );
                    baseTransactionVal = 0.0;

                    if ( baseTransactionInt <> 0 ){
                        baseTransactionVal =  extTierPrice / (baseTransactionInt * 1.0 );
                    }
                    if ( baseNonRampableIncrementalString <> "" ){
                        append(pbPriceArr, string(util.customAtof(nonRampableArr[transArrIndex], 0.0) + baseTransactionVal));
                    }
                    else{
                        append( pbPriceArr, string(baseTransactionVal ) );
                    }

                    transArrIndex = transArrIndex + 1;
                }
                nonRampableString = join( pbPriceArr, DELIMITER );

                utilResultFlag = util.putStringAttribute( stringsDict, baseCoreDocNum, DELIMITER, NON_RAMPABLE_BASE_INCREMENTAL_STRING, nonRampableString );
            }

            /* ======================================================================== */
            /*                      CALCULATE PROD BASED PRICING                        */
            /* ======================================================================== */
            utilResultDict = util.calculateProdBasedPricing(modelToLineDocNumsDict, lineDocNum, stringsDict, integersDict, floatsDict, DELIMITER);

            // Product based pricing for the incremental fee of ramps
            if ( find( lineDocNum, RAMP_DELIMITER ) <> -1 ){
                // Obtain incremental information
                //CSYS-95701 SN. Remove temp fix and check in new variable
                if(findinarray(travelAndExpenseWithTriplinkProductArr, lineItemPI) <> -1){
                    rollup = "No";
                }
                incKey = docNum + RAMP_DELIMITER + poID + RAMP_DELIMITER + rollup;
                incDocNum = util.getStringAttribute(stringsDict, incKey , DELIMITER, INCREMENTAL_FEE_FOR_PO );
                rampIndexArr = split( lineDocNum, RAMP_DELIMITER );
                incrementalRampDocNum = incDocNum + RAMP_DELIMITER + rampIndexArr[1];
                incPI = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, INCREMENTAL_PI );
                incTierPrice = util.getFloatAttribute( floatsDict, lineDocNum, DELIMITER, INCREMENTAL_FEE_LIST );

                // Put incremental information into a pseudoline
                // This will act like a ramp line item, but is not contained in the list of ramp doc nums
                utilResultFlag = util.putStringAttribute( stringsDict, incrementalRampDocNum, DELIMITER, PART_NUM, incPI );
                utilResultFlag = util.putStringAttribute( stringsDict, incrementalRampDocNum, DELIMITER, PARENT_DOC_NUM, docNum );
                utilResultFlag = util.putFloatAttribute( floatsDict, incrementalRampDocNum, DELIMITER, TIER_PRICE, incTierPrice );
                utilResultFlag = util.putStringAttribute( stringsDict, incrementalRampDocNum, DELIMITER, IS_GROUPED, TRUE_STR );
                /* ======================================================================== */
                /*                      Calculate Prod Base pricing                         */
                /* ======================================================================== */
                utilResultDict = util.calculateProdBasedPricing(modelToLineDocNumsDict, incrementalRampDocNum, stringsDict, integersDict, floatsDict, DELIMITER );
                incPBB = util.getFloatAttribute( floatsDict, incrementalRampDocNum, DELIMITER, PROD_BASED_PRICE );
                utilResultFlag = util.putFloatAttribute( floatsDict, lineDocNum, DELIMITER, INCREMENTAL_FEE_RATIO_VALUE, incPBB );
            }
            // Apply the tier based discounting
            termOfCommitment = util.getStringAttribute(stringsDict, lineItemPI, DELIMITER, TERM_OF_COMMITMENT);
            if(termOfCommitment == "Y") { // Apply the term discount only to the applicable line items
                utilResultFlag = util.putFloatAttribute(floatsDict, lineDocNum, DELIMITER, TERM_BASED_DISC, termDisc);
            } else {
                utilResultFlag = util.putFloatAttribute(floatsDict, lineDocNum, DELIMITER, TERM_BASED_DISC, 0.0);
            }
        }
    }
    if (pi <> "") {

        useCustomPrice = util.getStringAttribute( stringsDict, docNum, DELIMITER, USE_CUSTOM_PRICE );
        tierPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, TIER_PRICE);
        prodBasedPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, PROD_BASED_PRICE);
        specialWorkFlowFlag = util.getStringAttribute( stringsDict, pi, DELIMITER, SPECIAL_WORKFLOW_FLAG );
        customPricingHasOccured = util.getStringAttribute (stringsDict, docNum, DELIMITER, CUSTOM_PRICING_HAS_OCCURED);//CSYS-85811
        listPrice = prodBasedPrice;
        piItemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );//CSYS-87106
        productFamily = util.getStringAttribute(stringsDict, pi, DELIMITER, PRODUCT_FAMILY);//CSYS-87106
        trxns = util.getIntegerAttribute(integersDict, docNum, DELIMITER, TRANSACTIONS);//CSYS-89523
        assetTierPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_TIER_PRICE);//CSYS-95251 (LN. 4-30-2019)
        pricebookChangeDetected = util.getStringAttribute(stringsDict, docNum, DELIMITER, "pricebookChange_line");
        //CSYS-97422 SN. 01-2020
        poCategory = util.getStringAttribute(stringsDict, docNum, DELIMITER, PO_CATEGORY);
        if (editQuantity_quote == true){
            editQuantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, "editQuantity_line");
            if (editQuantity == 0 ){
                editQuantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, QTY);
            }
            if (poCategory <> "Professional Service"){
                editQuantity = 1;
            }
            utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, QTY, editQuantity); 
            utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, "editQuantity_line", editQuantity);//CSYS-97422 SN. 01-2020         
        }
        //end of CSYS-97422 SN. 01-2020

        //CSYS-85811 (LN. 9/27/2017)
        if(actionName <> "updateCustomPrice" AND customPricingHasOccured == FALSE_STR){
            //When in the context of "Submit for Custom Pricing", pull in the list price only on the first round
            customListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, PROD_BASED_PRICE);
            customQuantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, QTY);//CSYS-96366 SN. 07-2019
        }else{
            //When in the context of "Update Custom Price", use the custom price from the grid
            customListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, CUSTOM_LIST_PRICE);
            customQuantity = util.getIntegerAttribute(integersDict, docNum, DELIMITER, "customQuantity_line");//CSYS-96366 SN. 07-2019
        }
        
        //CSYS-93420 (MJ 2-27-20)
        if(specialWorkflowFlag <> "None" AND findinarray(customPricingArray, specialWorkflowFlag) == -1){
            //["Advantage Services", "Learning Services"];
            append(customPricingArray, specialWorkflowFlag);  
        }

        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, QTY, customQuantity);//CSYS-96366 SN. 07-2019
        multiplier = util.getMultiplier(docNum, DELIMITER, stringsDict, integersDict, floatsDict);


        if(_system_current_step_var == "pendingAdvantageServices_step") {
            //CSYS-85811 (LN. 9/27/2017) Removing criteria that Custom Price must be > 0 and that is cannot equal the list price
            if(specialWorkFlowFlag == "Advantage Services" OR specialWorkFlowFlag == "Learning Services" OR specialWorkFlowFlag == "Partner Services") { // On Update Custom Price action, user could have changed custom list price
                listPrice = customListPrice;
                tierPrice = listPrice;
                useCustomPrice = TRUE_STR;
            } else {
                customListPrice = listPrice;
            }
        }
        elif( useCustomPrice == TRUE_STR AND (specialWorkFlowFlag <> "Advantage Services" OR specialWorkFlowFlag <> "Learning Services" OR specialWorkFlowFlag <> "Partner Services")){
            listPrice = customListPrice;
            tierPrice = listPrice;
        }

        listPriceNonUnified = prodBasedPrice;
        promoPrice = prodBasedPrice;
        //add on related
        if(currentAction == TERMINATE_ACTION){
            //CSYS-97106 - 95591
            if( piItemType == BASE_FEE AND containskey(PROD_FAM_TIER_DECREASE_OCCURRED_DICT, currentAction + DELIMITER + pi) AND get(PROD_FAM_TIER_DECREASE_OCCURRED_DICT, currentAction + DELIMITER + pi) == TRUE_STR){

                terminatedTierDecreaseArrNet = (prodBasedPrice * multiplier) * RAMP_FLAG_MULTIPLIER;

                utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, EXISTING_ARR_CURRENCY_LINE, terminatedTierDecreaseArrNet);
                utilResultString = util.formAttrValueStr(attributesDict, EXISTING_ARR_CURRENCY_LINE, docNum, string(terminatedTierDecreaseArrNet));
            }

            listPrice = 0.0;

        }

        elif(currentAction == NONE_ACTION AND pricebookChangeDetected <> TRUE_STR){
            //CSYS-95251 (LN. 4-30-2019) CSYS-96748 (DC check)
            if(assetTierPrice <> listPrice AND NOT util.isDigitalCommerceTransaction(_system_user_login) ){// pricebook updates
                utilResultString = util.formAttrValueStr(attributesDict, "pricebookChange_line", docNum, string(true));
            }
            listPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_LIST_PRICE);
        }
        /*CSYS-89523 (LN. 2-20-2018) Analytics Reporting Services Product, need the line item grid to align with other products, take the List Price and divide by number of TRXNs
        (LN. 2-6-2019) Rolling back this functionality as ARS is no longer a fixed cost product, but a Unit based with updated pricing.

        if( pi == "3724957" AND trxns <> 0 AND currentAction <> NONE_ACTION){
            //Store the actual list price to get an accurate final Ext Net Price to calculate ARR accordingly
            analyticsReportingListPrice = listPrice;
            utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, "analyticsReportingListPrice", analyticsReportingListPrice);

            longListPrice = round(listPrice/trxns, 5);
            listPrice = round(longListPrice, 2);
        }*/


        //CSYS-70755/CSYS-CSYS-72450: Fix non-USD Extended list price consistency and related issues. KA. 10-27-2016.
        //extListPrice = listPrice * multiplier;
        if(currencyCode <> "USD"){
            if(currentAction == NONE_ACTION AND pricebookChangeDetected <> TRUE_STR){//CSYS-95956 (LN. 6-10-2019)
                //Grab the original Extended list price (assets string value):
                extListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_EXT_LIST_PRICE);
            }
            else{ //Business as usual:
                extListPrice = listPrice * multiplier;

                /*CSYS-89523 (LN. 2-20-2018)
                (LN. 2-6-2019) Rolling back this functionality as ARS is no longer a fixed cost product, but a Unit based with updated pricing.

                if(pi == "3724957"){//Non-USD Analytics Reporting Services Product (Not currently sold outside of USD, but could in the future)
                    analyticsReportingListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, "analyticsReportingListPrice");
                    extListPrice = analyticsReportingListPrice * multiplier;
                }*/
            }
        }
        else{ //Business as usual:
            extListPrice = listPrice * multiplier;

            /*CSYS-89523 (LN. 2-20-2018) Analyitics Reporting Service Product, the Ext List Price should be the actual list price from stdTierPricing (166.67)
            (LN. 2-6-2019) Rolling back this functionality as ARS is no longer a fixed cost product, but a Unit based with updated pricing.

            if(pi == "3724957"){
                if(currentAction <> NONE_ACTION){
                    analyticsReportingListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, "analyticsReportingListPrice");
                    extListPrice = analyticsReportingListPrice * multiplier;
                }
                else {
                    //Grab the original Extended list price (assets string value):
                    extListPrice = util.getFloatAttribute(floatsDict, docNum, DELIMITER, ASSETS_ORIGINAL_EXT_LIST_PRICE);
                }

            }*/

        }

        extListPriceNonUnified = extListPrice;
        isRampable = util.getStringAttribute( stringsDict, docNum, DELIMITER, IS_RAMPABLE );
        itemType = util.getStringAttribute( stringsDict, docNum, DELIMITER, PI_ITEM_TYPE );
        parentDocNum = util.getStringAttribute( stringsDict, docNum, DELIMITER, PARENT_DOC_NUM );
        isGrouped = util.getStringAttribute(stringsDict, docNum, DELIMITER, IS_GROUPED );

        if( isRampable <> TRUE_STR AND itemType == BASE_FEE AND isGrouped == TRUE_STR){
            currentTotalNonRampableBase = util.getFloatAttribute( floatsDict, docNum, DELIMITER, RAMP_PRICE_FOR_NON_RAMPABLE_BASE );
            currentTotalNonRampableBase = currentTotalNonRampableBase + extListPrice;
            utilResultFlag = util.putFloatAttribute( floatsDict, parentDocNum, DELIMITER, RAMP_PRICE_FOR_NON_RAMPABLE_BASE, currentTotalNonRampableBase );
        }

        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, LIST_PRICE, listPrice);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, EXT_LIST_PRICE, extListPrice);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, NET_PRICE_NON_UNIFIED, listPriceNonUnified);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, EXT_NET_PRICE_NON_UNIFIED, extListPriceNonUnified);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, PROMO_PRICE, promoPrice);
        utilResultFlag = util.putFloatAttribute(floatsDict, docNum, DELIMITER, CUSTOM_LIST_PRICE, customListPrice);
        utilResultFlag = util.putStringAttribute(stringsDict, docNum, DELIMITER, USE_CUSTOM_PRICE, useCustomPrice );
        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, "customQuantity_line", customQuantity);//CSYS-96366 SN. 07-2019
        utilResultFlag = util.putIntegerAttribute(integersDict, docNum, DELIMITER, "editQuantity_line", editQuantity);//CSYS-97422 SN. 01-2020
    }
}
//CSYS-93420 (MJ 2-27-20)
if(sizeofarray(customPricingArray) > 0 AND actionName == "updateCustomPrice"){

    if (customApprovalHistory <> ""){
        customApprovalHistory = replace(customApprovalHistory, "|", " ");
    }

    for eachItem in customPricingArray {
        customApprovalHistory = customApprovalHistory + eachItem + " Custom Pricing has occured on " + substring(datetostr(getdate()), 0, 10) + "." + DELIMITER; 
    }

    utilResultString = util.formAttrValueStr(attributesDict, "approvalHistoryCustom_quote", QUOTE_DOC_NUM, customApprovalHistory);
}

// CSYS-99177 (OK. 5-12-2020) Start
if(contractingEntity_quote <> "SAP Other" OR quoteType_quote <> NEW_BIZ)
{
    utilResultString = util.formAttrValueStr(attributesDict, "sAPSellsConcur_quote", QUOTE_DOC_NUM, "");
} 
// CSYS-99177 (OK. 5-12-2020) End
//Moved the default function of 'moreThanTwoCoresFlag' here for CSYS-61156. KA. 6-13-2016:
arraySize = sizeofarray(modelDocNumList);
if (arraySize > 2){
    utilResultString = util.formAttrValueStr(attributesDict, "moreThanTwoCoresFlag_quote", QUOTE_DOC_NUM, TRUE_STR);
}
else{utilResultString = util.formAttrValueStr(attributesDict, "moreThanTwoCoresFlag_quote", QUOTE_DOC_NUM, FALSE_STR);}

//CSYS-99477 SN. Set var to True once
if(_system_current_step_var == "pending_process"){
    utilResultString = util.formAttrValueStr(attributesDict, "saveAfterFAVR_quote", QUOTE_DOC_NUM, TRUE_STR);
}
//CSYS-99477 SN. Set var to True once
if(_system_current_step_var == "approved_process"){
    utilResultString = util.formAttrValueStr(attributesDict, "reviseAfterFAVR_quote", QUOTE_DOC_NUM, TRUE_STR);
}

//CSYS-94167 & CSYS-94755 & CSYS-97827 & CSYS-97864 (LN. 2-4-2019) (PhilS 01/24/2020) If there are only SMB Allowed Products, all with a transaction count of 20 or less, populate the Pre-defined Packages attribute with "Prime"; handled in Pricing Misc.
if(commerce.isPrimeRequired()){
    put(stringsDict, PRIME_PACKAGE_PRESENT, TRUE_STR);
}

/* ======================================================================== */
/*      Calculate Standard Discounts and Dynamically Grouped Prices         */
/* ======================================================================== */
/*if (debug) {
    printTempVal = util.printDebugHeader("Calculate Dynamically Grouped prices");
}*/
//TO DO: Investigate for encapsulation into util function
//create a dictionary that is populated with the descriptions per applied promotion only for INTERNAL_NAME xml tag. Dictionary Name: tempPromoCodeAppliedDict, Key: tempPromoCodeApplied (applied promo code), Value: description (taken from data table - PromoMessage)
tempPromoCodeAppliedDict = dict("string");

if(NOT(isempty(tempPromoCodeAppliedArr))){
    for tempPromoCodeApplied in tempPromoCodeAppliedArr{
            promoCodeDescResSet = bmql("SELECT description, descriptionType, orderNum FROM PromoMessage WHERE promotionCode=$tempPromoCodeApplied");
            internalDesc = "";
            internalDescOrder = 1;

            for resSet in promoCodeDescResSet{
                descType = get(resSet, "descriptionType");

                if(descType == "INTERNAL_NAME" AND get(resSet, "orderNum") == string(internalDescOrder)) {
                    internalDesc = internalDesc + get(resSet, "description");
                    internalDescOrder = internalDescOrder + 1;
                }

            }

            put(tempPromoCodeAppliedDict, tempPromoCodeApplied, internalDesc);
    }
}

for docNum in docNumList {
    currentAction = util.getStringAttribute( stringsDict, docNum, DELIMITER, ASSET_ACTION);
    pi = util.getStringAttribute(stringsDict, docNum, DELIMITER, PART_NUM);

    /* ------------ In this section, we loop by Model docNum -------------- */
    if (pi == "") {
        modelDocNum = docNum;
        lineItemDocNums = string[];
        lineItemDocNums = util.getStrListDict(modelToLineDocNumsDict, modelDocNum, lineItemDocNums);
        dynamicGroupingUsed = false;
        unifiedPricingUniquePOList = string[];
        /* ---------- Initialize local variables for the Model ------------ */
        modelDiscount = util.getFloatAttribute(floatsDict, docNum, DELIMITER, DISCOUNT);
        modelDiscountType = util.getStringAttribute(stringsDict, docNum, DELIMITER, DISCOUNT_TYPE);
        modelExtListPrice = 0.0;
        modelDiscountAmount = 0.0;
        modelDiscountPercent = 0.0;

        if (modelDiscountType <> AMOUNT_DISCOUNT_TYPE) {
            modelDiscountPercent = modelDiscount;
        }
        /*
        if (debug) {
            printTempVal = util.printDebugSubsection("Looping over Model docNum: " + modelDocNum, 1);
            printTempVal = util.printDebug("modelDiscount", string(modelDiscount), 1);
            printTempVal = util.printDebug("modelDiscountType", modelDiscountType, 1);
            printTempVal = util.printDebug("modelDiscountPercent", string(modelDiscountPercent), 1);
            printTempVal = util.printInternalSection("With lineDocNums: ", 1);
            print(lineItemDocNums);
        }*/

        /* --------- Loop through child line items of the Model ----------- */
        for lineDocNum in lineItemDocNums {
            //Initialize local variables
            extendedListPrice = util.getFloatAttribute(floatsDict, lineDocNum, DELIMITER, EXT_LIST_PRICE);
            disc = util.getFloatAttribute(floatsDict, lineDocNum, DELIMITER, DISCOUNT);
            discountType = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, DISCOUNT_TYPE);
            isGrouped = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, IS_GROUPED);
            childPi = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, PART_NUM);
            childPo = util.getStringAttribute(stringsDict, childPi, DELIMITER, PO_ID);
            bundleFlag = util.getStringAttribute(stringsDict, childPi, DELIMITER, BUNDLE_FLAG );
            parentDocNum = util.getStringAttribute(stringsDict, lineDocNum, DELIMITER, PARENT_DOC_NUM );
            currentAction = util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, ASSET_ACTION);

            if ( util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, PACKAGE_ID ) <> "" ){
                isGrouped = TRUE_STR;
                utilResultFlag = util.putStringAttribute( stringsDict, lineDocNum, DELIMITER, IS_GROUPED, isGrouped );
            }

            discountAmount = 0.0;
            discountPercent = 0.0;
            roundedDiscountAmount = 0.0;
            roundedDiscountPercent = 0.0;
            lineItemExtListPrice = 0.0;
            bundleID = util.getStringAttribute(stringsDict, QUOTE_DOC_NUM, DELIMITER, QUOTE_NUMBER );
            // start add-on
            if( quoteType_quote == ADD_ON ){
                if( util.getStringAttribute(stringsDict, parentDocNum, DELIMITER, CORE_ASSET_SERVICEID) <> ""){
                    //print "parentDocNum";
                    //print parentDocNum;
                    bundleID = util.getStringAttribute(stringsDict, parentDocNum, DELIMITER, CORE_ASSET_SERVICEID );
                    //print bundleID;
                }
            }

            //end add-on
            // Prep the data for unified pricing to be used in the next section. Get the unique part number list to feed to the util
            //Added By Sai Krishna -- A204 Test Script Issue Fix
            if(findinarray(unifiedPricingUniquePOList, childPo) == -1 AND currentAction <> TERMINATE_ACTION AND currentAction <> "") {
                /*print "line doc";
                print lineDocNum;
                print "asset Action";
                print currentAction;*/
                append(unifiedPricingUniquePOList, childPo);
            }
            //print "uniquePOList";
            //print unifiedPricingUniquePOList;

            /* --------- If the line item is Dynamically Grouped ----------- */
            //Bundle ID for New Business
            if( quoteType_quote <> ADD_ON ){
                if (isGrouped == TRUE_STR) {
                    //bundleID = bundleID + "-" + string(util.getIntegerAttribute( integersDict, modelDocNum, DELIMITER, SEQ_NUM ));
                    // Case 119160
                    bundleID = bundleID + "-" + modelDocNum;
                }
            }

            //Case 00105835
            currentAction = util.getStringAttribute( stringsDict, lineDocNum, DELIMITER, ASSET_ACTION);
            if( quoteType_quote == ADD_ON and (currentAction == CREATE_ACTION OR currentAction == MODIFY_ACTION) ){ //For Addon and Create line items
                assetBundleID = util.getStringAttribute( stringsDict, modelDocNum, DELIMITER,ASSETS_ORIGINAL_BUNDLE_ID); //Get the original bundle id
                tmpSplitBundleID = split(bundleID,"-");//Split on -. Bundle id could for example 2012-1234 or 2012-1234-1(when bundled)
                if (isGrouped <> TRUE_STR) {    // If not grouped
                    if (sizeofarray(tmpSplitBundleID) > 1) {
                        bundleID = tmpSplitBundleID[0] + "-"+tmpSplitBundleID[1]; //only need 2012-1234
                    }
                } else {
                    if(sizeofarray(tmpSplitBundleID) <= 2) { // the core is also bundled.
                        bundleID = bundleID + "-" + modelDocNum;
                    }
                }

            }
            //Case 00180017 - Save Discount in Dict for use in calculating discount in Net Price Section
            if (discountType <> PERCENTAGE_DISCOUNT_TYPE) {
                if (extendedListPrice > 0.0) {
                    put(unbundledExtendedListPriceDict, lineDocNum, extendedListPrice);
                }
            } //End Case 00180017 (2/3)

            utilResultFlag = util.putStringAttribute(stringsDict, lineDocNum, DELIMITER, BUNDLE_ID, bundleID );

        }
        put( stringsDict, "currentModelDocNumForUnified", docNum );
        utilResultFlag = util.getUnifiedPricingData(unifiedPricingUniquePOList, unifiedPricingDataDict, stringsDict );
        /* --------- Zero the Model's discount, if not applicable ----------- */
        if (dynamicGroupingUsed <> true) {
            modelDiscount = 0.0;
        }else{
            utilResultFlag = util.putStringAttribute( stringsDict, modelDocNum, DELIMITER, MODEL_HAS_GROUPING, TRUE_STR );
        }

        utilResultFlag = util.putFloatAttribute(floatsDict, modelDocNum, DELIMITER, EXT_LIST_PRICE, modelExtListPrice);
        utilResultFlag = util.putFloatAttribute(floatsDict, modelDocNum, DELIMITER, DISCOUNT, modelDiscount);
        utilResultFlag = util.putFloatAttribute(floatsDict, modelDocNum, DELIMITER, DISCOUNT_AMOUNT, modelDiscountAmount);
        utilResultFlag = util.putFloatAttribute(floatsDict, modelDocNum, DELIMITER, DISCOUNT_PERCENT, modelDiscountPercent);

    }
}

//CSYS-99022, Phil S, 04/13/2020, I will put this quote line loop to above line loop
bConsultativeIntelligence = false;
bServiceAdmin = false;
bServiceAdminArray = string[]{"699","706","8896","440562"};
bUserSupportDesk = false;
bPolicyAudit = false;
bIntelligence = false;
bIntelligenceArray = string[]{"512","522","532","366608"};

for line in line_process {
    poID = line.poId_line;
    assetAction = line.assetAction_line;
    if (assetAction=="CREATE"){
        if(bConsultativeIntelligence == false){  //if bConsultativeIntelligence == true, no need to check again, performance improvement
            if (poID == "203744" or poID == "329165" or poID == "346220"){bConsultativeIntelligence = true;}
        }
        if(bServiceAdmin == false){  //if bServiceAdmin == true, no need to check again, performance improvement
            if (findinarray(bServiceAdminArray,poID)<>-1){
                bServiceAdmin = true;
            }
        }
        if(bUserSupportDesk == false){
            if (poID == "832" or poID == "440590"){
                bUserSupportDesk = true;
            }
        }
        if (bPolicyAudit == false){
            if (poID == "644"){
                bPolicyAudit = true;
            }
        }
        if(bIntelligence == false){  //if bIntelligence == true, no need to check again, performance improvement
            if (findinarray(bIntelligenceArray,poID)<>-1){
                bIntelligence = true;
            }
        }
    }
}

result = result + "1" + keyDelim + "hasConsultativeIntelligence_quote" + keyDelim + string(bConsultativeIntelligence) + delim;
result = result + "1" + keyDelim + "hasServiceAdministration_quote" + keyDelim + string(bServiceAdmin) + delim;
result = result + "1" + keyDelim + "hasUserSupportDesk_quote" + keyDelim + string(bUserSupportDesk) + delim;
result = result + "1" + keyDelim + "hasPolicyAudit_quote" + keyDelim + string(bPolicyAudit) + delim;
result = result + "1" + keyDelim + "hasIntelligence_quote" + keyDelim + string(bIntelligence) + delim;

result = result + commerce.setIsBIselected(); //CSYS-99529, SN. 06/2020
result = result + commerce.setNonSystematizedReason(); //CSYS-99115, Phil S, 05/04/2020
result = result + commerce.setPaymentMethodChangedCCDD(); //CSYS-97516, Bhavna S, 11/05/2020

//CSYS-79624 (KA. 3-20-2017): call the logic that has moved:
//CSYS-95701 SN. 09-2019 Add travelAndExpenseWithTriplinkProductArr to argument list
pricingMisc = commerce.pricingMisc(attributesDict, stringsDict, assetBillingDict, QUOTE_LEVEL_RAMP_PLAN, createdDate, triggerDict, isCoreChangedDict, isEditionChangedDict, actionName, floatsDict, docNumList, listOfCore, listOfIM, QUOTE_TOTAL_EXISTING_ARR, strImpMethod, siteReviewEliteExistInQuote, siteReviewExistInQuote, consultingSessionExistInQuote, multiCountryExpExistInQuote, singleCountryExpExistInQuote, meetMgtInQuote, intelligenceReportInQuote, clientWebServiceInQuote, premierTravelExistInQuote, concurforceExistInQuote, outputDisplayRamp, conversionRate, countryIsoCode, currencyCode, PRICELIST, billingCycleNumber, termNumMonths_quote, promoCodeDetails, promoCodeApplied, autoAppliedPromotions, applicablePromotions, invalidPromoMessage, totalPromoDiscounts, integersDict, QUOTE_TRANSACTIONS, CURRENCY_SYMBOL, listOfNumOfTransPOs,  RAMP_FLAG_MULTIPLIER, errorDict, acctPartnerDiscount, incToBaseDict, businessUnit, PROD_FAM_TIER_DECREASE_OCCURRED_DICT, modelToLineDocNumsDict, numDecimals, cipPiDict, unbundledExtendedListPriceDict, promotionsDataDict, tempPromoCodeAppliedArr, tempPromoCodeAppliedDict, unifiedPricingDataDict, travelAndExpenseWithTriplinkProductArr);

//CSYS-99114 contract conversion to from concur paper to sap gtc flag
if (quoteType_quote == ADD_ON) { // 99693
    if (accountContractSource_quote == "Concur Paper") {
	if (contractSource_quote == "SAP GTC") {
	    utilResultString = util.formAttrValueStr(attributesDict, "contractConversionToSAPGTC_quote", QUOTE_DOC_NUM, TRUE_STR);
	}
	else {
	    utilResultString = util.formAttrValueStr(attributesDict, "contractConversionToSAPGTC_quote", QUOTE_DOC_NUM, FALSE_STR);
	}
    }
    else {
	utilResultString = util.formAttrValueStr(attributesDict, "contractConversionToSAPGTC_quote", QUOTE_DOC_NUM, FALSE_STR);
    }
}
else {
    utilResultString = util.formAttrValueStr(attributesDict, "contractConversionToSAPGTC_quote", QUOTE_DOC_NUM, FALSE_STR);
}

//CSYS-99331
promoBundleExtServComp ="";
resultSet = BMQL("select PromoCode from PromoBundleComp");
for r in resultSet{
	promoCodeTemp = get(r,"PromoCode");
	promoBundleExtServComp = promoBundleExtServComp + promoCodeTemp + ",";
}
result = result + "1" + keyDelim + "promoBundleExtServComp_quote" + keyDelim + promoBundleExtServComp + delim;
//end of CSYS-99331

//CSYS-99026 (OK. 06-05-2020) Set the Sales ARR Modified flag true based on Tier change and Billing Pull List date.
//we have Tier change logic in Pricing so setting this condition here, after executing the Pricing Misc function.
//Start
if(quoteType_quote == ADD_ON AND billingPullList_quote <> "")
{
    billingPullListQuarter = util.isDateWithinTheCurrentQuarter(billingPullList_quote); // Check the Billing Pull List date is within current Quarter or not.
    
    if(quoteTierChange == "true" AND billingPullListQuarter == true)
    {
        utilResultString = util.formAttrValueStr(attributesDict, "salesArrModified_quote", QUOTE_DOC_NUM, "true");
        utilResultString = util.formAttrValueStr(attributesDict, "billingPullListAlert_quote", QUOTE_DOC_NUM, "true"); //To set the ARR Disputes value in SFDC          
    }
    else {
        utilResultString = util.formAttrValueStr(attributesDict, "billingPullListAlert_quote", QUOTE_DOC_NUM, "false");                 
    }   
}
//CSYS-99026 (OK. 06-05-2020) End

return result;